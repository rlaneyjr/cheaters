<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Reducing the Number of Matches</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part280.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part282.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark502">Reducing the Number of Matches</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Sometimes the completion system will generate unwanted matches. For example, an applica- tion might create backup copies of any files you are currently working on. It is very rare that you would actually want to do anything directly with these backup files, so it can be annoying when completion matches them. Completion becomes more useful when it generates fewer matches, because an unambiguous match is more likely. For this reason, excluding such files is a useful thing to be able to do. In this section, we’ll describe the following strategies for reducing the number of matches:</p><p style="padding-top: 7pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• Restricting filename completion to only certain types of files</p><p style="padding-top: 8pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• Excluding matches that are the same as any preceding words on the command line</p><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">PASTING COMMAND LINES</p><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">PASTING COMMAND LINES</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">PASTING COMMAND LINES</p><p style="padding-top: 8pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• Not completing matches unless initial prefix characters have already been typed</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">To take reducing the number of matches to its ultimate extreme, you can disable completion entirely for certain contexts. The question is, why might you want to do this? Every now and then, you will want to use the windowing system’s cut-and-paste to copy text from another window, perhaps where you are editing your start-up file, into your shell window. It isn’t uncommon for the text being pasted to include tab characters, especially as part of initial indentation. This looks just the same to the shell as if you had pressed the Tab key directly so completion is invoked. The result is somewhat unpredictable and as a result it is one situation where disabling completion is beneficial.</p><p class="s66" style="padding-top: 6pt;text-indent: 0pt;text-align: right;">Continued</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">To take reducing the number of matches to its ultimate extreme, you can disable completion entirely for certain contexts. The question is, why might you want to do this? Every now and then, you will want to use the windowing system’s cut-and-paste to copy text from another window, perhaps where you are editing your start-up file, into your shell window. It isn’t uncommon for the text being pasted to include tab characters, especially as part of initial indentation. This looks just the same to the shell as if you had pressed the Tab key directly so completion is invoked. The result is somewhat unpredictable and as a result it is one situation where disabling completion is beneficial.</p><p class="s66" style="padding-top: 6pt;text-indent: 0pt;text-align: right;">Continued</p><p style="padding-left: 39pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">To take reducing the number of matches to its ultimate extreme, you can disable completion entirely for certain contexts. The question is, why might you want to do this? Every now and then, you will want to use the windowing system’s cut-and-paste to copy text from another window, perhaps where you are editing your start-up file, into your shell window. It isn’t uncommon for the text being pasted to include tab characters, especially as part of initial indentation. This looks just the same to the shell as if you had pressed the Tab key directly so completion is invoked. The result is somewhat unpredictable and as a result it is one situation where disabling completion is beneficial.</p><p class="s66" style="padding-top: 6pt;text-indent: 0pt;text-align: right;">Continued</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark531"><span class="s27">252 </span></a>CHAPTER 10 <span class="s28">■ </span>COMPLETION </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="507" height="542" alt="image" src="Image_215.png"/></span></p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">bash has a no_empty_cmd_completion option that, if turned on, disables command completion unless at least one character has been typed. This solves the problem for any tabs in initial indentation because command completion is always used at the beginning of a line.</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 186%;text-align: left;">The zsh equivalent of enabling no_empty_cmd_completion is to set the insert-tab style to true: zstyle &#39;:completion:*&#39; insert-tab true</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">You may find this behavior is already in operation—the default has changed between zsh versions. A slightly better option is to set the style to pending. What this does is to check whether more characters are queued up for reading. This is commonly the case when you paste text and is unusual when you are typing the char- acters. Unfortunately, it isn’t guaranteed to work on all systems.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: justify;">To disable completion more generally for a particular context, you can use the tag-order style. This isn’t fully covered until the section “Tag Ordering” in Chapter 15, but for disabling completion you won’t need to understand the full details. As an example, to disable all completion in command position, you can do this:</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">zstyle &#39;:completion:*:*:-command-:*&#39; tag-order &#39;-&#39;</p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">If you use this style it will likely be with some other zstyle context. However, the context shown in the example needs a little explanation. -command- is used to indicate completion in command position. This actually applies in slightly more cases than just the beginning of the command line, such as after pre-command modi- fiers like nice or time.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">Another issue you may have noticed when pasting text is that the output and error messages can be a bit of mess, becoming mixed up both with the input you’ve pasted and with any prompts that the shell has added. There’s a trick to get around this. It involves using a feature we won’t cover until the section “Grouping and Subshells” in Chapter 13, but it’s so simple it’s worth mentioning here. Before you paste the text, type</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">zsh% <b>{</b></p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">(This works in bash, too.) Next, paste the text. Then type a closing brace at the final prompt:</p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">cursh&gt; <b>}</b></p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: justify;">When you hit Return on that line, the whole chunk is executed at once. That’s basically all the braces do—they delimit chunks of commands to be executed by the shell in one go. That’s why the continuation prompt shows cursh—to show it’s waiting for the end of a list of commands to be run in the <i>current shell</i>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part282.htm">Excluding Certain File Types</a><a class="toc0" href="part283.htm">Ignoring Matches Based on Other Criteria</a><a class="toc0" href="part284.htm">Completing Ignored Matches</a><a class="toc0" href="part285.htm">Requiring Prefixes</a><a class="toc0" href="part286.htm">Defining Different Words to Complete</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part280.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part282.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
