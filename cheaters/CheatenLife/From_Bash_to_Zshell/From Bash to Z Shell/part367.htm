<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Accessing Extended Filesystem Attributes</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part366.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part368.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark659">Accessing Extended Filesystem Attributes</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">We’ll now present an extensive example to further demonstrate what can be done with the</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">e <span class="p">glob qualifier.</span></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Many filesystems allow for extended attributes to be associated with files beyond the basics that are common across Unix systems. The standard Linux ext2 filesystem, for instance, has a few attributes that can be changed or listed using the <span class="s33">chattr </span>and <span class="s33">lsattr </span>attributes. If you need to access these attributes, perhaps to operate on those files with the append only flag set, there will be no built-in <span class="s33">zsh </span>glob qualifier. This is a situation where a function using the <span class="s33">(e) </span>glob qualifier comes to your aid.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Such a function becomes especially useful when you consider modern filesystems such as SGI’s XFS that allow user-defined attributes to be specified for files. If you are using version 2.6 of the Linux kernel, extended attributes are supported by some other filesystems. They may need to be enabled (<span class="s33">tune2fs -o user_xattr </span><i>device </i>for ext2 and ext3). Alternatively, see the link in Appendix B for kernel patches and more information. If your filesystem or operating system don’t support extended attributes, don’t worry. The examples presented in this section may give you ideas for other things you can do from glob qualifiers along with some insight into how you can go about making those ideas work.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">getfattr </span>and <span class="s33">setfattr </span>commands allow extended attributes to be manipulated. If you are using the IRIX operating system, you may need to use the <span class="s33">attr </span>command instead but it should be straightforward to adapt our examples.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">One situation where user-defined attributes are useful is with a collection of photographs from a digital camera or scanner stored on your computer. You could use a separate database to store information about things like where and when a picture was taken, or which people or animals are featured in it, or if you’re more serious about photography, you might want to record your camera settings. When you store this information in extended attributes, directly associated with the image files, it becomes much more convenient. This is especially so when you can use a <span class="s33">zsh </span>glob qualifier to perform a query of this “database,” sending the results straight to your image viewer. To associate information you just use the <span class="s33">setfattr </span>(or similar) command:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">setfattr -n user.year -v 1990 oldpicture.jpg</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The “user” prefix is a name space. It is there for user-defined attributes. Other name spaces, such as “root”, may exist but you probably won’t have the necessary permission to use them.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_277.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 114%;text-align: justify;">■<span class="s23">Caution </span><span class="s19">Many backup programs like tar are not yet aware of extended file attributes so you may want to include a dump of the attributes (from getfattr  -d) with your backups or use a program like xfsdump that does handle them.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_278.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">To begin with, we’ll write a function that just checks for the existence of a particular attribute. The return status of <span class="s33">getfattr </span>isn’t particularly helpful so we’ll just check if it produces any output. We’ll pass the name of an attribute as a parameter:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark698"><span class="s27">342 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">fattr() {</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">[[ -n $(getfattr -n user.$1 $REPLY 2&gt;/dev/null) ]]</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 8pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">Now, we can use <span class="s33">*(e:fattr year:) </span>to pick out any files with the year attribute set. Taking</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">this further, we want to be able to query the value of the attribute. To do this, we need to save the value of the attribute in a local variable and then perform a comparison:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">fattr() {</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">local  val=$(getfattr  -n  user.$1  --only-values  $REPLY  2&gt;/dev/null) [[  -n  $val  &amp;&amp;  (  -z  $2  ||  $val  =  $~2  )  ]]</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 8pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">The first line of this function gets the value of the attribute. The <span class="s33">--only-values </span>option</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">allows us to get just the value which is more convenient for comparing. The second line then determines the return status. If no value was found, we want to return failure. If then no value was supplied for comparison to be against, it returns success. The final component of the test does the comparison of the value against <span class="s33">$~2</span>. The tilde (<span class="s33">~</span>) there turns on the <span class="s33">glob_subst </span>option, which we saw in the section “Quoted Command Substitution” in Chapter 11, for this single expansion. This allows us to do more powerful searches by treating the result of expanding <span class="s33">$2 </span>as a shell pattern.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_279.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 114%;text-align: left;">■<span class="s23">Tip </span><span class="s19">The tilde flag can be used wherever you want the result of a variable expansion to be treated as a pattern. You may have a very complex pattern that includes a particular chunk multiple times. It can even be used with globbing; try this:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">%  <b>glob=&#39;~/*(/)&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>echo $~glob</b></p><p class="s19" style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">Note that this is actually how shells other than zsh always behave.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_280.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">With this function we can now perform simple queries in our directory of photographs and have the results directed to the command line of our image viewer. For example, if I want to view all my pictures taken in Salzburg, I use the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">xv *(e:fattr place Salzburg:)</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">We can even chain together more than one test. The following views all photographs taken in Salzburg during 2002 or 2003:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">xv *(e:fattr place Salzburg:e:&#39;fattr year 200\[23\]&#39;:)</p><p style="padding-top: 8pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">Note how the pattern needs to be quoted.</p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark699">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">343</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">As you can see, writing your own functions for use in glob qualifiers is very powerful and can allow you to use filename generation in ways unimagined before.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part366.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part368.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
