<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Defining Completion Widgets</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part426.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part428.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark779">Defining Completion Widgets</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Just as <span class="s33">zle -N </span>can be used to create editor widgets, you can create completion widgets with <span class="s33">zle</span></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">-C<span class="p">. How they differ is that you also need to specify which built-in editor command’s behavior you want (</span>complete-word<span class="p">, </span>menu-complete<span class="p">, etc.) and the name of your function is required instead of being optional. The manual gives this as an example:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">zle -C complete complete-word complete-files bindkey &#39;^X\t&#39; complete</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">complete-files() { compadd - * }</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you try to write widgets like this you will soon find that they won’t work together with regular completion functions and many other things like tag loops. In the next section, we will show how you can write widgets that do interact well with the rest of the completion system.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you look at the <span class="s33">zsh </span>manual, you will see that there are two separate manpages covering the newer, function-based, completion mechanism. The first—zshcompwid—covers the low- level features such as <span class="s33">compadd </span>and <span class="s33">zle -C</span>. The second manpage—zshcompsys—is about the set of shell functions (collectively referred to as just <i>compsys</i>) that use this. In this book we have talked about aspects of the two parts interchangeably.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">As in the example above, it is quite possible to use completion widgets on their own without using compsys. But why might you want to? Back in the section “Asking the User for Input” in Chapter 13 we showed how you can use the <span class="s33">vared </span>command to read a line of input from the user with all the features of the <span class="s33">zsh </span>line editor (completion included) enabled. Suppose that you write a shell script that uses <span class="s33">vared</span>. Not using compsys means that your script doesn’t need to run <span class="s33">compinit </span>to load the entire completion system. For example, you might have a script for editing e-mail that prompts you for each of the header fields before running your normal text editor. This couldn’t be a written as a shell function if it is to be run by your e-mail program.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark817"><span class="s27">406 </span></a>CHAPTER 15 <span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you are using <span class="s33">vared </span>from a shell function instead of a script, the situation is simpler. A shell function runs directly in an interactive shell. This means that the completion system may already be enabled. The completion system includes a hook allowing you to easily define what is completed within <span class="s33">vared</span>. To use it, just set the <span class="s33">compcontext </span>variable to a string in the same form as those passed to <span class="s33">_arguments</span>. For example, a function that reads a hostname might look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">gethost() {</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">local  compcontext=&#39;hosts:host:_hosts&#39; vared  -c  -p  &#39;Enter  hostname:  &#39;  host</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part426.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part428.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
