<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Other Tips on Terminals</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part103.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part105.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark180">Other Tips on Terminals</a></h4><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">We’ll finish the chapter with a few remarks regarding interaction between editing command lines and the terminal. Unix terminal drivers—the part of the system that handles input and output for a terminal or terminal emulator—are slightly weird things. We say a little about why in the sidebar “The Terminal Driver.” We’ve already met some occasions where certain special keys are swallowed up. They were Ctrl-d at the start of the line, which meant end-of-file (EOF), Ctrl-s to stop output, and Ctrl-q to start it again.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There’s a program called <span class="s33">stty </span>that controls these settings, as well as a lot of others, many of which, we can assure you, you will not want to know about. However, it is useful to know the basics of <span class="s33">stty </span>if you are interested in customizing your own environment. The following lists the settings:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>stty -a</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">speed 38400 baud; rows 24; columns 80; line = 4;</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">intr  =  ^C;  quit  =  ^\;  erase  =  ^?;  kill  =  ^U;  eof  =  ^D;  eol  =  &lt;undef&gt;;</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">eol2 = &lt;undef&gt;; start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O; min = 1; time = 0;</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-parenb -parodd cs8 -hupcl -cstopb cread -clocal -crtscts</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">-ignbrk brkint ignpar -parmrk -inpck -istrip -inlcr -igncr icrnl ixon -ixoff</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">-iuclc -ixany imaxbel</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">opost  -olcuc  -ocrnl  onlcr  -onocr  -onlret  -ofill  -ofdel  nl0  cr0  tab0  bs0  vt0  ff0 isig  icanon  iexten  echo  echoe  echok  -echonl  -noflsh  -xcase  -tostop  -echoprt echoctl  echoke</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">This is from a Linux system using the GNU tools. Your output could be completely different, since other versions of Unix can have very different setups. However, <span class="s33">stty </span>is a program provided by the system, so it doesn’t matter if you’re using <span class="s33">bash </span>or <span class="s33">zsh </span>or any other shell.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">The settings we’re most interested in here are the three lines starting with <span class="s33">intr = ^C</span>. This means that the interrupt character is set to Ctrl-c. We met this feature and used it to interrupt a running program in the section “Starting and Stopping Processes: Signals, Job Control” in Chapter 3, but we didn’t say you could change the key. You can do so like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>stty intr &#39;^t&#39;</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">(The quotes are recommended, since <span class="s33">zsh</span>’s <span class="s33">extended_glob </span>option makes <span class="s33">^ </span>special. By the way, control characters are case insensitive; <span class="s33">^t </span>and <span class="s33">^T </span>are the same.) This makes Ctrl-t the interrupt character. You can try it by typing the following command:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>sleep 10</b></p><p class="s46" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">&lt;ctrl-t&gt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">sleep 10 </span>makes nothing happen for 10 seconds, unless you interrupt it early with Ctrl-t. Note you can only have one key doing each special task, so we freed Ctrl-c at the same time as we started using Ctrl-t. This is different from the way shells work: the shells remember what single function is assigned to each key, for every key, while the terminal driver remembers for each special function what key is assigned to it.</p><p class="s29" style="padding-top: 3pt;padding-left: 188pt;text-indent: 0pt;text-align: left;"><a name="bookmark218">CHAPTER 4 </a><span class="s28">■ </span>EN TERING AND ED ITING THE CO MMAND LIN E <span class="s27">103</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">It’s also possible to turn off special keys—that’s what the <span class="s33">&lt;undef&gt; </span>after <span class="s33">eol </span>meant. The traditional way of doing this is with the sequence <span class="s33">^-</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>stty intr &#39;^-&#39;</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">Yet some versions of <span class="s33">stty </span>understand the more logical <span class="s33">undef</span>, too. Obviously, doing this means you can’t send an interrupt from the keyboard until you redefine <span class="s33">intr</span>.</p><p style="padding-left: 40pt;text-indent: 20pt;line-height: 115%;text-align: left;">As you’ll see in the sidebar “The Terminal Driver,” not all keys known to <span class="s33">stty </span>are special inside <span class="s33">zsh</span>. On my system, at least, you only need to worry about <span class="s33">intr</span>, <span class="s33">eof</span>, <span class="s33">start</span>, and <span class="s33">stop </span>inside the shell. This is probably just as well since some of the others are rather obscure. Hence you can bind an editing command, for example, to Ctrl-z, despite the fact that it is assigned to <span class="s33">susp </span>by <span class="s33">stty</span>. (This is one of the more useful special keys used for job control; see the section “Starting and Stopping Processes: Signals, Job Control” in Chapter 3.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="569" height="494" alt="image" src="Image_143.png"/></span></p><p class="s40" style="padding-top: 11pt;padding-left: 38pt;text-indent: 0pt;text-align: center;">THE TERMINAL DRIVER</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">Why are there all these strange effects associated with terminals, and why do we need the stty command to control them?</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">In the early days of Unix, shells had no editing capabilities of their own, not even the basic ability to delete the previous character. However, a program existed that read the characters typed by the user, and sent them to the shell: the <i>terminal driver</i>. It gradually developed a few simple editing features of its own, until it grew to include all the features you can see from the output of stty -a in the main text.</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">By default, the terminal driver accepts input a line at a time; this is sometimes known as “canonical” input mode. For commands that don’t know about terminals, such as simple shells without their own editors, the terminal driver usually runs in a mode sometimes known as “cooked.” (This is Unix humor; when not in “cooked” mode, the terminal is in “raw” mode.) Here, all the special keys are used. This allows you some very primitive editing on a line of input. For these simple editing features, the command stty shown in the main text acts as a sort of bind or bindkey command.</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 10pt;text-align: left;">For example, let’s try cat, which simply copies input to output. Type the following:</p><p class="s33" style="padding-top: 8pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">% <b>cat</b></p><p class="s46" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">this is a line&lt;ctrl-u&gt;</p><p class="s33" style="padding-top: 8pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">The line disappears; that’s because of the kill stty setting. If it didn’t work, try setting the following first:</p><p class="s33" style="padding-top: 8pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">%  <b>stty  kill  &#39;^u&#39;</b></p><p class="s33" style="padding-top: 8pt;padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">This is handled entirely by the terminal driver; neither the program (cat) nor the shell knows anything about it. In “cooked” mode, the terminal passes a complete line to the program when you press Return. So cat never saw what you typed before the Ctrl-u.</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">Since not all programs want the terminal driver to handle their input, the terminal has other modes. The shell itself uses “cbreak” mode (not quite equivalent to “raw” mode), which means many of the characters which are special in “cooked” mode are passed straight through to the shell. Hence when you press Backspace in either bash or zsh, it’s the shell, not the terminal driver, that deals with it.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark219"><span class="s27">104 </span></a>CHAPTER 4 <span class="s28">■ </span>EN TERING AND ED ITING THE CO MMAND LINE </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part105.htm">Working Around Programs with Bad Terminal Handling</a><a class="toc0" href="part106.htm">Variables That Affect the Terminal</a><a class="toc0" href="part107.htm">When Unix Gets a Bit Confused about Keys</a><a class="toc1" href="part108.htm">The Carriage Return and Linefeed Confusion</a><a class="toc1" href="part109.htm">The Backspace and Erase Confusion</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part103.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part105.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
