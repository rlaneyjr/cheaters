<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>bash Example</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part396.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part398.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark749">bash Example</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">The first argument to <span class="s33">chown </span>needs to specify the new owner and group while the remaining arguments are all filenames. When calling a completion function, <span class="s33">bash </span>sets a number of special variables that tell the function information, such as what is currently on the command line and where the cursor is. These variables are shown in Table 15-1. The <span class="s33">COMP_CWORD </span>variable is partic- ularly relevant to our example. We can use it to determine if we are on the first word (and want to complete users and groups) or if we are on a subsequent word (and should complete files). So as a starting point, our example looks like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">_chown() {</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">if (( COMP_CWORD == 1 )); then</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"># <i>complete users[.groups]</i></p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">else</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"># <i>complete filenames</i></p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">fi</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">}</p><p class="s29" style="padding-top: 3pt;padding-left: 223pt;text-indent: 0pt;text-align: left;"><a name="bookmark787">CHAPTER 15 </a><span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S <span class="s27">375</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">Table 15-1. <span class="s45">bash </span><span class="s32">Special Completion Variables</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><table style="border-collapse:collapse;margin-left:40.2pt" cellspacing="0"><tr style="height:15pt"><td style="width:72pt;border-top-style:solid;border-top-width:1pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s56" style="text-indent: 0pt;text-align: left;">Variable</p></td><td style="width:114pt;border-top-style:solid;border-top-width:1pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s56" style="padding-left: 30pt;text-indent: 0pt;text-align: left;">zsh Equivalent</p></td><td style="width:193pt;border-top-style:solid;border-top-width:1pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s56" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">Purpose</p></td></tr><tr style="height:14pt"><td style="width:72pt;border-top-style:solid;border-top-width:1pt"><p class="s58" style="padding-top: 2pt;text-indent: 0pt;text-align: left;">COMP_CWORD</p></td><td style="width:114pt;border-top-style:solid;border-top-width:1pt"><p class="s58" style="padding-top: 3pt;padding-left: 31pt;text-indent: 0pt;line-height: 10pt;text-align: left;">CURRENT</p></td><td style="width:193pt;border-top-style:solid;border-top-width:1pt"><p class="s57" style="padding-top: 3pt;padding-left: 20pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Indicates the word at which the cursor is</p></td></tr><tr style="height:15pt"><td style="width:72pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:114pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:193pt"><p class="s57" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">positioned</p></td></tr><tr style="height:15pt"><td style="width:72pt"><p class="s58" style="padding-top: 3pt;text-indent: 0pt;text-align: left;">COMP_WORDS</p></td><td style="width:114pt"><p class="s58" style="padding-top: 3pt;padding-left: 31pt;text-indent: 0pt;line-height: 10pt;text-align: left;">words</p></td><td style="width:193pt"><p class="s57" style="padding-top: 3pt;padding-left: 20pt;text-indent: 0pt;line-height: 10pt;text-align: left;">An array containing the words on the</p></td></tr><tr style="height:15pt"><td style="width:72pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:114pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:193pt"><p class="s57" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">command line</p></td></tr><tr style="height:15pt"><td style="width:72pt"><p class="s58" style="padding-top: 3pt;text-indent: 0pt;text-align: left;">COMP_POINT</p></td><td style="width:114pt"><p class="s57" style="padding-top: 3pt;padding-left: 31pt;text-indent: 0pt;line-height: 10pt;text-align: left;">N/A*</p></td><td style="width:193pt"><p class="s57" style="padding-top: 3pt;padding-left: 20pt;text-indent: 0pt;line-height: 10pt;text-align: left;">The position within the current word at</p></td></tr><tr style="height:15pt"><td style="width:72pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:114pt"><p style="text-indent: 0pt;text-align: left;"><br/></p></td><td style="width:193pt"><p class="s57" style="padding-left: 20pt;text-indent: 0pt;text-align: left;">which the cursor is placed</p></td></tr><tr style="height:17pt"><td style="width:72pt"><p class="s58" style="padding-top: 3pt;text-indent: 0pt;text-align: left;">COMP_LINE</p></td><td style="width:114pt"><p class="s58" style="padding-top: 3pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">BUFFER</p></td><td style="width:193pt"><p class="s57" style="padding-top: 3pt;padding-left: 20pt;text-indent: 0pt;text-align: left;">The current command line in full</p></td></tr><tr style="height:27pt"><td style="width:72pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s58" style="padding-top: 2pt;text-indent: 0pt;text-align: left;">COMPREPLY</p></td><td style="width:114pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s58" style="padding-top: 2pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">compadd <span class="s57">built-in</span></p></td><td style="width:193pt;border-bottom-style:solid;border-bottom-width:1pt"><p class="s57" style="padding-top: 2pt;padding-left: 20pt;padding-right: 2pt;text-indent: 0pt;text-align: left;">An array containing the list of matches; set by the function and read by <span class="s58">bash</span></p></td></tr></table><p class="s66" style="padding-top: 3pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">* There is no direct equivalent in <span class="s73">zsh </span>but the same information is conveyed by the <span class="s73">PREFIX </span>and <span class="s73">SUFFIX </span>variables.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The next step is to generate some possible matches. Let’s deal with filenames first. <span class="s33">bash </span>completion functions return the list of matches in an array named <span class="s33">COMPREPLY</span>. You could use something along the lines of <span class="s33">COMPREPLY=(  *  )</span>, but there is a better way. We have seen that with the <span class="s33">-f </span>option to <span class="s33">complete </span>we can make <span class="s33">bash </span>handle filename completion internally. To use that from within a completion function, there is a <span class="s33">compgen </span>built-in. It takes many of the same options as <span class="s33">complete </span>and allows access to many internal structures that would be otherwise difficult to access. <span class="s33">compgen </span>doesn’t automatically add matches when run; it produces the list of matches as standard output and so needs to be used with command substitution (see the section “Command Substitution” in Chapter 2).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_293.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 111%;text-align: left;">■<span class="s23">Tip </span><span class="s19">compgen is not only useful in a completion function. Want a list of groups? Just type compgen -g. A list of signals? That’s compgen -A signal.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_294.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">So with command substitution, you are probably now envisioning something along the lines of <span class="s33">COMPREPLY=( $(compgen -f) )</span>. This is not all, however. <span class="s33">bash </span>does not automatically match the values supplied in <span class="s33">COMPREPLY </span>against what is currently on the command line. By passing the current word as an extra argument to <span class="s33">compgen</span>, it will match against it and only return those words that start with the current word. The current word is retrieved with</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">${COMP_WORDS[COMP_CWORD]}<span class="p">. So we now have this:</span></p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">_chown() {</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">if (( COMP_CWORD == 1 )); then</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">: <i>complete users[:groups]</i></p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">else</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">COMPREPLY=( $(compgen -f -- ${COMP_WORDS[COMP_CWORD]}) )</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">fi</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;text-indent: 0pt;text-align: right;">7</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><span class="s27">376 </span>CHAPTER 15 <span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_295.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 114%;text-align: left;">■<span class="s23">Note </span><span class="s19">If you followed the section “bash_completion” in Chapter 10 and are using the bash_completion project, you can save yourself a lot of this trouble. bash_completion includes a _filedir function that you can call to complete filenames.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_296.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Merely defining a function is not sufficient for <span class="s33">bash </span>to use it: <span class="s33">bash </span>needs to know what func- tion to associate with which command. The <span class="s33">complete </span>built-in’s <span class="s33">-F </span>option makes this possible:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">complete -F _chown chown</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you try this function out, it should complete nothing in the first argument position but complete filenames in subsequent argument positions. If you try to complete a directory, however, you may notice that it doesn’t add a trailing slash. Adding a slash to directory names is a feature of <span class="s33">bash</span>’s internal filename completion, but <span class="s33">bash </span>needs to know that it is completing filenames if it is going to enable such features. However, <span class="s33">bash </span>doesn’t know that it is completing filenames here. To tell it, you need to specify the <span class="s33">filenames </span>completion option to the <span class="s33">complete </span>built-in. So the command becomes</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">complete -F _chown -o filenames chown</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Now on to completion of the first argument. First we need to decide whether we want to complete users or groups. We can do this by checking to see if the current word already contains a dot. This is straightforward to do using pattern matching. So we need an <span class="s33">if </span>statement using <span class="s33">[[ ${COMP_WORDS[COMP_CWORD]} = *.* ]] </span>as the condition.</p><p style="padding-left: 41pt;text-indent: 17pt;line-height: 115%;text-align: left;">To complete usernames, we can use <span class="s33">compgen -u</span>. However, it would also be useful to add a dot after the username ready for the group to be specified. The <span class="s33">compgen </span>command’s <span class="s33">-S </span>option allows a suffix like this to be specified. Unfortunately it also adds a space. You can prevent this with the <span class="s33">-o nospace </span>option to <span class="s33">complete</span>, but it would then apply when completing filenames too, which would be annoying. At this point, we have</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">_chown() {</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">if (( COMP_CWORD == 1 )); then</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">if  [[  ${COMP_WORDS[COMP_CWORD]}  =  *.*  ]];  then</p><p class="s33" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">: <i>complete groups</i></p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">else</p><p class="s33" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">COMPREPLY=( $(compgen -S . -u -- $cur) )</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 8pt;line-height: 115%;text-align: left;">fi else</p><p class="s33" style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">COMPREPLY=( $(compgen -f -- ${COMP_WORDS[COMP_CWORD]}) )</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">fi</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Now finally, we need to complete group names. The hard part of this task is that it needs to</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="p">cope with the user part already being there at the beginning of the word. We do this by extracting the user part from the current word and passing that to </span>compgen <span class="p">as a prefix (with the </span>-P <span class="p">option). We’re using the current word a lot, so it helps matters if we copy it into a local variable (</span>local cur=${COMP_WORDS[COMP_CWORD]}<span class="p">). To extract the user part of the current word, we need to cut off anything following the dot. For this we can use the </span>${<i>...</i>%%<i>...</i>} <span class="p">pattern operator with a</span></p><p class="s29" style="padding-top: 3pt;padding-left: 223pt;text-indent: 0pt;text-align: left;"><a name="bookmark788">CHAPTER 15 </a><span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S <span class="s27">377</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">pattern that matches any non-dot characters. The expansion <span class="s33">${cur%%*([^.])} </span>produces the user part of the word. We now indicate to <span class="s33">compgen </span>that this should be ignored. So this would give us this for completing groups:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">COMPREPLY=(  $(compgen  -P  ${cur%%*([^.])}  -g  --  ${cur##*.})  )</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you put this into the function and give it a try, it should now work. If not, make sure you have the <span class="s33">extglob </span>option set. The <span class="s33">compgen -g </span>option is actually quite a new addition, so if you don’t have a recent version of <span class="s33">bash</span>, you may get an error message. To cope with that situation, we are going to generate our own list of groups. For most things that you will want to complete, <span class="s33">bash </span>doesn’t have a handy <span class="s33">compgen </span>option, so it is useful to be able to do this yourself.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The list of groups on a system can usually be found in the file <span class="s33">/etc/group</span>. If you look at the file, you will see that it is a colon-delimited file where each line contains not just the nameof a group but also an optional encrypted password and the list of users who are members of that group. We don’t need all that extra information so we want to filter it out. The <span class="s33">cut </span>command can do this job for us: <span class="s33">cut  -d  :  -f  1 </span>outputs just the first field in a colon-delimited file. Though we could use <span class="s33">grep</span>, it would be nice to still have <span class="s33">compgen</span>’s ability to match the words against the current word. The</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">-W <span class="p">option to </span>compgen <span class="p">or </span>complete <span class="p">allows a list of words to be supplied, so we can use that. </span>bash <span class="p">first applies word splitting to the argument supplied with </span>-W <span class="p">and then expands each resulting word. So the </span>-g <span class="p">can be replaced in the function with </span>-W &#39;$(cut -d: -f1 /etc/group)&#39;<span class="p">. Our final function looks like this:</span></p><p class="s33" style="padding-top: 6pt;padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">_chown()  { local  user</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 10pt;text-align: left;">local  cur=${COMP_WORDS[COMP_CWORD]}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">if (( COMP_CWORD == 1 )); then</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: -9pt;line-height: 115%;text-align: left;">if [[ $cur = *.* ]]; then COMPREPLY=(</p><p class="s33" style="padding-left: 76pt;text-indent: 0pt;line-height: 10pt;text-align: left;">$(compgen -P ${cur%%*([^.])} -W &#39;$(cut -d: -f1 /etc/group)&#39; -- ${cur##*.})</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">)</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">else</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">COMPREPLY=( $(compgen -S . -u -- $cur) )</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 8pt;line-height: 115%;text-align: left;">fi else</p><p class="s33" style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">COMPREPLY=( $(compgen -f -- $cur) )</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">fi</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">complete -F _chown -o filenames chown</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Using an option to the <span class="s33">complete </span>built-in you can control what happens if no matches are generated by the function. Normally, nothing will be completed, but there are a few further options. By specifying <span class="s33">-o default</span>, <span class="s33">bash </span>will revert to filename completion, and by specifying</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">-o dirnames<span class="p">, it will revert to completing directories. For a command such as </span>chown <span class="p">where we want to complete all files, we can therefore leave the explicit filename completion out of the function and instead pass </span>-o default <span class="p">to </span>complete<span class="p">. This wouldn’t help if we wanted to limit file- name completion to only some filenames, image files perhaps. </span>bash <span class="p">3 adds a </span>-o bashdefault <span class="p">option. This enables all the default completions. This includes filename completion but also</span></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark789"><span class="s27">378 </span></a>C HA P T E R 15 <span class="s28">■ </span>W R I T I NG COMP LET I ON F UNCTI ON S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">covers such things as completing usernames after a tilde and variables after a dollar sign. You will find that it is useful to specify this for most commands.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part396.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part398.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
