<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Matching a Restricted Range of Characters</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part219.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part221.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark410">Matching a Restricted Range of Characters</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Sometimes you want to match only a certain range of characters, for example only uppercase letters. To do this, you can put the characters you want to match in square brackets. This feature is usually referred to as a <i>character class</i>. In the simplest form, the square brackets contain every character allowed to match at that point in the pattern. However, it’s very commonplace for the characters allowed to be within a range of consecutive characters, such as letters or digits, so there is a shortcut for this case. You can specify this by putting the first character in the range, then a <span class="s33">- </span>(hyphen), then the last character in the range, all inside the brackets. You can even mix individual characters with ranges. Let’s consider a few examples. First, here are all the files that don’t begin with a dot:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo *</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1foo Mail MSG msg.txt</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">In the following example we echo files that start with an uppercase letter from the English alphabet:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo [A-Z]*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Mail  MSG</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark451"><span class="s27">202 </span></a>CHAPTER 9 <span class="s28">■ </span>PATTER N MATCHING </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In the following example, we specify that the first letter is either the digit <span class="s33">1 </span>or an uppercase letter:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>echo [1A-Z]*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">1foo Mail MSG</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note that the expression in brackets matches exactly one character. Therefore, in the previous example the <span class="s33">[1A-Z] </span>matched the <span class="s33">M </span>of <span class="s33">MSG </span>and the <span class="s33">* </span>matched the <span class="s33">SG</span>.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">If you place a ^ (sometimes called a <i>caret</i>) immediately after the opening bracket, the sense is negated, so the shell matches any single character that is not one you specified. (Some shells such as <span class="s33">ksh </span>use a <span class="s33">! </span>instead of a <span class="s33">^</span>; you can do that in <span class="s33">bash </span>and <span class="s33">zsh</span>, too, but in <span class="s33">zsh </span>you will need to quote the <span class="s33">! </span>at the command line to prevent it from being taken as a history reference.) Let’s consider another example:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>echo [^a-z]*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">1foo MSG</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The first character was forced to be anything except a lowercase English letter. Once again, it can’t be a dot, either, since it’s a pattern at the start of a word. In addition, you can’t match an opening dot even if you include it explicitly inside the brackets, so <span class="s33">[.]* </span>doesn’t match any files. This is probably so that it is safe to use character classes in the more complicated forms of matching that we’ll meet later.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you are wondering whether you can put one of the special characters into a character class, you can. The rules are as follows:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: justify;"><span class="s13">1. </span>A right bracket (“<span class="s33">]</span>”) to be matched literally must come immediately after the opening left bracket, except for any caret (<span class="s33">^</span>) used for negation. The following example shows a directory with three files; first we match any files ending in a right bracket or an <span class="s33">X</span>, then any files that don’t end in one of those characters:</p><p class="s33" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">% <b>ls</b></p><p class="s33" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">file0 file[1] fileX</p><p class="s33" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">% <b>echo file*[]X]</b></p><p class="s33" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">file[1] fileX</p><p class="s33" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">% <b>echo file*[^]X]</b></p><p class="s33" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">file0</p><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;"><span class="s13">2. </span>A hyphen to be matched literally must come immediately after the left bracket, except for any caret used for negation, and any right bracket. (Some versions of <span class="s33">bash </span>appar- ently don’t let you combine a hyphen and a right bracket in this way.) In the following example, we first list the files in the current directory. Then we show all files whose names end with a hyphen or a plus sign; then all files whose names end with a right bracket or a hyphen; then all files whose names don’t end with a hyphen or a right bracket.</p><p class="s29" style="padding-top: 3pt;padding-left: 280pt;text-indent: 0pt;text-align: left;"><a name="bookmark452">CHAPTER 9 </a><span class="s28">■ </span>PATTER N MATCHIN G <span class="s27">203</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>ls</b></p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">file- file+ file[0]</p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>echo *[-+]</b></p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">file- file+</p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>echo *[]-]</b></p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">file- file[0]</p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>echo *[^]-]</b></p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">file+</p><p class="s13" style="padding-top: 8pt;padding-left: 70pt;text-indent: -12pt;line-height: 114%;text-align: left;">3. <span class="p">A caret to be matched literally must not come immediately after the left bracket. In the following example, we list all files, then show all those whose names start with a plus sign or caret:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>ls</b></p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">_func +note ^readme</p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>echo [+^]*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">+note ^readme</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can also include one of the characters <span class="s33">]</span>, <span class="s33">-</span>, <span class="s33">^</span>, or <span class="s33">\ </span>in a character class by escaping it with a backslash; for example, in <span class="s33">bash [\]\-\^] </span>will match any of the three characters that are special in classes. This is usually rather easier than the rules we just listed. Unfortunately, however, <span class="s33">zsh </span>won’t let you escape a hyphen in that way—you must put the hyphen first, or after the caret for negation. A backslash also needs to be doubled to be treated literally in a character class.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part221.htm">Picking the Right Range of Characters</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part219.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part221.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
