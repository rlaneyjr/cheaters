<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Special Variables in zle</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part378.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part380.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark710">Special Variables in zle</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">In the function <span class="s33">backward-ten-word </span>we showed how altering the value of the variable <span class="s33">CURSOR </span>moved the cursor on the command line. This is one of aset of variables that have a special meaning to the line editor. Since variable substitution in <span class="s33">zsh </span>is very powerful, editing the command line with variables allows you to do quite lot without too much work.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In the following list we summarize the most common variables that have a special meaning in editor widgets. It’s not a complete set; consult the manual (<span class="s33">man zshzle</span>) for more. You can alter the values of the variables except where we note that a variable is read-only.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">These variables are only special inside <span class="s33">zle </span>widgets. You are entirely free to use variables of the same names in your own functions or on the command line, where they will behave normally. The only limitation is that you won’t be able to see global variables of the same name as a <span class="s33">zle </span>variable inside a <span class="s33">zle </span>widget.</p><p class="s29" style="padding-top: 3pt;padding-left: 241pt;text-indent: 0pt;text-align: left;"><a name="bookmark729">CHAP TER 14 </a><span class="s28">■ </span>WRITING EDITOR COMMANDS <span class="s27">351</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s46" style="padding-left: 58pt;text-indent: 0pt;text-align: left;">CURSOR<span class="p">—The character position of the cursor on the command line.</span></p><p class="s46" style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">BUFFER<span class="p">—The contents of the current editing buffer. Possibly multiple lines.</span></p><p class="s46" style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;line-height: 115%;text-align: left;">PREBUFFER<span class="p">—The contents of any lines already read, if you are editing at a continuation prompt.</span></p><p style="padding-top: 7pt;padding-left: 58pt;text-indent: 0pt;text-align: left;"><span class="s46">LBUFFER</span>—The part of <span class="s33">BUFFER </span>to the left of and above the cursor.</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;"><span class="s46">RBUFFER</span>—The part of <span class="s33">BUFFER </span>to the right of and below the cursor.</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s46">NUMERIC</span>—The numeric prefix passed by Esc <span class="s45">digit </span>or by the <span class="s33">universal-argument </span>widget. If there is none, the value is not set. Numeric prefixes are introduced later.</p><p class="s46" style="padding-top: 7pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">WIDGET<span class="p">—The name of the editor widget currently being executed.</span></p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s46">LASTWIDGET</span>—The name of the immediately previous editor widget that the user called using a key binding, or of a widget function called with <span class="s33">zle </span><span class="s45">widgetname</span>. Don’t worry if this sounds complicated; there’s a special section “Case Study 4: Chaining Widgets Together,” to illustrate the use of <span class="s33">LASTWIDGET</span>.</p><p class="s46" style="padding-top: 7pt;padding-left: 58pt;text-indent: 0pt;line-height: 115%;text-align: left;">KEYS<span class="p">—The set of keys used to execute the current widget. A raw string of characters, which may well not be printable.</span></p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">There are two pairs of variables that you will use frequently in widget functions. Alongside <span class="s33">CURSOR</span>, there is the variable <span class="s33">BUFFER</span>, which is a scalar containing the entire contents of the editing buffer after the most recent prompt. (If you are at a continuation prompt, the lines before are in <span class="s33">PREBUFFER</span>, which you can read but not alter.) Hence <span class="s33">CURSOR </span>is essentially an index into the string <span class="s33">BUFFER</span>. That means you can use <span class="s33">zsh</span>’s standard notation for subscripts in parameters, which we described in the section “Substrings” in Chapter 12. Here’s a quick reminder: variables in <span class="s33">zsh </span>such as <span class="s33">BUFFER </span>that represent a string can be followed by a number in square brackets (the subscript). A single number gives an index into the string, picking out the <i>index</i>th character in the variable’s value. A subscript consisting of two indexes with a comma in between picks out the range of characters between the two positions, including the positions of the subscripts themselves. The indexes are treated by the shell as numeric expressions, so they can contain variables like <span class="s33">CURSOR </span>that represent a number. A negative index counts from the end of the string, with -1 representing the last character. Here are a few common ways of using this feature with <span class="s33">zle </span>variables:</p><p style="padding-top: 6pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• The character at the cursor position is <span class="s33">${BUFFER[CURSOR]}</span>.</p><p style="padding-top: 8pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• The string to the left of the cursor can be extracted by <span class="s33">${BUFFER[1,CURSOR-1]}</span>.</p><p style="padding-top: 8pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• The string from the cursor to the end is <span class="s33">${BUFFER[CURSOR,-1]}</span>.</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">It’s so common to need the string before the cursor, and the string from the cursor to the end, that there are variables that let you do this: <span class="s33">LBUFFER </span>and <span class="s33">RBUFFER</span>. These are simply another way of presenting the information in <span class="s33">CURSOR </span>and <span class="s33">BUFFER</span>. All four variables can be altered; which you use is determined simply by convenience.</p><p class="s33" style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">LBUFFER <span class="p">and </span>RBUFFER <span class="p">provide a simple way of manipulating text at the variable position without needing to use subscripting. The following example, when executed inside a widget</span></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark730"><span class="s27">352 </span></a>CHAPTER 14 <span class="s28">■ </span>WRITING EDITOR CO MMANDS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">function, inserts the string <span class="s33">prefix </span>just to the left of the cursor, and the string <span class="s33">suffix </span>starting at the cursor position:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">LBUFFER=&quot;${LBUFFER}prefix&quot; RBUFFER=&quot;suffix${RBUFFER}&quot;</p><p style="padding-top: 7pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">After those assignments, the variables <span class="s33">CURSOR </span>and <span class="s33">BUFFER </span>would also reflect the changes. In other words, the value of <span class="s33">CURSOR </span>would be increased by 6 (the length of the string <span class="s33">prefix</span>) and the value of <span class="s33">BUFFER </span>would include the string <span class="s33">prefixsuffix </span>in the middle.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: right;">Note that the shell doesn’t know how to alter the cursor position when you change <span class="s33">BUFFER</span>. It makes its best guess about what to do—keep it the same. However, the shell will never leave <span class="s33">CURSOR </span>pointing off the end of <span class="s33">BUFFER</span>. It’s up to you if you want to set <span class="s33">CURSOR </span>as well as <span class="s33">BUFFER</span>.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Now you immediately have all the power of variable substitutions available. Here are a few simple things you can do; return to Chapter 12 for a quick refresher if you need to.</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;"># <i>Replace all the single quotes on the line with double quotes.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">BUFFER=${BUFFER//\&#39;/\&quot;}</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;"># <i>Move the cursor back to the last preceding uppercase letter.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;"># <i>(Note the first test, to avoid an infinite loop.)</i></p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: -9pt;line-height: 115%;text-align: left;">while [[ CURSOR -gt 1 &amp;&amp; ${RBUFFER[1]} != [[:upper:]] ]]; do (( CURSOR-- ))</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Remember that <span class="s33">zsh </span>is capable of editing multiline expressions. All the text, including the newlines, appears in <span class="s33">BUFFER </span>and the other variables. Usually, you won’t need to worry about this, since the shell will handle adding and removing of newline characters just like any other. If you need to add a newline, the easiest way is to use the special form of quoting that interprets backslashes in the same manner as the built-in command <span class="s33">print</span>: <span class="s33">$&#39;\n&#39; </span>is a single newline char- acter. Strings can include real newlines, too; in other words, just press Return in the middle of a string. The following code, when executed inside a widget function, adds an extra line <span class="s33">echo Hello </span>at the end of the editing buffer. If you press Return, the shell will execute the <span class="s33">echo </span>command after the command already on the command line (assuming that is a complete command):</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">BUFFER=${BUFFER}$&#39;\necho Hello&#39;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part378.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part380.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
