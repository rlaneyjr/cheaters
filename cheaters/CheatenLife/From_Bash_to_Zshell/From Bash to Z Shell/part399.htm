<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Adding Matches Directly</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part398.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part400.htm">Next &gt;</a></p><p class="s35" style="padding-top: 12pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark751">Adding Matches Directly</a></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">In the previous section, we used functions such as <span class="s33">_groups </span>to add matches in <span class="s33">zsh</span>. These func- tions are convenient, but for many things that you will want to complete, there won’t already be an appropriate function you can call. In this section we’ll explain how you can generate your own set of matches.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">As an example of how to add matches directly, we’ll look at how the <span class="s33">_groups </span>function itself works. Unlike <span class="s33">bash</span>, <span class="s33">zsh </span>does not use a shell variable similar to <span class="s33">COMPREPLY </span>for returning matches. Instead, a built-in named <span class="s33">compadd </span>is used. This has the distinct advantage that more information about the matches can be supplied with them. This avoids the problems we had with <span class="s33">bash </span>where the <span class="s33">-o nospace </span>option would have been useful for user completion but was better left out because it would have been a nuisance for group and filename completion.</p><p style="padding-left: 42pt;text-indent: 17pt;line-height: 115%;text-align: justify;">Using the <span class="s33">compadd </span>built-in is a simple matter of passing it your list of matches. When writing the <span class="s33">bash </span>function, we showed how to get a list of groups using the <span class="s33">cut </span>program and the <span class="s33">/etc/group </span>file. So a working <span class="s33">_groups </span>function need contain no more than this:</p><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">PARAMETER MODULE</p><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">PARAMETER MODULE</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">PARAMETER MODULE</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">compadd $(cut -d : -f 1 /etc/group)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">In order to be able to complete internal properties of the shell, some mechanism needs to be provided. In bash, that mechanism is the compgen built-in, an idea that was actually taken from early development stages of zsh’s new completion system. In zsh, it was, however, deemed preferable to have functions for completing these properties, so we have _options, _parameters, _jobs, _aliases, etc. This makes things much more consistent.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">But these functions still need to access the underlying information. The information was therefore made available in a number of shell variables. These variables are provided by the zsh/parameter and zsh/zleparameter modules. They are useful in many situations outside of completion.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">For example, there is a commands associative array that acts as an interface to the internal hash table that maps commands to their location. So when the names of commands need to be completed, the list of keys in this asso- ciative array is used. It can also be useful if you want to check if a certain command exists. Instead of writing if whence  -p  <i>command  </i>&gt;/dev/null;  then, you can write if  ((  $+commands[<i>command</i>]  ));  then.</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">In order to be able to complete internal properties of the shell, some mechanism needs to be provided. In bash, that mechanism is the compgen built-in, an idea that was actually taken from early development stages of zsh’s new completion system. In zsh, it was, however, deemed preferable to have functions for completing these properties, so we have _options, _parameters, _jobs, _aliases, etc. This makes things much more consistent.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">But these functions still need to access the underlying information. The information was therefore made available in a number of shell variables. These variables are provided by the zsh/parameter and zsh/zleparameter modules. They are useful in many situations outside of completion.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">For example, there is a commands associative array that acts as an interface to the internal hash table that maps commands to their location. So when the names of commands need to be completed, the list of keys in this asso- ciative array is used. It can also be useful if you want to check if a certain command exists. Instead of writing if whence  -p  <i>command  </i>&gt;/dev/null;  then, you can write if  ((  $+commands[<i>command</i>]  ));  then.</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">In order to be able to complete internal properties of the shell, some mechanism needs to be provided. In bash, that mechanism is the compgen built-in, an idea that was actually taken from early development stages of zsh’s new completion system. In zsh, it was, however, deemed preferable to have functions for completing these properties, so we have _options, _parameters, _jobs, _aliases, etc. This makes things much more consistent.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">But these functions still need to access the underlying information. The information was therefore made available in a number of shell variables. These variables are provided by the zsh/parameter and zsh/zleparameter modules. They are useful in many situations outside of completion.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">For example, there is a commands associative array that acts as an interface to the internal hash table that maps commands to their location. So when the names of commands need to be completed, the list of keys in this asso- ciative array is used. It can also be useful if you want to check if a certain command exists. Instead of writing if whence  -p  <i>command  </i>&gt;/dev/null;  then, you can write if  ((  $+commands[<i>command</i>]  ));  then.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">To complete usernames, the <span class="s33">_users </span>function could do something akin to this but using the</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">/etc/passwd <span class="p">file. However, </span>zsh <span class="p">already keeps track of the list of users along with their home directories in order to support the tilde expansion feature for expanding user home directories. The </span>zsh/parameter <span class="p">module, described in the sidebar “Parameter Module,” includes a variable named </span>userdirs <span class="p">that allows us to get at this information. It is an associative array mapping usernames to home directories. We’re only interested in the usernames: the keys of this asso- ciative array. We could expand them using </span>${(k)userdirs} <span class="p">but </span>compadd <span class="p">has a </span>-k <span class="p">option for just this situation. So we can execute</span></p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">compadd -k userdirs</p><p class="s29" style="padding-top: 3pt;padding-left: 223pt;text-indent: 0pt;text-align: left;"><a name="bookmark792">CHAPTER 15 </a><span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S <span class="s27">381</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 58pt;text-indent: 0pt;text-align: left;">There is also a similar <span class="s33">-a </span>option for taking the values of an array (or indeed of several arrays).</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 18pt;line-height: 110%;text-align: justify;">If we want functions like <span class="s33">_users </span>and <span class="s33">_groups </span>to be autoloadable, we still want <span class="s33">compinit </span>to be able to pick them up even though they aren’t used directly for any commands.<span class="s43">2 </span>To achieve this, instead of using the <span class="s33">#compdef </span>special tag on the first line of the file, we use <span class="s33">#autoload </span>instead.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part398.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part400.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
