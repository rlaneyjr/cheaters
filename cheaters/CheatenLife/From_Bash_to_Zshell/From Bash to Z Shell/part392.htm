<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Keeping Other Input Away from the Command Line</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part391.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part393.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark723">Keeping Other Input Away from the Command Line</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">If you use the shell’s <span class="s33">notify </span>option to tell you immediately when a background job exits, you may notice it has a neat feature that prevents the message that appears from making a mess of the line you are editing. The editor exits temporarily, then the message is printed, and then the whole command line is redrawn just as it was. If you’ve never seen that, try the following example:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>setopt notify</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>sleep 5 &amp;</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Then simply wait for the message. Type something while you’re waiting, and see how that gets redisplayed.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">There is an option to the <span class="s33">zle </span>command, <span class="s33">zle -I</span>, that provides the same behavior for you to use. If you have an ordinary shell function that often runs in the background (as in the section “Grouping and Subshells” in Chapter 13), you can use <span class="s33">zle -I </span>to make sure the output is kept tidy. One reason for that is to run a function when a timer expires or a signal is received. Here’s a function that sends you a message after 10 seconds using the signal <span class="s33">USR1</span>. Most people don’t use that signal for anything in the shell—if you already are, you will probably know, and shouldn’t try this example.</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Function to send the shell a signal in ten seconds.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">signal_me() { sleep 10</p><p class="s33" style="padding-left: 35pt;text-indent: 0pt;line-height: 10pt;text-align: center;">kill  -USR1  $$</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Function executed by the shell when it receives the signal.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">TRAPUSR1() {</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">zle -I</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">print &quot;Time&#39;s up.&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Start the first function in the background.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">signal_me &amp;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you run this function in the background and wait, you should see <span class="s33">Time&#39;s up </span>printed neatly before the line is redrawn. If you still have the <span class="s33">notify </span>option turned on, you will also see the message saying the background job finished. That’s the shell using the same display mech- anism for its own purposes.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark745"><span class="s27">368 </span></a>C HA P T E R 14 <span class="s28">■ </span>W R I T I N G E D I T O R CO M M A N D S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The two functions <span class="s33">TRAPUSR1 </span>and <span class="s33">signal_me </span>are needed because the special <span class="s33">zle </span>handling must take place in the main shell, where the line editor is running. We use the trap for that, since traps always run in the main shell when it gets a signal. The other function runs in the background, and can’t communicate directly to the line editor in the main shell.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part391.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part393.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
