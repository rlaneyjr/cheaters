<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Grouping and Subshells</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part345.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part347.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark638">Grouping and Subshells</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">Sometimes, it can be useful to group several commands together. Perhaps you want to redirect the output from several commands to a file. For an example, let’s write a backup script that backs up several disks and writes output to a log file. The <span class="s33">ufsdump </span>command allows a single file- system to be backed up. It needs to be passed some options and the name of the tape and disk devices. So we might use something like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">ufsdump 0f /dev/rmt/0n /dev/dsk/c0t1d0s0 &gt; logfile ufsdump 0f /dev/rmt/0n /dev/dsk/c0t1d0s1 &gt;&gt; logfile</p><p style="padding-top: 7pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Because there are two separate redirections, this script will close the log file and reopen it between the two commands. A more efficient method involves the grouping of commands between curly brackets, also known as <i>braces</i>, like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">{</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">ufsdump 0f /dev/rmt/0n /dev/dsk/c0t1d0s0 ufsdump 0f /dev/rmt/0n /dev/dsk/c0t1d0s1</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">} &gt; logfile</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Another use for this grouping is with job control. When we place <span class="s33">&amp; </span>after the closing brace, a single background job is created that will run both commands. So for example, to cause a build to be run in the background in an hour’s time, you might use</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">{ sleep 3600; make; } &amp;</p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark675">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">319</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">You may also have seen something similar to this that uses parentheses instead of braces. This introduces a subshell: the shell <i>forks </i>creating a copy of itself as a separate process. A subshell inherits just about everything from its parent but inside it, changes to things like the current directory, traps, or any variables are lost. This can be quite useful. The following common trick uses <span class="s33">tar </span>to copy a directory structure to another place:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">tar cvf - . | ( cd /somewhere/else; tar xvf - )</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Because the <span class="s33">cd </span>command is run in a subshell, the current directory is changed only for that subshell.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">What is perhaps more important to know about subshells is that they can be introduced indirectly in other ways with unexpected results. One way is with pipes: a pipe expects two communicating processes, but what if both commands are shell built-ins? Try executing the following in <span class="s33">bash</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>var=before</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>echo after | read var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>echo $var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">before</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">The <span class="s33">read </span>command is a built-in that reads its input into a variable. We introduce it in more detail in the section “Reading Input” later in this chapter. In this case, we would expect <span class="s33">read </span>to set the variable named <span class="s33">var </span>to <span class="s33">after</span>. So why doesn’t <span class="s33">read </span>change the variable? As you’ve prob- ably now guessed, <span class="s33">read </span>is being run in a subshell. So why does it work in <span class="s33">zsh</span>? Because <span class="s33">zsh </span>runs <span class="s33">echo </span>in a subshell instead. To be more explicit, <span class="s33">zsh </span>runs all but the last command of a pipeline in a subshell, while conversely <span class="s33">bash </span>runs all but the first. This means you can see the same effect in <span class="s33">zsh </span>with the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>echo after | read var | :</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">zsh </span>behavior is less likely to be a nuisance, but there is one case that occasionally surprises people: when you use the <span class="s33">jobs </span>command (see the section “Starting and Stopping Processes: Signals, Job Control” in Chapter 3) to determine which background jobs are running. You probably expect to be able to read the output like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>sleep 60 &amp;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>jobs | read line</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>echo $line</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh%</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">In <span class="s33">bash</span>, this works. In versions of <span class="s33">zsh </span>up to and including 4.0, you get no output, even if</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">jobs <span class="p">on its own gives you a list of jobs.</span></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The reason is that in <span class="s33">zsh </span>the <span class="s33">jobs </span>built-in is run in a subshell. This subshell, unlike the main shell, has no jobs. Therefore, there is no output. In <span class="s33">zsh </span>version 4.2 this has been fixed, but only by having <span class="s33">zsh </span>remember the list of jobs as they were when the subshell was started. It’s possible that the list has changed by the time it is recalled in the subshell, since the subshell doesn’t get to see what’s happening in the main shell. However, if you only use it to process output right away with <span class="s33">read </span>or some other command, that won’t be a problem. If you are using</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark676"><span class="s27">320 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">zsh <span class="p">4.0, you can implement a similar solution yourself by using a temporary file to remember the output, and process that:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh% <b>jobs &gt;/tmp/jobs.$$</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh% <b>read line &lt;/tmp/jobs.$$</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh% <b>rm /tmp/jobs.$$</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh% <b>echo $line</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">[1] + suspended vi foo</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_266.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: justify;">■<span class="s23">Tip </span><span class="s19">The special variable $$ (see the section “Expansion and Substitution” in Chapter 1) is a common way of creating the name of a temporary file name that’s unlikely to clash with an existing one. $$ expands to the shell’s process ID and there can only be one process with a given ID at any one time. We’ll use the same trick in the section “Trapping Signals” in this chapter.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_267.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">The other notable places where you will have a subshell is inside command substitution and process substitution. See the section “Command Substitution” in Chapter 2 and the section “Process Substitution” in Chapter 11.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part345.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part347.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
