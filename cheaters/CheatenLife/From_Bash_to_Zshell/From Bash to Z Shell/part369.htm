<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Trace Information</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part368.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part370.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark661">Trace Information</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">When debugging a program, what you need is the ability to see the steps taken by the program that led it to producing an erroneous result. With the <span class="s33">xtrace </span>option on, the shell shows each command line as it is executed. This may seem a somewhat basic mechanism, but it is actually very useful when debugging. If you are accustomed to compiled languages you may be more used to using a debugger to step through code. The problem with stepping through code is that you have to go forwards toward a problem instead of being able to work back from it. With trace information, it is often possible to isolate a problem more quickly because all the information is in front of you.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">We can see how this works from an interactive shell. If you turn on the <span class="s33">xtrace </span>option:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">set -x</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">then every time the shell executes a command, it prints <span class="s33">$PS4</span>, followed by the line to be executed after expanding variables, file patterns, and so on. The following demonstrates this directly from the <span class="s33">zsh </span>command line:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>set -x</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>echo $ZSH_NAME</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">+zsh:2&gt; <b>echo zsh</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Before executing the <span class="s33">echo</span>, <span class="s33">zsh </span>printed a line with: a <span class="s33">+</span>, which indicates a trace; the name of what was executing—here just the shell, but it could be the name of a script or function; and the line number, which is <span class="s33">2 </span>here but will be larger if your shell has been running for a while. Then it prints what it’s about to execute; note that the variable has already been expanded. <span class="s33">bash </span>behaves a little differently in detail, but the idea is very similar.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Now, if you take a script or function you can turn on the <span class="s33">xtrace </span>option at the start of it and run it again to get more information. You can also alter <span class="s33">PS4 </span>if you find you need to know other things about the state of the shell and how it is changing during the trace.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">One thing you may just be wondering about is our use of <span class="s33">set -x </span>to turn the option on here. You can use <span class="s33">setopt xtrace </span>or <span class="s33">set -o xtrace </span>if you prefer. Options that have come from the Bourne shell heritage are often known by their single letter forms. For a script, you can even specify the option as an argument to the shell:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">#!/bin/sh -x</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark700"><span class="s27">344 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;">In <span class="s33">zsh</span>, you can also enable tracing for a function by setting the <i>trace </i>attribute for it:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">functions -t <span class="s32">func</span></p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;line-height: 115%;text-align: left;">This has the advantage that you don’t need to modify the function to turn tracing on. There are two other similar options that can be useful in debugging:</p><p style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"><span class="s46">noexec </span>(or <span class="s33">-n</span>)—This prevents commands from being run and just checks the syntax.</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s46">verbose </span>(or <span class="s33">-v</span>)—This causes each command line to be printed exactly as it appears in the script before any expansion.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_281.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 114%;text-align: left;">■<span class="s23">Tip </span><span class="s19">The nounset (or -u) option can save a lot of heartache with bug hunting for misspelled variable names. Normally, expanding an unset variable results in the empty string. With the nounset option set, an error will be returned instead.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_282.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part368.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part370.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
