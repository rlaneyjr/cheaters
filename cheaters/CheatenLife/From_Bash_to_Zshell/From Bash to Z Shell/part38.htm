<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Expansion and Substitution</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part37.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part39.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark48">Expansion and Substitution</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Shells handle wildcards by <i>expansion</i>. You’ll also see the term <i>substitution </i>used for the same type of operation. If you need to use a term precisely, check your shell’s manpage. Otherwise, remember that these terms both mean “replacing something with something else.”</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Before we look at other kinds of expansion, let’s see a few examples of wildcard expansion.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">The <span class="s33">echo </span>command is handy here because it simply outputs whatever arguments the shell gives it, with a space between each argument; this lets you see what the shell’s expansion did:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo great grape goop</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">great grape goop</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo great grape goop</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">great grape goop</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo /bin/g*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">/bin/gawk /bin/gettext /bin/grep /bin/gtar /bin/gunzip /bin/gzip</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>cd /bin</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo g*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">gawk gettext grep gtar gunzip gzip</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The first two command lines had nothing to expand; those arguments were passed to <span class="s33">echo </span>as-is. In the second case, notice that the shell ignores multiple spaces. Whether you separate arguments by a single space or multiple spaces, the shell still passes only the arguments to the program—without the space. Then <span class="s33">echo </span>outputs the arguments with a single space between each. (You can pass spaces in an argument by using quoting. See the section “Control Shell</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="226" height="1" alt="image" src="Image_050.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 52pt;text-indent: -12pt;line-height: 109%;text-align: left;">1. This isn’t true if you’ve typed <span class="s29">shopt -s dotglob </span>in bash, <span class="s29">setopt glob_dots </span>in zsh, or the corresponding command in some other shells. But we don’t recommend it! See the section “Basic Globbing” in Chapter 9.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark72"><span class="s27">22 </span></a>CHAPTER 1 <span class="s28">■ </span>I N TR ODUC TION TO SHELLS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">Interpretation with Quoting” in Chapter 3.) The third and last command lines use wildcard expansion to build pathnames.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: left;">Most wildcards don’t match the slashes (<span class="s33">/</span>) in pathnames; you have to type each slash for each “level” of a pathname. For example, <span class="s33">echo /b* </span>outputs <span class="s33">/bin /boot</span>, but doesn’t output things like <span class="s33">/bin/gawk </span>or <span class="s33">/boot/grub</span>. To match those, you’d need to include the slashes, like <span class="s33">echo /b*/*</span>. Try those, if you’d like. (The Z shell has two wildcards that match slashes: <span class="s33">** </span>and</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">***<span class="p">, explained in the section “Recursive Searching” in Chapter 9.)</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: justify;">Shells can expand more than wildcards. For instance, when you ran <span class="s33">echo $SHELL </span>a while ago, the shell replaced <span class="s33">$SHELL </span>with the value of the environment variable named <span class="s33">SHELL</span>; when you typed <span class="s33">ps -p $$</span>, the shell replaced <span class="s33">$$ </span>with its own PID (the shell’s).</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In general, shells give special meaning to characters like <span class="s33">$</span>, <span class="s33">*</span>, and SPACE that aren’t letters or digits. So it’s a good idea not to use those characters in filenames (although you can if you <i>quote </i>them).</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There’s one more important question here: what happens if expansion fails? For instance, what if you type a wildcard pattern that doesn’t match? The answer is: it depends. Shells have different ways to handle this; some can be configured, and others just use their default behavior. For instance, if a wildcarded argument doesn’t match any pathname, Bourne-type shells generally pass that unexpanded argument on to the program. On C-type shells, if no argument matches, they print an error and won’t run the command line at all. (Try it if you’d like to: type <span class="s33">ls zz*zz </span>on your shell, and see if the error seems to come from your shell or from <span class="s33">ls</span>.) In C-type shells, if <i>some </i>of the arguments expand and others don’t, unmatched arguments are removed:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>echo zz*zz</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">echo: No match.</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>echo *conf zz*zz</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">fsconf linuxconf netconf userconf</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">You may not want to worry about this level of detail. We’re only mentioning it to give you a better appreciation of what shells do.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part37.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part39.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
