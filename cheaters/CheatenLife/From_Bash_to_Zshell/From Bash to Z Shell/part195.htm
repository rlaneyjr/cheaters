<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Running find in a Pipeline</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part194.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part196.htm">Next &gt;</a></p><p class="s18" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark360">Running find in a Pipeline</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">When running <span class="s33">find </span>on its own isn’t powerful enough, there are other ways of passing the names of files to other commands. One is to use <span class="s33">find -print </span>to get the list of names printed out, one per line. Then use the command <span class="s33">xargs </span>to run another command once for each line. Here’s the previous example rewritten to use the combination:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">find . -name &#39;*.o&#39; -print | xargs rm</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">xargs </span>command collects the output from <span class="s33">find </span>and runs <span class="s33">rm </span>with all the output from those lines as set of arguments. It’s therefore often faster than <span class="s33">find </span>with <span class="s33">-exec</span>, which always runs one command for each file found.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_173.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 117%;text-align: left;">■<span class="s23">Tip </span><span class="s19">Filenames may contain space characters. This is very common on Windows, which uses a lot of spaces in the names of the directories it creates for you, such as My Documents. However, the problems caused by spaces in filenames occur regardless of the operating system. Spaces cause problems for xargs when it divides up the arguments passed to it. If you want to protect against this, you can tell both find and xargs that null characters (ASCII 0) are to be used to divide up the arguments instead. This is bound to work, since nulls aren’t allowed in filenames. You need to modify both commands to tell them about the nulls:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">find . -name &#39;*.o&#39; -print0 | xargs -0 rm</p><p class="s19" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Not all versions of find and xargs understand this syntax.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_174.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Your last resort with a long list of files is to read them as a shell variable with the shell’s <span class="s33">read </span>command and then process that variable. Running <span class="s33">read </span>in a loop to read output from <span class="s33">find </span>or a similar command is a common trick we’ll meet in the section “Reading Input” in Chapter 13.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_175.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">■<span class="s23">Tip </span><span class="s19">With zsh you can often dispense with find altogether and use the shell’s built-in ability to search through directories using **. Here’s the rm example rewritten, including the list of files it’s about to delete; it looks a lot more natural as a pair of commands. Note the option -l to print to make it output one argument per line:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">zsh% <b>print -l **/*.o</b></p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">tmp/gas.o zsh/sourceforge/4_0/zsh/Src/builtin.o</p><p class="s45" style="padding-left: 50pt;text-indent: 0pt;line-height: 10pt;text-align: left;">... lots of other hits...</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">zsh%  <b>rm  **/*.o</b></p><p class="s19" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">We discuss ** in more detail in the section “Recursive Searching” in Chapter 9.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_176.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part194.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part196.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
