<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>States</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part404.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part406.htm">Next &gt;</a></p><p class="s18" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark757">States</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">For completing the list of languages supported by NEdit, a hardcoded list is not ideal: support for new languages can be added, either with new versions of NEdit or by the user. It is better to generate the list of languages automatically.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">We could write another completion function for this, but there is another way. For instance, you specify the name of a state in the <span class="s33">_arguments </span>specification. For <span class="s33">-lm</span>, it would look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&#39;-lm[specify  language  mode]:language  mode:-&gt;languages&#39;</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">Then, when <span class="s33">_arguments </span>returns, it sets a number of variables:</p><p class="s46" style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">state<span class="p">—An array containing the list of states that need to be completed.</span></p><p class="s46" style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">context<span class="p">—An array containing the zstyle context associated with each state.</span></p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s46">line</span>—A contracted version of the <span class="s33">words </span>array from which all options and their arguments have been removed.</p><p class="s46" style="padding-top: 7pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">opt_args<span class="p">—An associative array mapping options to their arguments.</span></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">In the vast majority of cases (and including this one), only one state can ever be completed at a time. You need to have something like optional arguments to options before you need to worry about handling several states. This allows us to simplify things a little: if we pass the <span class="s33">-C </span>option to <span class="s33">_arguments</span>, then the <span class="s33">context </span>array is not used and it will just put the zstyle context in the standard <span class="s33">curcontext </span>variable. This variable carries around the current context for <span class="s33">zstyle </span>throughout the completion system. Because we are now modifying all these variables, we need to declare them as being local at the top of our function. For <span class="s33">curcontext</span>, we also need to copy its existing value into it. So the upper part of our function now looks like this:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">local curcontext=&quot;$curcontext&quot; state line declare -A opt_args</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">_x_arguments -C \</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">&#39;-lm[specify  language  mode]:language  mode:-&gt;languages&#39;  \</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">...</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark797"><span class="s27">386 </span></a>CHAPTER 15 <span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="507" height="635" alt="image" src="Image_300.png"/></span></p><p class="s40" style="padding-top: 4pt;padding-left: 38pt;text-indent: 0pt;text-align: center;">NESTED EXPANSIONS</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: justify;">zsh allows expansions (${...} or $(...)) to be embedded inside another expansion. We haven’t covered the full gory details of these nested expansions. Although these are very useful, complicated expressions can easily become ugly and unreadable. They also don’t achieve much that can’t be done with more standard Unix tools like sed, awk, and even cut. They are, however, used a lot in completion functions for parsing the output of commands because they run faster than the equivalent pipeline of Unix commands. To read them, the first thing to keep in mind is that you need to start from the inside and work your way outwards.</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">For completion, the same basic constructs tend to be used. The following list relates these basic constructs to their standard Unix equivalents.</p><p class="s33" style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;">• In most cases, begin with ${(f)&quot;$(<i>command</i>)&quot;}, which turns the command output into an array of lines.</p><p class="s33" style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;">•   Where you would use grep, you can use ${(M)<i>...</i>:#<i>pattern</i>}. The (M) modifier can be removed to achieve the effect of grep  -v.</p><p class="s33" style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;">• Where you want to select specific lines such as with head and tail or sed’s d and p (with -n) commands, you can use array indexing. So just add something like [(r) *,-1] on the end.</p><p class="s33" style="padding-top: 7pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">• For sed’s s command you can use the ${<i>...</i>/<i>...</i>} and ${<i>...</i>//<i>...</i>} forms or the :s modifier. If the</p><p class="s33" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">sed regular expression uses “^” or “$” as an anchor, then the ${<i>...</i>%<i>...</i>}, ${<i>...</i>#<i>...</i>},</p><p class="s33" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;">${<i>...</i>%%<i>...</i>} and ${<i>...</i>##<i>...</i>} forms will be sufficient.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">To give you an idea of the types of things you can do and an appreciation for what we mean by complicated expressions becoming ugly and unreadable, the following is an example:</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">print -l ${${${(@f)&quot;$(&lt;/etc/passwd)&quot;}#*:*:*:*:}%%[,:]*}</p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">That takes the password file and removes chunks from the start and end of each line to leave just the real names. More specifically, this selects the fifth field on each line of /etc/passwd. To achieve this we use a pattern that alternately matches the field separator (a colon) and the contents of a field. By taking the shortest possible matches using the single # operator instead of ## we avoid the stars (*) ever matching a colon. This is a common way to select fields as you might otherwise do with cut or awk. You might think that we could use word splitting to separate the delimited fields. The difficulty in this example is that we have already split the input at line breaks and we want to pick the fifth field on every line. After word splitting, you would have one long array and taking the fifth element would return only the fifth field of the first line.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">Certainly don’t feel you have to use nested expansions for parsing. The speed difference isn’t so great and there are other tricks you can use to speed up Unix pipelines. Often one instance of sed can replace a series of simpler commands like grep and cut.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Next we need to deal with actually handling the state. If you have more than one possible state, youwill needa case statement at this point. We canget away withjust checking if the <span class="s33">state </span>variable is set. Unfortunately, NEdit doesn’t have an option that lists the available languages so we have to look inside the user’s <span class="s33">.nedit </span>configuration file. The format of this file is similar to that of an X resources file. Languages are listed starting from a line beginning with “<span class="s33">nedit.languageModes:</span>”.</p><p class="s29" style="padding-top: 3pt;padding-left: 223pt;text-indent: 0pt;text-align: left;"><a name="bookmark798">CHAPTER 15 </a><span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S <span class="s27">387</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">The next line starting with “<span class="s33">nedit.</span>” marks their end. So we can filter the file down to just these lines with <span class="s33">sed</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">sed -n &#39;/^nedit.language/,/^nedit/ p&#39; ~/.nedit</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The name of each language is surrounded by other information, but there is a tab char- acter on the left and a colon on the right. By piping the output of <span class="s33">sed </span>above to <span class="s33">cut </span>we can strip this down:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">sed -n &#39;/^nedit.language/,/^nedit/ p&#39; ~/.nedit | cut -d $&#39;\t&#39; -f 2 | cut -d : -f 1</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">This command now gives us a list of languages. Passing the list on to <span class="s33">compadd </span>is not quite as simple as just using a command substitution. Some of the languages such as “NEdit Macro” contain a space and this needs to be quoted. Using the <span class="s33">(f) </span>variable expansion flag, which was introduced in the section “Expansion Flags” in Chapter 12, we can split it into an array at newlines. So the bottom of our function looks like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">if [[ -n $state &amp;&amp; -f ~/.nedit ]]; then</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: -17pt;line-height: 115%;text-align: left;">compadd - ${(f)&quot;$(sed -n &#39;/^nedit.language/,/^nedit/ p&#39; ~/.nedit | cut -d $&#39;\t&#39; -f 2 | cut -d : -f 1)&quot;} &amp;&amp; ret=0</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">fi</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">return ret</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">(f) </span>flag is used a lot in completion functions like this. Often, the whole expression is written as a nested substitution instead of using commands like <span class="s33">sed</span>. The result may run</p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">quicker but tends to be harder to read. The sidebar “Nested Expansions” has more information about these.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part404.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part406.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
