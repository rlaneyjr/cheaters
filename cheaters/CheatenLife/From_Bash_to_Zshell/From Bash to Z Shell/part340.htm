<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Condition Tests</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part339.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part341.htm">Next &gt;</a></p><p class="s18" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark632">Condition Tests</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">There is one command that is used more often than any other in conditions: that is the <span class="s33">test </span>command and its synonym <span class="s33">[</span>.The <span class="s33">test </span>command has a variety of options that allow you to do common things like check for a file’s existence, check the type of a file, and compare two values. So for example, we can write the following to test whether a filename stored in the variable <span class="s33">file </span>has a <span class="s33">.txt </span>extension:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark666"><span class="s27">310 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: -9pt;line-height: 115%;text-align: left;">if test ${file##*.} = txt; then echo file has .txt extension</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fi</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Note that because <span class="s33">test </span>is like any other command, it can’t tell the difference between an expanded variable and a literal string. So if your variable happens to be empty or its value looks like an option, you may run into problems. This is often an issue when comparing two strings. Try this to see why:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$ <b>value=&#39;&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$ <b>[ $value = val ]</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">bash: [: =: unary operator expected</p><p style="padding-top: 8pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">More useful in this case would have been an exit status of 1 (false). Unfortunately, what the</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">[ <span class="p">command sees is exactly the same as if you had typed just</span></p><p class="s33" style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$ <b>[ = val ]</b></p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Using double quotes around variable expansions solves this dilemma. Quoting doesn’t help where you have a value that might look like an option to <span class="s33">test</span>. For this reason you may see a condition where an extra character has been added on both sides of the comparison operator, as in the following example:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">if [ X$1 = X-z ]; then</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">Due to issues such as this, there is a newer way of doing conditions. These are instead delimited by double brackets (</span>[[ <span class="s32">... </span>]]<span class="p">). They are given special handling by the shell so that they work better. Unless you need to support older shells, we would recommend using them instead.</span></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">These newer conditions are in many ways similar to the old form; they understand a similar set of condition codes. The available condition codes are listed in Table 13-1. <span class="s33">&amp;&amp; </span>and <span class="s33">|| </span>can be used within the condition as <span class="s33">AND </span>and <span class="s33">OR </span>operators, respectively (the <span class="s33">test </span>command uses <span class="s33">-a </span>and</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-o <span class="p">instead).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-bottom: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Table 13-1. <span class="s32">Conditional Expression Operators</span></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_256.png"/></span></p><p class="s48" style="padding-bottom: 2pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">Operator Purpose</p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_257.png"/></span></p><p class="s52" style="padding-top: 2pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><span class="s61">-b </span>file <span class="s51">Tests if </span>file <span class="s51">is a block special file.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><span class="s61">-c </span>file <span class="s51">Tests if </span>file <span class="s51">is a character special file.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><span class="s61">-d </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is a directory.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><span class="s61">-e </span>file <span class="s51">Tests if </span>file <span class="s51">exists.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><span class="s61">-f </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is an ordinary file.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><span class="s61">-g </span>file <span class="s51">Tests if </span>file <span class="s51">exists and has its setgid bit set.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><span class="s61">-k </span>file <span class="s51">Tests if </span>file <span class="s51">exists and has its sticky bit set.</span></p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark667">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">311</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-bottom: 4pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Table 13-1. <span class="s32">Conditional Expression Operators (Continued)</span></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_258.png"/></span></p><p class="s48" style="padding-bottom: 2pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Operator Purpose</p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_259.png"/></span></p><p class="s52" style="padding-top: 2pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-n </span>string <span class="s51">Tests if </span>string <span class="s51">is nonempty.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-o </span>option <span class="s51">Tests if </span>option <span class="s51">is turned on.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-p </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is a named pipe (fifo).</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-r </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is readable.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-s </span>file <span class="s51">Tests if </span>file <span class="s51">exists and has a size greater than zero.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-t </span>file descriptor <span class="s51">Tests if </span>file descriptor <span class="s51">is open and associated with a terminal device.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-u </span>file <span class="s51">Tests if </span>file <span class="s51">exists and has its setuid bit set.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-w </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is writable.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-x </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is executable.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-z </span>string <span class="s51">Tests if </span>string <span class="s51">is empty (length zero).</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-G </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is owned by the current group.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-L </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is a symbolic link.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-O </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is owned by the current user.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><span class="s61">-S </span>file <span class="s51">Tests if </span>file <span class="s51">exists and is a socket.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">file1 <span class="s61">-ef </span>file2 <span class="s51">Tests if the two filenames refer to the same file.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">file1 <span class="s61">-nt </span>file2 <span class="s51">Tests if </span>file1 <span class="s51">is newer than </span>file2<span class="s51">.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">file1 <span class="s61">-ot </span>file2 <span class="s51">Tests if </span>file1 <span class="s51">is older than </span>file2<span class="s51">.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">string <span class="s61">== </span>pattern <span class="s51">Tests if the string matches the pattern.</span></p><p class="s52" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;line-height: 181%;text-align: left;">string <span class="s61">!= </span>pattern <span class="s51">Tests if the string doesn’t match the pattern. </span>string1 <span class="s61">&gt; </span>string2 <span class="s51">Compares strings based on their ASCII values. </span>string1 <span class="s61">&lt; </span>string2 <span class="s51">Compares strings based on their ASCII values.</span></p><p class="s52" style="padding-bottom: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 8pt;text-align: left;">string <span class="s61">=~ </span>regex <span class="s51">Tests if the string matches the regular expression (</span><span class="s61">bash </span><span class="s51">3 only).</span></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_260.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">So for example, you might place the following in your <span class="s33">zsh </span>startup file to test whether the shell is interactive and has a terminal before running the <span class="s33">mesg </span>command:</p><p class="s33" style="padding-top: 7pt;padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">if [[ -o interactive &amp;&amp; -t 0 ]]; then mesg y</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fi</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark668"><span class="s27">312 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">mesg </span>command allows you to control whether other people have write permissions for your terminal. Write permission is necessary for others to be able to use the <span class="s33">write </span>or <span class="s33">talk </span>commands to talk to you.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">== </span>operator (which can also be written as just <span class="s33">=</span>) is worth a special mention because it is one of the most useful. It allows you to compare a string against a pattern. The patterns used are the same as those we saw in Chapter 9 for matching filenames, with the exceptions we described for variable expansions in the section “Patterns” in Chapter 12. In particular, slashes don’t have any special meaning.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">For example, the following will test if the current directory is below the current user’s home directory:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">[[ $PWD = $HOME/* ]]</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Note that it isn’t necessary to quote the pattern to protect it from filename generation.</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">[[ <span class="s32">... </span>]] <span class="p">style conditions are handled specially by the shell, so in this example, it knows not to expand </span>$HOME/* <span class="p">to the list of files in your home directory. Often, you will only want to compare against a literal string instead of a pattern. To do this, just quote any characters that have special meanings in patterns.</span></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Sometimes it is useful to do comparisons of numbers as opposed to strings. For this, there are additional operators, not listed in Table 13-1, such as <span class="s33">-eq </span>(equal) and <span class="s33">-lt </span>(less than). If you want to deal with numbers instead of strings, it is both more efficient and more readable</p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">to make use of the shells arithmetic mode. So, for example, instead of using the condition</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">[[ $val -ge 3 ]]<span class="p">, you can write </span>(( val &gt;= 3 ))<span class="p">.</span></p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note that the notions of true and false for math evaluation are similar to those used by the C programming language. This is the reverse of how the exit status of a Unix command is inter- preted. This means that if the number resulting from the math evaluation is nonzero, the return status will be zero. There are a number of useful tricks making use of this. For example, you might test whether an array is empty as follows:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">if  ((  !  ${#<span class="s32">array</span>}  ));  then</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Arithmetic mode is another thing that is specific to the more modern shells. If you want to write a script that will work in the Bourne shell, there is an <span class="s33">expr </span>command that evaluates number-based expressions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part339.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part341.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
