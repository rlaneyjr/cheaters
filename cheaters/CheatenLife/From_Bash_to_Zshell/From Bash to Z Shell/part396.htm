<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Completions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part395.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part397.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark748">Completions</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">The term <i>completions </i>is used when referring to the definitions that describe what the shell should complete depending on the existing words on the command line. To avoid confusion we use the term <i>matches </i>when referring to the list of possibilities generated by the completion system in a given situation, although you may see them referred to as <i>completions </i>elsewhere. For many commands, you will find that there is as yet no completion definition and the shell resorts to completing filenames. This will be especially true for any programs or shell scripts you have written yourself. By writing a completion for such commands, you can make the shell complete words that are valid arguments to the command. This chapter shows you how to write your own completions.</p><p class="s27" style="padding-top: 7pt;padding-left: 39pt;text-indent: 0pt;text-align: right;">371</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark784"><span class="s27">372 </span></a>CHAPTER 15 <span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">When programmable completion first appeared in <span class="s33">tcsh</span>, a <span class="s33">complete </span>built-in allowed completions to be specified using a special syntax roughly resembling <span class="s33">sed </span>expressions. <span class="s33">zsh </span>initially adopted a similar built-in—named <span class="s33">compctl</span>—but using more traditional command options. Unfortunately, these completions were hard to read and the many options meant that while writing them you had to keep the manual close at hand. Though improvements could have been made by using long options, completion definitions require more expressive power than was possible using sequences of options. Rather than define a whole new syntax, it made sense to make use of the existing <span class="s33">zsh </span>scripting language. So completions in <span class="s33">zsh </span>are now defined using shell functions. The old <span class="s33">compctl</span>-based system is not covered in this book, but it still works if you want to use it.</p><p class="s33" style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">bash <span class="p">followed </span>zsh<span class="p">’s lead with a shell function–based system that was clearly inspired by </span>zsh<span class="p">’s. In some respects, it resembles a hybrid between </span>zsh<span class="p">’s new and old systems. As you will see, its flexibility is lacking in some areas.</span></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There is quite a lot you can achieve without resorting to writing whole shell functions, however. For example, in <span class="s33">bash </span>to complete hostnames after the <span class="s33">telnet </span>command (which makes a network connection to another host) you can use</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">complete -A hostname telnet</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">-A </span>option specifies an action. In this example, the action is <span class="s33">hostname</span>, indicating that hostnames should be completed. <span class="s33">bash </span>provides a number of similar actions for completing words from particular groupings. For many of these actions, there is a short form using a single option so, for example, we can use <span class="s33">-j </span>instead of <span class="s33">-A hostname</span>. In general, it’s probably better to stick with the <span class="s33">-A </span>option because it’s more readable.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">In <span class="s33">zsh </span>the <span class="s33">_hosts </span>function performs hostname completion. So in <span class="s33">zsh</span>, you would use</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">compdef _hosts telnet</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_290.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 42pt;text-indent: 0pt;line-height: 114%;text-align: left;">■<span class="s23">Note </span><span class="s19">If you see a “command not found” error for compdef, you will need to make sure you first enable the new completion system. See the section “zsh’s compinit” in Chapter 10 for details on how to do this. Also, make sure that the directories containing zsh’s completion functions are listed in the fpath variable.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_291.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">In fact, <span class="s33">zsh </span>also has a function named <span class="s33">_telnet </span>that does a better job of completing for</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">telnet <span class="p">than merely completing hostnames.</span></p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">It is common to want to restrict completion for a command to certain types of files. In Chapter 10 we demonstrated how completion after <span class="s33">gunzip </span>is restricted to only those files it can uncompress. Completions of this kind are easy to define and are powerful enough to make a difference. For instance, you might want to restrict completion to <span class="s33">.jpg </span>image files for the <span class="s33">gimp </span>image editor. In <span class="s33">bash </span>you can specify that like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">complete -A file -X &#39;!*.jpg&#39; gimp</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In this example we specify that we want to complete filenames using the <span class="s33">file </span>action and we also specify a pattern with the <span class="s33">-X </span>option to indicate that some matches should be excluded. The pattern starts with an exclamation mark (<span class="s33">!</span>) because we want to exclude those matches that don’t match the pattern rather than those that do. If you have more than one command</p><p class="s29" style="padding-top: 3pt;padding-left: 223pt;text-indent: 0pt;text-align: left;"><a name="bookmark785">CHAPTER 15 </a><span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S <span class="s27">373</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">that uses the same completion definition, you can list all of their names as arguments to <span class="s33">complete </span>(the same applies to <span class="s33">zsh</span>’s <span class="s33">compdef</span>). Typically you also want to specify a range of file types so the pattern needs to be more complicated. So you might use the following to addition- ally complete arguments to the <span class="s33">gimp-remote </span>command and to match <span class="s33">.jpeg </span>and <span class="s33">.png </span>files:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">complete  -f  -X  &#39;!*.@(jp?(e)g|png)&#39;  gimp  gimp-remote</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">Note that you will need to have the <span class="s33">extglob </span>option turned on in your setup for this to work. It is an invaluable option when writing completions because there is a lot of pattern matching. In this example, we use the <span class="s33">-f </span>option to specify that we want to complete filenames. This is the short form of <span class="s33">-A file</span>. One noteworthy aspect of the exclusion pattern is that it also applies to directories. It is, however, quite common to want to use <span class="s33">gimp </span>to edit an image file that is in a subdirectory. Starting with version 3 of <span class="s33">bash</span>, if you pass the option <span class="s33">-o plusdirs </span>to <span class="s33">complete</span>, it will additionally complete directory names. Let’s now create a similar completion definition for <span class="s33">zsh</span>. To achieve this, you already run into the need to write a shell function. File completion is handled by a <span class="s33">_files </span>function. This supports a <span class="s33">-g </span>option that allows you to specify a glob pattern to restrict completion to certain types of files. In <span class="s33">zsh </span>4.0, you can’t specify these arguments with <span class="s33">compdef</span>.<span class="s43">1 </span>It is still very simple, however:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">_gimp() {</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">_files -g &#39;*.jpg(-.)&#39;</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">compdef _gimp gimp</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">(-.) </span>at the end of the pattern is a glob qualifier (see the section “Glob Qualifiers in zsh” in Chapter 9). This restricts the files matched to regular files or symbolic links to regular files. We do this because <span class="s33">gimp </span>expects its argument to be an image file and not something like a directory. <span class="s33">_files </span>can still complete directories, however. In the section “Ordering with File Completion” later in this chapter we show how the behavior of <span class="s33">_files </span>in this regard can be configured.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The functions that make up <span class="s33">zsh</span>’s completion system are all autoloadable. This has the advantage that functions are only loaded into memory when they are first called. As you may recall from the section “Autoloadable Functions” in Chapter 13, autoloadable functions are each stored in a separate file and the shell searches the directories listed in <span class="s33">$fpath </span>to find these files. You don’t need to use the <span class="s33">autoload </span>command to mark your completion functions for autoloading; when <span class="s33">compinit </span>runs, it looks for functions with an initial underscore (<span class="s33">_</span>) in their name and also at the first line of the file. If the first line contains a special tag, it autoloads it. So for this function, you might create a file with the following contents:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">#compdef gimp</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">_files -g &#39;*.jpg(-.)&#39;</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">If this is placed in a directory in your </span>$fpath <span class="p">when </span>compinit <span class="p">executes, it will be picked up, marked for autoloading and defined for the </span>gimp <span class="p">command. Note that the function body doesn’t need to be surrounded by </span>_gimp()  {  <i>...  </i>}<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="226" height="1" alt="image" src="Image_292.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1.   In <span class="s29">zsh </span>4.2, you can use <span class="s29">compdef  &#39;_files  -g  &quot;*.jpg(-.)&quot;&#39;  gimp</span>.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark786"><span class="s27">374 </span></a>CHAPTER 15 <span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">So far in this section, you have learned how to replace, for a particular command, the default filename completion. In our example for the <span class="s33">gimp </span>command, this meant that the names of image files could be completed for each command argument. However, many commands expect each argument to be something quite different. A shell function allows programming logic to be used to make decisions. From a function, you can therefore find out which command argument is being completed and act accordingly. To demonstrate this ability, we’ll write a function to handle completion for the <span class="s33">chown </span>command. The syntax for the <span class="s33">chown </span>command is</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">chown <i>owner file...</i></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">or</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">chown  <i>owner</i>.<i>group  file...</i></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">where we have omitted some options to make the example simpler. Our aim is to make the shell complete usernames for the first argument to <span class="s33">chown </span>and filenames for any subsequent arguments. Additionally, when completing after a dot (<span class="s33">.</span>) in the first argument, we want to complete the names of groups. Modern systems use a colon (<span class="s33">:</span>) instead of a dot to separate the user and group. Unfortunately, as was mentioned in the section “Completing Parts of Words” in Chapter 10, a colon is treated specially by <span class="s33">bash </span>and it splits the word up at the colon. This makes things a little complicated so, for <span class="s33">bash</span>, we will stick with the dot.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">We’ll write our completion function first for <span class="s33">bash </span>and then for <span class="s33">zsh</span>. Users of each shell will find it useful to still read through both sections because the shells have a fair amount in common.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part397.htm">bash Example</a><a class="toc0" href="part398.htm">zsh Example</a><a class="toc0" href="part399.htm">Adding Matches Directly</a><a class="toc0" href="part400.htm">Return Status</a><a class="toc0" href="part401.htm">Debugging Completion Functions</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part395.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part397.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
