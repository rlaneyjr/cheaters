<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>bash Startup Files</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part115.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part117.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark228">bash Startup Files</a></p><p class="s33" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">bash <span class="p">behaves differently according to which type of shell is running, for the types we just discussed. If it is a login shell, it executes the code in the following files, in this order:</span></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark240"><span class="s27">110 </span></a>CHAPTER 5 <span class="s28">■ </span>ST ARTI NG THE SHELL </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: left;">1. <span class="s33">/etc/profile</span><span class="p">, as set up by the system administrator (or maybe the person who wrote the shell package for your system).</span></p><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: justify;"><span class="s13">2. </span><span class="s33">~/.bash_profile</span>, and if that doesn’t exist, <span class="s33">bash </span>executes the file <span class="s33">~/.bash_login </span>instead, as long as that does exist. If <i>that </i>doesn’t exist either, it looks for <span class="s33">~/.profile </span>and executes that if it exists. All these are files beginning with a dot in your home directory. Note that <span class="s33">ls </span>won’t show them; you need to use <span class="s33">ls -a</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: left;">Be particularly careful with <span class="s33">~/.profile</span>, if you use that file to contain <span class="s33">bash </span>code. It is executed by the Bourne shell and all its direct descendants such as <span class="s33">ksh</span>. Putting <span class="s33">bash</span>-specific code in <span class="s33">~/.profile </span>can cause problems. On the other hand, if you use lots of different shells, it can be quite useful to put common code in this single file. For example, setting up your <span class="s33">PATH </span>or <span class="s33">CDPATH </span>variables here and marking them for export is a task common to all those shells.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: left;">If the shell isn’t a login shell but is interactive, <span class="s33">bash </span>executes the single file <span class="s33">~/.bashrc</span>. (It doesn’t execute <span class="s33">/etc/profile</span>, <span class="s33">.bash_profile</span>, <span class="s33">.bash_login</span>, or <span class="s33">.profile</span>.)</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note that no startup file is read by both login and non-login shells. If you want all interac- tive <span class="s33">bash </span>shells to run <span class="s33">~/.bashrc</span>, you can put an appropriate command in <span class="s33">~/.bash_profile</span>. The following makes <span class="s33">bash </span>execute the commands in your <span class="s33">.bashrc</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">. ~/.bashrc</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The first “<span class="s33">.</span>” is actually a command that tells the shell to read the named file (here, the file is <span class="s33">~/.bashrc</span>) like a startup file. That is, all code will be run inside the current shell instead of in a separate process. This is necessary for the shell to set options and variables. If the shell started a new process to read the file (as it would for a shell script), the current shell wouldn’t get your new settings. We’ll call this command “the dot command” to avoid too many cryptic punctuation marks in the text.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can use the dot command to split your startup files, if you like to keep things neat. For example, some people like to keep all their aliases in a separate file. (We introduced aliases back in the section “Command Lines” in Chapter 1.) Let’s call the file <span class="s33">~/.bash_aliases </span>and insert the following lines into it:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">alias l=less alias ll=&#39;ls -l&#39; alias la=&#39;ls -a&#39;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 59pt;text-indent: 0pt;text-align: left;">To execute those lines from <span class="s33">~/.bash_aliases</span>, you can put the following in both <span class="s33">.bashrc</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">and <span class="s33">.bash_profile</span>:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">. ~/.bash_aliases</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">That command executes all the lines in the file passed as the argument as if you’d typed them as input to the shell. We sometimes describe this as <i>sourcing </i>a file. That’s really slang from the C shell, which has the command <span class="s33">source </span>instead of the dot command. The phrase “sourcing a file” is a bit more understandable than “dotting a file.”</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">None of the startup files have to exist; the shell will silently carry on if one isn’t there. Generally speaking, in fact, you will want to pick one file for all your commands. For most uses, it’s probably best to stick with <span class="s33">~/.bashrc </span>and run it from other files with the dot command if you need to. If</p><p class="s29" style="padding-top: 3pt;padding-left: 275pt;text-indent: 0pt;text-align: left;"><a name="bookmark241">CHAPTER 5 </a><span class="s28">■ </span>STARTING THE SHELL <span class="s27">111</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">you use a GNU/Linux distribution, the shell package may well be configured this way, so you may only need to edit <span class="s33">~/.bashrc</span>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If the shell is not interactive, <span class="s33">bash </span>does not automatically read any of the files we just discussed. Instead, it looks for an environment variable called <span class="s33">BASH_ENV</span>. If it’s set, that variable should contain the full path to the startup file (you’ll see an example in couple of paragraphs).</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">As we said, shell scripts are typically run by a noninteractive shell. Often it’s best to write scripts so that they don’t depend on the settings from a particular startup file. Then it’s easy for other people to run the script and to move it to other machines.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">If you need a startup file for noninteractive shells, the simplest way is to have <span class="s33">bash </span>read your <span class="s33">~/.bashrc</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">export BASH_ENV=~/.bashrc</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">One more file needs mentioning for completeness: <span class="s33">~/.bash_logout </span>is run at the end of a login shell. There is no specific file run at the end of shells that aren’t login shells, but you can make the shell run <span class="s33">~/.bash_logout </span>or any other file by putting the following in <span class="s33">~/.bashrc</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">trap &#39;. ~/.bash_logout&#39; EXIT</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">A <i>trap </i>specifies code, within the quotes, for the shell to execute when something happens.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Here we’ve told the shell to source <span class="s33">~/.bash_logout </span>when it exits.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">This trap actually isn’t well designed. It makes a login shell read <span class="s33">~/.bash_logout </span><i>twice</i>. That’s because, as we said earlier, a login shell always reads <span class="s33">~/.bash_logout </span>automatically. However, a trap is run by all shells—both login and non-login. So a login shell will read</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">~/.bash_logout <span class="p">once from the trap and again automatically.</span></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The way to prevent the trap from being executed twice is only to execute the trap command if the shell isn’t a login shell. Here’s an example showing how to do that. The test itself is the command <span class="s33">shopt -q login_shell, </span>which tests whether the option <span class="s33">login_shell </span>is set:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">if  shopt  –q  login_shell;  then</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 13pt;line-height: 115%;text-align: left;"># Put the code to be executed only if the shell is a login shell here. else</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 10pt;text-align: left;"># Put the code to be executed only if the shell is not a login shell here.</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">fi</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">In this case, you should put the trap we showed in the previous example in place of the line after the <span class="s33">else</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part115.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part117.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
