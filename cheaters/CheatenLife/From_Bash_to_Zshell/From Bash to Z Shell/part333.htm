<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Associative Arrays</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part332.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part334.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark598">Associative Arrays</a></h4><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">Associative arrays are a feature specific to <span class="s33">zsh </span>and <span class="s33">ksh93</span>. Like ordinary arrays, they can contain more than one value. How they differ is that instead of being indexed by number and being in a well-defined order, they are indexed by a text string that is known as the <i>key</i>. Values in an associative array are not in any particular order. Note that elsewhere you may see associative arrays referred to as <i>hashes</i>. In this section we cover just <span class="s33">zsh</span>’s handling of associative arrays. There are a few differences in the syntax for <span class="s33">ksh93</span>, but the basic principles are the same.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">To create an associative array, you need to invoke <span class="s33">declare </span>with the <span class="s33">-A </span>option. Assignments then look like regular array assignments. The values in the assignment are expected to alternate between keys and values, so there must be an even number of them. For example, the following will create an associative array with the keys “pres”, “vicepres”, and “secr” having the values “Pamela”, “Victor”, and “Sam”, respectively:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">declare -A people</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">people=(pres Pamela vicepres Victor secr Sam)</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The keys can be used to index into the array in much the same way as for ordinary arrays. This means that assignments to individual elements are also possible. Here we add a fourth element to the associative array with the key “treas” and value “Tammy”:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">people[treas]=Tammy</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">This indexing is more useful when accessing the array, however. Here, we show the value corresponding to the key “vicepres” being retrieved:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>echo $people[vicepres]</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Victor</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you take the value of the whole associative array, all the values will be returned. To demon- strate this, observe the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>echo $people</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Sam Tammy Victor Pamela</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Again, this is entirely consistent with ordinary arrays. As we see here, elements of an asso- ciative array come in no particular order. You may even see the four values in a different order. Sometimes, it can be useful to extract the keys of an associative array. For this, the <span class="s33">k </span>variable expansion flag is used:</p><p class="s29" style="padding-top: 3pt;padding-left: 314pt;text-indent: 0pt;text-align: left;"><a name="bookmark623">CHAPTER 12 </a><span class="s28">■ </span>VARIABLES <span class="s27">301</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo ${(k)people}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">secr treas vicepres pres</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">There is also a similar <span class="s33">v </span>flag that extracts the values of an associative array. With this being the default, it may not seem very useful, but it can be combined with <span class="s33">k </span>to return both the keys and values together:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo ${(kv)people}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">secr Sam treas Tammy vicepres Victor pres Pamela</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">You may notice that this paired list of keys and values is similar to how we assigned to the associative array in the first place. This can be useful if you need to add elements to an associative array. The following line uses this feature to add a further three elements to our associative array:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">people=( ${(kv)people} driver Don clerk Clara cleaner Charles )</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">If you are using <span class="s33">zsh </span>4.2, there is actually an easier way to do this using a <span class="s33">+= </span>assignment.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">So we could instead write the previous example as follows:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">people+=( driver Don clerk Clara cleaner Charles )</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">One final point: to delete an element of an associative array, you need to use the <span class="s33">unset</span></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">built-in command. Here we delete the element with the key “pres”:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">unset &#39;people[pres]&#39;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">We’ll now consider an example use of an associative array. Back in Chapter 7 we mentioned a <span class="s33">colors </span>autoloadable function that is used by the prompt themes. This function defines asso- ciative arrays that map meaningful color names to their associated terminal escape sequences. For example, <span class="s33">$fg[red] </span>produces the output necessary to turn the text (in other words, the fore- ground) red. The variable is both more readable and easier to remember than the direct escape sequences. In Chapter 7 we showed an example that output a word in red text on a yellow back- ground using the escape sequences directly. We can rewrite that example as follows:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>autoload colors</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>colors</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo &quot;${fg[red]}${bg[yellow]}WHAM$reset_color&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">WHAM</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">In addition to allowing more readable code, the associative array is more flexible. For example, we can use the <span class="s33">k </span>subscript flag to retrieve a list of available colors:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo ${(k)bg}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">cyan white yellow magenta black blue red default green grey</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">You may see the colors listed in a different order. Remember that unlike ordinary arrays, associative arrays are not ordered. If you want, you can always sort the result using the <span class="s33">o </span>flag that we mentioned earlier:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo ${(ok)bg}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">black blue cyan default green grey magenta red white yellow</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark624"><span class="s27">302 </span></a>CHAPTER 12 <span class="s28">■ </span>VARIABLES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Another way in which the associative array is more flexible than using escape sequences directly is that you can put the name of the color in another variable. This makes it easier to make the colors used by a script configurable. For example, you might assign the name of a color to the variable <span class="s33">col </span>and then use <span class="s33">$fg[$col] </span>when outputting the escape sequence.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Bringing this all together, the following example displays all combinations of foreground and background colors. (Actually there are a few more combinations if you use the bold attribute too.) It first iterates through each background color in alphabetical order. It then uses each key to retrieve the escape code from the associative array. The inner loop is just doing exactly the same for foreground colors. This would be difficult to do without using associative arrays.</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: -9pt;line-height: 115%;text-align: left;">for bgc in ${(ko)bg}; do print -n &quot;$bg[$bgc]&quot;</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 10pt;text-align: left;">for fgc in ${(ko)fg}; do</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 8pt;line-height: 115%;text-align: left;">printf &#39;%s%-8s&#39; $fg[$fgc] $fgc done</p><p class="s33" style="padding-left: 41pt;text-indent: 9pt;line-height: 115%;text-align: left;">print $reset_color done</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part334.htm">Reverse Indexing</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part332.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part334.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
