<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Parsed Comments</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part344.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part346.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark637">Parsed Comments</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">There is another command functionally equivalent to the <span class="s33">true </span>command mentioned in the last section, it consists of just a single colon. Like <span class="s33">true</span>, the command itself doesn’t perform any useful action but the shell parses and evaluates its arguments. This is in contrast to a comment, introduced with <span class="s33">#</span>, which the shell simply ignores. As we will demonstrate, forcing the shell to evaluate a set of arguments does have some uses.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">One use of the colon command is to comment out a command that spans multiple lines.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">This might be a command with a large here-document or a command where lines end in a backslash or where quotes span several lines. When we place a colon before the command name all the lines are, in effect, commented out. Be careful if you have any commandsubstitutions, though: command substitutions are still evaluated and may have unwanted side effects. Note that you can’t use a colon to comment out multiline structures that consist of several commands such as a <span class="s33">while </span>loop or pipeline: it applies to one command only. You can use a colon to comment out a single command in a series, however. Earlier in this chapter, we showed the following example:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">grep -q word file &amp;&amp; grep -q word otherfile &amp;&amp; echo files both contain word</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If this appears in a script and you want to temporarily skip the command in the middle, you can comment out just that command alone as follows:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">grep -q word file &amp;&amp; : grep -q word otherfile &amp;&amp; echo files both contain word</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Another way you can use the colon command is to fill in an area of a script that you have yet to write while you test those parts of the script that have been written. In most cases you can leave areas blank or use conventional comments, but in some places the shell expects to find a command. To see one such place, try the following in <span class="s33">bash</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">if true; then</p><p class="s33" style="padding-top: 1pt;padding-left: 18pt;text-indent: 0pt;text-align: center;"># comment</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">fi</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">The following error is returned:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash: syntax error near unexpected token `fi&#39;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">It doesn’t like the lack of commands inside the <span class="s33">if </span>statement. By substituting <span class="s33"># </span>with <span class="s33">:</span>, it will still be a comment but this time the script will run.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark674"><span class="s27">318 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Perhaps the most common way in which the colon command is used is to give it argu- ments where the process of evaluating those arguments has side effects. There are two variable expansion forms that have a side effect. Suppose that you are writing a script that expects an environment variable, which I’ll name <span class="s33">VAR</span>, to be set. When you use an expansion of the form</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">${<span class="s32">variable</span>:?<span class="s32">error  message</span>}<span class="p">, it will print an error message and exit if the variable is not set. Your script can, therefore, use a line like this at the beginning.</span></p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">: ${VAR:?error: VAR not set}</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Another similar situation is that we may want to assign a default value for the variable. In Table 13-1 we included the <span class="s33">-z </span>condition code, which allows us to test whether a string, and hence a variable expansion, is empty. Making use of that, we could write the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">[[ -z $VAR ]] &amp;&amp; VAR=&#39;default value&#39;</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">You may remember from the previous chapter that default values can be achieved in a substitution by using the </span>${<span class="s32">variable</span>:-<span class="s32">default</span>} <span class="p">form. There is a variant of this, using an equals sign, that actually assigns the default value to the variable if the variable is unset or empty.</span></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Using this and the colon command, the equivalent of the previous example would be</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">: ${VAR:=default value}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part344.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part346.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
