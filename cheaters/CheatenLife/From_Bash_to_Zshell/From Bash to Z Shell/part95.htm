<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Conflicts between Prefixes and Editor Commands</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part94.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part96.htm">Next &gt;</a></p><p class="s18" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark171">Conflicts between Prefixes and Editor Commands</a></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">You can actually make a prefix, such as the sequence Ctrl-x-d in the previous example, into a keybinding in its own right. In <span class="s33">bash</span>, the required command is as follows:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">bash$ <b>bind &#39;&quot;\C-xd&quot;: backward-kill-word&#39;</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">This binding conflicts with the example using <span class="s33">kill-word </span>at the end of the previous section: After Ctrl-x-d, the shell doesn’t know whether you’re going to type a <i>d </i>next, to get <span class="s33">kill-word</span>. <span class="s33">bash </span>resolves this simply by waiting to see what you type next, so if you don’t type anything, nothing happens; if you then type a <i>d</i>, you get <span class="s33">kill-word</span>, and if you type anything else, the shell executes <span class="s33">backward-kill-word</span>, followed by the editor commands corresponding to whatever else you typed.</p><p class="s33" style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">zsh <span class="p">works like </span>bash <span class="p">if you type something immediately after the prefix. However, it has a bit of extra magic to avoid the shell waiting forever to see what character comes after the Ctrl-x-d. The shell variable </span>KEYTIMEOUT <span class="p">specifies a value in hundredths of a second for which the shell will wait for the next key when the keys typed so far form a prefix. If none turns up in that time, and the keystrokes so far are themselves bound to a command, then that command is executed. So let’s consider the following:</span></p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>bindkey &#39;\C-xdd&#39; kill-word</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>bindkey &#39;\C-xd&#39; backward-kill-word</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">When you’ve entered those commands, go up to the previous line, position the cursor at the start of <span class="s33">forward-word</span>, press Ctrl-x-d, and wait. You’ll find that after a short time the previous word is deleted. That’s because the default value of <span class="s33">$KEYTIMEOUT </span>is 40 in units of 100ths of a second. Why hundredths of a second? When <span class="s33">KEYTIMEOUT </span>was introduced, the shell didn’t handle numbers with a decimal point. The unit had to be small enough to be useful, and a second was too large, so hundredths of a second was chosen.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Choosing a value for <span class="s33">KEYTIMEOUT </span>is a bit of an art: It needs to be small enough that you’re not annoyed by the wait, but large enough so you have time to type a complete key sequence. There is an extra factor when you are using a shell over the network; the various keys can be sent out at any old time the network feels like, so <span class="s33">$KEYTIMEOUT </span>has to be large enough to cope with the sort of delays you get. There’s no real way of predicting this; you just have increase the value of <span class="s33">KEYTIMEOUT </span>until everything seems to work. You set it by the following assignment:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>KEYTIMEOUT=60</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Of course, you can set it to whatever value you please. To make this setting permanent put it in a startup file. Remember, there are no spaces around the <span class="s33">=</span>.</p><p class="s29" style="padding-top: 3pt;padding-left: 188pt;text-indent: 0pt;text-align: left;"><a name="bookmark210">CHAPTER 4 </a><span class="s28">■ </span>EN TERING AND ED ITING THE CO MMAND LIN E <span class="s27">95</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part94.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part96.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
