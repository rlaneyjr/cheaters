<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Command Lines</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part31.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part33.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark42">Command Lines</a></h4><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">What you type at a prompt is called a <i>command line</i>. As you’ll see, learning to use the command line is a bit like learning to speak a new language: you need to learn what words you can use and where, the punctuation, and so on. It’s easier than a language, though, because you don’t have to remember all of the things that can go on a command line. Once you’ve learned how to put together a command line, the documentation for Unix commands will show you what you can use there. There are many quick-reference guides and books with more detailed information. Your system probably also has manual pages (also called <i>manpages</i>), which provide brief summaries of what a program does and what you can put on its command line.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_030.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 42pt;text-indent: 0pt;line-height: 111%;text-align: justify;">■<span class="s23">Note </span><span class="s19">We’re introducing features here, showing what the shell can do. Don’t be concerned about learning every detail.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_031.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_032.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 114%;text-align: justify;">■<span class="s23">Definition </span><span class="s19">Unix-like systems have a program named man that displays manual pages—manpages for short. Each program, such as date, has its own manual page, and so does each shell. Commands that are built into a shell, which we’ll see later—cd, for instance—are covered in the shell’s manpage.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s19" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">Another man-like program is named info. If man doesn’t show a manpage, try info instead.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_033.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you’re just getting started with Unix, you may want more information than you can get from some manual pages. Still, they can be helpful as a quick introduction or reminder. Let’s try reading the manual page for <span class="s33">date </span>by typing <span class="s33">man date </span>at a prompt. You should see something like this:</p><p class="s29" style="padding-top: 3pt;padding-left: 258pt;text-indent: 0pt;text-align: left;"><a name="bookmark59">CHAPTER 1 </a><span class="s28">■ </span>INTRODUCTION TO SH ELLS <span class="s27">9</span></p><p class="s33" style="padding-top: 24pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>man date</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">DATE(1) FREE SOFTWARE FOUNDATION DATE(1)</p><p class="s33" style="padding-top: 13pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">NAME</p><p class="s33" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">date - print or set the system date and time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">SYNOPSIS</p><p class="s33" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">date [OPTION]... [+FORMAT]</p><p class="s33" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;text-align: left;">date  [OPTION]  [MMDDhhmm[[CC]YY][.ss]]</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">DESCRIPTION</p><p class="s33" style="padding-top: 1pt;padding-left: 71pt;text-indent: 0pt;line-height: 115%;text-align: left;">Display  the  current  time  in  the  given  FORMAT,  or  set  the system  date.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s32" style="padding-left: 49pt;text-indent: 0pt;text-align: left;">...parts omitted...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">-u, --utc, --universal</p><p class="s33" style="padding-top: 1pt;padding-left: 103pt;text-indent: 0pt;text-align: left;">print or set Coordinated Universal Time</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 71pt;text-indent: 0pt;text-align: left;">--help display this help and exit</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">--More--(15%) <b>q</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 17pt;line-height: 115%;text-align: left;">The command line that you typed told your shell to run a program called <span class="s33">man</span>; it also told <span class="s33">man </span>that you want information about the <span class="s33">date </span>program. This is a lot like going to the menu with a mouse, selecting Programs, then System Accessories, choosing manuals to start the manuals program, pulling down the program’s File menu, choosing the Open Manual page entry, moving the mouse to the dialog box, choosing <span class="s33">date </span>from a series of drop-down lists (because there are literally hundreds of manual pages), and then clicking the OK button. This is a simple example of how much faster a shell can be to use than a window system—once you’ve learned the basics of shells, that is.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Back to our example. As we’ve just shown, when <span class="s33">man </span>starts, your screen will probably fill with text, and then pause. The last line of your screen will have a prompt like a colon (<span class="s33">:</span>) character— or, as we’ve shown here, the word “More”. What’s happening? The <span class="s33">man </span>program (actually, another program called a pager) is pausing and prompting you to give a command. At the pager’s prompt, you can press the spacebar (or maybe Return) for the next page, <span class="s33">q </span>to quit, and probably (depending on your system) commands that scroll back, search, and more.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_034.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 111%;text-align: left;">■<span class="s23">Definition </span><span class="s19">A pager is a program that displays text page by page—or, actually, screenful by screenful. Three common pagers are named more, less, and pg.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_035.png"/></span></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark60"><span class="s27">10 </span></a>CHAPTER 1 <span class="s28">■ </span>I N TR ODUC TION TO SHELLS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">After you look over this first part of the <span class="s33">date </span>manpage, type <span class="s33">q </span>to quit the pager program. When <span class="s33">man </span>sees the pager program exit, <span class="s33">man </span>will exit too. Your shell has been waiting for <span class="s33">man </span>to finish; now that it’s done, you should see another shell prompt.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s take a closer look at the command-line syntax of Unix programs. <i>Syntax </i>means the formal properties of a language, or what you can put on a command line and where.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• The first component of a command line (after the prompt) is typically the name of a program or command. (As the section “Where the Commands Are Located” in this chapter explains, the shell can run programs both from external files and from built-in commands that are part of the shell.) The first program we’ve used was <span class="s33">date</span>. The second program was <span class="s33">man</span>, which we we’re using to show the manpage for <span class="s33">date</span>. (The <span class="s33">man </span>program actually started a pager program, but the shell doesn’t know that.)</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• The rest of the command line varies. We won’t try to cover all of the possibilities here; this is part of what gives Unix and the shells so much flexibility. In general, though, after the program or command name you can add <i>arguments</i>. (This term comes from mathe- matics and is similar to the arguments to an equation.) These tell the program how to work or what to work on—basically, they control the overall operation of the program. For instance, in the command line <span class="s33">man date</span>, the program name is <span class="s33">man</span>, and <i>date </i>is its only argument.</p><p style="padding-top: 7pt;padding-left: 57pt;text-indent: 0pt;text-align: left;">• The SYNOPSIS section of a program’s manual page gives a very brief syntax summary.</p><p style="padding-top: 8pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• One important type of argument is an <i>option</i>. It changes the way that a command works. An option usually starts with one or two dash (<span class="s33">-</span>) characters. (One example is the <span class="s33">-u </span>option that we gave to the <span class="s33">date </span>program earlier.) Options usually come first on a command line, before other arguments. You’ll find a list of a program’s options in its manpage, often near the top. The <span class="s33">date </span>manpage, for example, lists <span class="s33">-u </span>(which starts with a single dash) and another common option, <span class="s33">--help </span>(which starts with two dashes).</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: left;">Let’s wrap this section up by typing <span class="s33">date --help </span>at a prompt. If it works, you can bet that many other programs on your system probably also accept the <span class="s33">--help </span>option:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">$ <b>date --help</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Usage: date [OPTION]... [+FORMAT]</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">or:    date  [OPTION]  [MMDDhhmm[[CC]YY][.ss]]</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Display the current time in the given FORMAT, or set the system date.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s32" style="padding-left: 50pt;text-indent: 0pt;text-align: left;">...omitted...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;text-align: left;">-u,  --utc,  --universal       print  or  set  Coordinated  Universal  Time</p><p class="s33" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">--help  display this help and exit</p><p class="s33" style="padding-top: 1pt;padding-left: 29pt;text-indent: 0pt;text-align: center;">--version                     output  version  information  and exit</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">FORMAT controls the output. The only valid option for the second form specifies Coordinated Universal Time. Interpreted sequences are:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;text-align: left;">%a locale&#39;s abbreviated weekday name (Sun..Sat)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s32" style="padding-left: 50pt;text-indent: 0pt;text-align: left;">...omitted...</p><p class="s29" style="padding-top: 3pt;padding-left: 258pt;text-indent: 0pt;text-align: left;"><a name="bookmark61">CHAPTER 1 </a><span class="s28">■ </span>INTRODUCTION TO SH ELLS <span class="s27">11</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you didn’t see the first part of the <span class="s33">date --help </span>output, and if your terminal or window can scroll through previous output, you may be able to scroll back to the start. You can also view long output with a pager (as we saw in the section “Command Lines” in this chapter).</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">As the help message showed, your version of <span class="s33">date </span>may accept a format argument. This is a shorthand way to tell the <span class="s33">date </span>command exactly what to show. Here’s an example; be sure to type it carefully:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>date &quot;+Today is %x, day number %j of %Y.&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Today is 11/20/04, day number 325 of 2004.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">If that looks cryptic, don’t worry: most Unix commands aren’t that messy. (<span class="s33">date</span>’s format was designed for programmers.) And, if you like to check the date that way, you don’t have to type that long command every time. Almost all shells provide <i>aliases </i>or <i>functions</i>, which let you abbreviate one or more command lines to a single word.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_036.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 111%;text-align: left;">■<span class="s23">Definition </span><span class="s19">The shell’s alias is a single word that the shell expands into a complete command line. A shell function can contain one or many commands; like an alias, it’s called by a one-word name.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_037.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">For instance, you can make an alias called <span class="s33">mydate </span>to run the long command line above. The ways you can do this vary from shell to shell, as we’ll see in the section the section “Shell Types and Versions,” later in this chapter. Some shells use an equal sign (<span class="s33">=</span>) after the alias name (as shown in the first example that follows), and others use a space (as shown in the second example). If the first way doesn’t work, try the second. Note that the outer quotes are apostrophes (<span class="s33">&#39; </span>or <i>accents aigus</i>), often called <i>single </i>quotes by shell users, but <span class="s47">not </span>backquotes (<span class="s33">` </span>or <i>accents graves</i>):</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$  <b>alias  mydate=&#39;date  &quot;+Today  is  %x,  day  number  %j  of  %Y.&quot;&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>mydate</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Today is 11/20/04, day number 325 of 2004.</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">%  <b>alias  mydate  &#39;date  &quot;+Today  is  %x,  day  number  %j  of  %Y.&quot;&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>mydate</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Today is 11/20/04, day number 325 of 2004.</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">%</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">We’ve jumped ahead to advanced topics without explaining much about them. (We do that in these introductory chapters to introduce a lot of shell features in a short time.) You’ll learn more about aliases in the section “Command Lines” in this chapter and about quoting (the <span class="s33">&quot; </span>and <span class="s33">&#39; </span>marks) in the section “Control Shell Interpretation with Quoting” in Chapter 3.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Aliases are one of the many ways a shell can save you time by storing shortcuts and simpli- fying complex commands. Keep in mind, however, that the shell will forget many of its settings when you close the shell (close its window, shut down your system, and so on). If you want to</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark62"><span class="s27">12 </span></a>CHAPTER 1 <span class="s28">■ </span>I N TR ODUC TION TO SHELLS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">use the <span class="s33">mydate </span>alias every time you use a shell, store the alias in your shell startup file; see the section “Startup Files, Login and Interactive Shells” in Chapter 5.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Let’s try one more Unix program. The <span class="s33">cal </span>program prints a calendar for any month or year between 1 and 9999 AD (CE). With no argument, it prints this month’s calendar. To see how it works, run the next three examples. In the second example, substitute the month and year you were born, and be sure to use all four digits of the year:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">cal</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">cal 5 1973</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">cal 1752</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 19pt;line-height: 115%;text-align: justify;">If you’re wondering why the calendar for September 1752 is short, it’s because that’s when many countries switched to the Gregorian calendar.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="568" height="435" alt="image" src="Image_038.png"/></span></p><p class="s40" style="padding-top: 11pt;padding-left: 158pt;text-indent: 0pt;text-align: left;">WHAT’S HAPPENING: PROCESSES</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">To get the most from a shell, it’s important to understand what’s happening—what the shell and the system do as you use the shell.</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">One of the most important concepts to understand about a Unix system is that a program is run (“executed”) in a <i>process</i>. A process is a program that’s running in memory. (The program comes from an executable file— which typically is stored on a hard disk.) A process keeps track of the state of a program: whether it’s running or stopped, its current directory (in the filesystem tree, which we’ll see later), its environment variables (a list of names and values), and more.</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">Each process has a unique identifying number called its <i>PID </i>(process identifier). When a program starts, the system gives a PID to the process. That PID stays the same until the process exits. You can use the PID to get information about the process and to control it.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">All PIDs are between 1 and 30,000 or so. PIDs are assigned in order, depending on when a process starts. Once the top PID (like 30000) has been assigned, the system starts over at low numbers, reusing PIDs from old processes that have since finished. Some “system” processes start when your system starts and keep running until you shut it down. For example, PID 1 is the program called init.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">A process (called the <i>parent process</i>) can start one or more other process (called <i>child processes</i>, or <i>subprocesses</i>). The init process is the ancestor of all other processes—its children, their children, and so on.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">The shell can start its own child processes. In fact, this is what happens when you type most command lines: the shell starts a child process, waits for it to finish, then outputs another prompt.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">The following graphic shows what happened when you ran the cal program a moment ago. The diagram shows a Z shell and some PIDs that we made up, but the basic idea is the same for all shells. The shell waits for you to type a command line. When you press Return, the shell finds the cal program and runs it as a child process. When cal finishes, its process terminates; the zsh process is still there, waiting for you to type another command line.</p><p class="s29" style="padding-top: 3pt;padding-left: 258pt;text-indent: 0pt;text-align: left;"><a name="bookmark63">CHAPTER 1 </a><span class="s28">■ </span>INTRODUCTION TO SH ELLS <span class="s27">13</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="506" height="688" alt="image" src="Image_039.png"/></span></p><p class="s48" style="padding-top: 8pt;padding-left: 173pt;text-indent: 0pt;text-align: left;">What’s Happening: Processes</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 9pt;padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">To see a listing of some of your processes, type the command ps  -l. (The option is a lowercase letter “L”; it means “long format”.) Here’s an example:</p><p class="s33" style="padding-top: 7pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">$ <b>ps -l</b></p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">... PID PPID ... TIME COMMAND</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">... 729 1 ... 0:03.10 zsh</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">... 793 729 ... 0:00.09 ps</p><p class="s33" style="padding-top: 8pt;padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">We’ve left out most of the information. This listing shows two processes: zsh has PID 729 and PPID (parent’s PID) of 1 (which, as we know, is the init process). In this case, ps is also showing itself (after all, it’s a process too!): its PID is 793 and its PPID is 729, which is assigned to the shell that started ps (where you typed its name at a shell prompt).</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">In the section “Starting and Stopping Processes: Signals, Job Control” in Chapter 3, we’ll explore what you can do with all of this information: controlling processes, putting them in the background, and more. We’ll also cover <i>jobs</i>, which is a term for one or more processes that can be controlled as a unit. For now, remember that most (but not all) command lines start one (or more) new processes.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark64"><span class="s27">14 </span></a>CHAPTER 1 <span class="s28">■ </span>I N TR ODUC TION TO SHELLS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part31.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part33.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
