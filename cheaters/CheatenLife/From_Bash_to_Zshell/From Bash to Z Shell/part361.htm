<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Trapping Signals</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part360.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part362.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark653">Trapping Signals</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">In the section “Starting and Stopping Processes: Signals, Job Control” in Chapter 3, we learned how to send signals to a process using either the <span class="s33">kill </span>command or with special key combina- tions such as Ctrl-z. Using traps, these signals can be picked up within the shell allowing you to run shell code in response. This concept is perhaps best illustrated with an example. A typical use of traps is to clear up any temporary files if the script is interrupted by the user with Ctrl-c:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">trap &#39;rm /tmp/temp-$$; exit&#39; INT TERM</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note how we include an <span class="s33">exit </span>command to ensure the script still exits after clearing up the temporary file. This will also respond to the <span class="s33">TERM </span>signal, which is what the <span class="s33">kill </span>command sends by default. In addition to <span class="s33">INT </span>and <span class="s33">TERM</span>, there are quite a few signals that, by default, cause programs to terminate. Of these, it is common to trap the <span class="s33">HUP </span>signal often so as to do nothing more than ignore the signal. If you want to ignore a signal, disabling any default behavior, you can specify the empty string as the command argument to <span class="s33">trap</span>. Here we specify that the <span class="s33">HUP </span>signal should be ignored:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">trap &#39;&#39; HUP</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you subsequently want to restore the default handling of a signal, you need to remove the trap. This is done by passing a dash (<span class="s33">-</span>) as the command argument to <span class="s33">trap</span>. So to make <span class="s33">HUP </span>signals terminate our process again we would use the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">trap - HUP</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If a signal isn’t used to tell a process to exit, then it amounts to a rudimentary way of having one process communicate with another. Two signals, <span class="s33">USR1 </span>and <span class="s33">USR2</span>, are made available for user-defined purposes. If you want to use a signal for some custom purpose, you can use one of these. It isn’t possible to pass any information with a signal, though, so they are only useful for synchronization, perhaps to tell another process when a file is ready for it to read. There is an example using the <span class="s33">USR1 </span>signal in the section “Keeping Other Input Away from the Command Line” in Chapter 14.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark692"><span class="s27">336 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 114%;text-align: left;">Most signals are sent in response to some event occurring. In <span class="s33">zsh</span>, the <span class="s33">TMOUT </span>variable we saw in Chapter 7 is used in conjunction with the <span class="s33">ALRM </span>signal: when the time elapses an <span class="s33">ALRM </span>signal is sent. By trapping <span class="s33">ALRM</span>, you can do something more useful than exiting the shell:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>TMOUT=30</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>trap &#39;echo Do something.&#39; ALRM</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you haven’t typed anything for 30 seconds, you will see the message, and again 30 seconds later, until you unset <span class="s33">TMOUT</span>. The command run when this alarm goes off doesn’t need to be before a prompt; that’s because it’s done using the operating system’s own signal facility. This also means that the prompt is not redisplayed after the “Do something” appears, making the display look a bit messy. Some magic with the line editor that we’ll meet in the section “Outputting Messages” in Chapter 14 can help there.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The shell also makes available a set of fake signals. These are signals that aren’t known to the operating system and can’t be sent with the <span class="s33">kill </span>command but that the shell allows you to trap. They allow you to intercept certain operations of the shell.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The <span class="s33">EXIT </span>fake signal is triggered any time the shell exits, whether it does so normally or in response to some signal. For tasks like clearing up temporary files, this can be a lot more conve- nient than trapping a whole host of signals.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Similar to the <span class="s33">EXIT </span>trap, <span class="s33">bash </span>version 3 has a <span class="s33">RETURN </span>fake trap that is triggered whenever a function or sourced script returns. In <span class="s33">zsh</span>, if you define the <span class="s33">EXIT </span>trap within a function, it will be triggered when the function exits. <span class="s33">zsh </span>will also restore any previous <span class="s33">EXIT </span>trap when the function exits. In general, traps are not restored when a function returns. <span class="s33">zsh </span>allows all traps to be made local to a function by turning the <span class="s33">local_traps </span>option on. This is similar to the <span class="s33">local_options </span>option we saw in the section “Porting Scripts” in this chapter.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The other two common fake signals are intended to aid debugging: <span class="s33">DEBUG </span>and <span class="s33">ERR</span>, which are triggered after every command and commands returning a nonzero exit status, respectively. In <span class="s33">zsh</span>, the <span class="s33">ERR </span>trap is instead named <span class="s33">ZERR </span>because some operating systems already have a signal named <span class="s33">ERR</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part360.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part362.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
