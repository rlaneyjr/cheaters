<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Handling Errors</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part381.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part383.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark713">Handling Errors</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: justify;">When the line editor encounters an error, it usually beeps. Each widget decides for itself what it considers to be an error condition. It’s therefore up to you to decide how to handle errors in your own widgets. In this section we’ll demonstrate the features you can use.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">It’s possible to cause a beep by calling <span class="s33">zle beep </span>inside a widget. This appears to the user just as if an error had occurred. The beeps are suppressed by setting the option <span class="s33">no_beep</span>. However, <span class="s33">zle beep </span>has no effect other than making the shell beep. If you want to indicate that an error occurred in a function widget, the widget should call the <span class="s33">return </span>built-in with the argument <span class="s33">1</span>, just like any other function. The shell detects this nonzero status. If the widget was called directly during editing of the command line, rather than from another widget, the shell will beep as if you’d called <span class="s33">zle beep</span>. In the following we rewrite our example widget <span class="s33">backward-ten-characters </span>to indi- cate a return value 1 if there were not enough characters for it to be able to move the full 10:</p><p class="s33" style="padding-top: 6pt;padding-left: 51pt;text-indent: -9pt;line-height: 115%;text-align: left;">if  ((  CURSOR  &gt;  10  ));  then ((  CURSOR  -=  10  ))</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">else</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">return 1</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">fi</p><p class="s29" style="padding-top: 3pt;padding-left: 241pt;text-indent: 0pt;text-align: left;"><a name="bookmark733">CHAP TER 14 </a><span class="s28">■ </span>WRITING EDITOR COMMANDS <span class="s27">355</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The advantage of using a return value is apparent when you call the widget from inside another widget. Then the return status can be used within the calling widget just like that of any other command. Here’s an example. Suppose we want to call <span class="s33">backward-ten-characters </span>but handle the error gracefully:</p><p class="s33" style="padding-top: 7pt;padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">if ! zle backward-ten-characters; then zle beginning-of-line</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fi</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 20pt;line-height: 115%;text-align: left;">The definition of <span class="s33">backward-ten-characters </span>that we showed most recently will return a nonzero status if there are fewer than 10 characters before the cursor. The calling widget detects this status in the <span class="s33">if </span>and simply goes to the start of the line. Instead of going to the beginning of the line, you could have handled the failure of <span class="s33">backward-ten-characters </span>by outputting a message, for example; we’ll see how to do that later. The calling widget also has the option of passing a nonzero status value back to its own caller to indicate an error has occurred; then the shell will beep after the calling widget returns. Alternatively, the calling widget may simply ignore the return status from <span class="s33">backward-ten-characters </span>by executing <span class="s33">return 0</span>. So return statuses are very flexible. You can see why we recommend using a return status to indicate a failure by consid- ering the following alternative definition of <span class="s33">backward-ten-characters</span>:</p><p class="s33" style="padding-top: 6pt;padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">if  ((  CURSOR  &gt;  10  ));  then ((  CURSOR  -=  10  ))</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">else</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">zle beep</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">fi</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">In that case, the shell beeps as soon as it finds that the cursor can’t be moved 10 characters. The calling widget has no effect on this. Furthermore, no return status is passed back, so the calling widget can’t tell that <span class="s33">backward-ten-characters </span>failed.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Return statuses are even useful when the calling widget doesn’t handle them explicitly.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Suppose the last line of the calling widget was the following:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zle backward-ten-characters</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Because there is no <span class="s33">return </span>command, the status value returned by this function is the status value from the <span class="s33">zle </span>command. So the return status is propagated back to the shell; it will beep if <span class="s33">backward-ten-characters </span>failed.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Occasionally you may want to make sure the line editor stops what it’s doing right away.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">That might be appropriate, for example, if the widget were in a state from which you were unable to recover. To abort right away, use the command <span class="s33">zle send-break</span>. This is the widget executed by default when you press Ctrl-g in the <span class="s33">emacs </span>keymap. When you call <span class="s33">zle send-break</span>, the shell doesn’t finish executing the rest of the function where the command occurs, nor any calling functions. It clears the command line, redraws it, and waits for you to type a new key.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part381.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part383.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
