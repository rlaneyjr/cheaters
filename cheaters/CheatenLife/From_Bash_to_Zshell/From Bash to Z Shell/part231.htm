<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Recursive Searching</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part230.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part232.htm">Next &gt;</a></p><p class="s18" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark421">Recursive Searching</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Suppose you want to find a file that resides somewhere in the directory tree that starts with the current directory, but you don’t know how deep in the tree it is. For example, it might be in <span class="s33">scripts</span>, or in <span class="s33">scripts/zsh</span>, or in <span class="s33">functions/zsh/completion</span>. In most shells you have to do something quite complicated to find the file:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark462"><span class="s27">214 </span></a>CHAPTER 9 <span class="s28">■ </span>PATTER N MATCHING </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: left;"><span class="s13">1.  </span>You could use the tricks we discussed in the section “Using <span class="s33">find </span>to Execute a Command” in Chapter 8.</p><p style="padding-top: 6pt;padding-left: 60pt;text-indent: 0pt;text-align: left;"><span class="s13">2. </span>You could specify a list of possible directory levels, such as <span class="s33">*/* */*/*</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="s33">zsh </span>has a simple replacement: the pattern <span class="s33">**/ </span>matches any number of directories (including none) to any depth. By “including none,” we mean that <span class="s33">**/</span><i>filepat </i>can match <i>filepat </i>in the current directory, too; if you don’t want that, you can use <span class="s33">*/**/</span><i>filepat</i>.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Here is a simple example:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">zsh% <b>print -l **/*.txt </b>README.txt src/config.txt</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">src/drivers/driver-list.txt src/problems.txt testing.txt</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note how at each level the directory entries are listed in alphabetic order; if any are them- selves directories, all the files inside them to any depth appear at that point. This is one of the most commonly used <span class="s33">zsh </span>extensions. However, you should be aware of a few problems you may encounter:</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• Operating systems limit the number of arguments that can be passed down to a program. This syntax can generate truly huge argument lists, which can result in an error message such as “argument list too long”. If that happens, you need to split the argu- ments up—for example, using <span class="s33">xargs </span>as we did with <span class="s33">find </span>in the section “Running find in a Pipeline” in Chapter 8.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: 0pt;line-height: 115%;text-align: left;">You don’t need to use <span class="s33">xargs </span>with commands that are part of the shell, because that error occurs only when you’re starting a separate program. However, really large argument lists can take up huge amounts of memory. Using the <span class="s33">xargs </span>method avoids that.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">•   The shell isn’t very fast at performing the search. If you experiment, you will probably discover that the <span class="s33">find </span>command can generate long lists more quickly. The fact that the <span class="s33">find </span>command can do additional tests on files it finds isn’t much of an advantage, however. We’ll see a bit later that <span class="s33">zsh</span>’s “glob qualifiers” provide many of the same abilities.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• The form <span class="s33">**/ </span>does not follow symbolic links to directories. However, the variant <span class="s33">***/ </span>does follow symbolic links, and this can cause problems. Keep in mind that <span class="s33">***/ </span>will follow any link, even those that refer to a directory outside the parent of the directory containing the link. This can result in an infinite loop. Luckily, other operating system limits come into play first. If the length of the filename including all the directories is too long, you may see the message “file name too long”. If the system has followed as many links as it will allow, you may see “too many levels of symbolic links”. These limitations usually mean the effect of loops isn’t too disastrous.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• A limitation of the pattern <span class="s33">**/ </span>is that you can’t use it as part of a set of alternatives in parentheses since it matches across multiple directories. For example, the pattern <span class="s33">(dir1/**/file1|dir1/**/file2).txt</span>, which you might expect to find files called <span class="s33">file1.txt </span>below <span class="s33">dir1 </span>or files called <span class="s33">file2.txt </span>below <span class="s33">dir2</span>, actually fails to match.</p><p class="s29" style="padding-top: 3pt;padding-left: 280pt;text-indent: 0pt;text-align: left;"><a name="bookmark463">CHAPTER 9 </a><span class="s28">■ </span>PATTER N MATCHIN G <span class="s27">215</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• Be careful to make sure the <span class="s33">** </span>occurs at the start of the pattern, or between slashes; if you put some other text next to it, or don’t follow it with a slash, its behavior reverts to that of a single star. There is a way of recursive matching with a given pattern that you’ll learn about in the section “Multiple Matches,” later in this chapter.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part230.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part232.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
