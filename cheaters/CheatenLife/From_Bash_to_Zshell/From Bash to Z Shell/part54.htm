<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Running the Script</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part53.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part55.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark88">Running the Script</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Now, if all’s well, you should be able to run the script and rebuild your <span class="s33">proglist </span>file. If the script is in your current directory, the safest way to run it is by giving its relative pathname, starting with a dot (as the section “Relative Pathnames and Your Current Directory” in Chapter 1 explains, the relative pathname to the current directory is always <span class="s33">.</span>).</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If it works right, the script should be silent: no output except to the <span class="s33">proglist </span>file in your home directory. (For more about this, see the sidebar “Making Error and Progress Messages”.)</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">To be sure the script updates the file, use <span class="s33">ls -l </span>to check its size and last-modification time before and after you run the script. Here goes:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">%  <b>ls  -l  $HOME/proglist</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">-rw-r--r-- 1 zoe users 6182 Dec 6 14:18 /home/zoe/proglist</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">%  <b>./make_proglist</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>!l</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">ls -l $HOME/proglist</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">-rw-r--r-- 1 zoe users 6129 Dec 6 16:44 /home/zoe/proglist</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The program shouldn’t take very long to run. If it takes much longer than a few seconds, terminate the program by typing (typically) Ctrl-c or Delete; you should get another shell prompt. Then look in the <span class="s33">proglist </span>file to see if there’s output and try to track down what’s wrong.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark112"><span class="s27">48 </span></a>C HA P T E R 2 <span class="s28">■ </span>U S I N G S H E L L F E A T U R E S T O G E T H E R</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">Compare it carefully to the example code we’ve shown here. If that doesn’t help, you can ask the shell for debugging output while the program runs by changing the program’s first line to</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">#!/bin/sh  -xv</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The options <span class="s33">-xv </span>tell the shell to list each command line it reads and show each command name as it’s run. Watch carefully to see if you can tell what’s wrong. We won’t cover program debugging in detail here, but it’s basically a matter of comparing what the program should do to what it actually does. For more about debugging, see the section “Debugging Scripts” in Chapter 13.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="569" height="549" alt="image" src="Image_080.png"/></span></p><p class="s40" style="padding-top: 11pt;padding-left: 202pt;text-indent: 0pt;text-align: left;">INHERITANCE</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">Inheritance? Well, yes—but we aren’t talking money or genetics here. We’re talking about Unix processes. When one process (the parent process) starts a new process (a child process), the child inherits many attributes from its parent. (The sidebar “What’s Happening: Processes” in Chapter 1 introduces parent and child processes.) For instance, the parent’s environment variables, like PATH, are copied to the child. The child starts in the same current directory where its parent was. And so on.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">But once the child has started, its environment is separate from its parent’s. Also, a child process can’t change its parent’s environment (unless both processes are set up to cooperate).</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">So: a child process can change any of its attributes, and the parent is safe from unanticipated changes in itself. In other words, the processes start nearly identical to each other, but they run basically independent of each other. Why is this important? A child process can reset its PATH to a list that’s right for it, to be sure it will find commands in the directories it needs to— but that won’t affect the parent’s PATH. The child can create and change shell and environment variables, but the parent’s variable settings stay the same. A child process can cd all over the filesystem, but its parent’s current directory won’t change. We’ve taken advantage of this in our shell script.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">This script cds all over the filesystem, then it exits. Beginners often think that the script has to save its starting directory pathname, then cd back to that directory before it exits. No—not if the code is running as a script, that is. (Keep reading, though, for a note about shell functions.) Because a shell script is run in a separate shell—a separate process—it does <i>not </i>need to save its starting directory. When it’s done, it simply exits; other processes’ current directories (and the rest of their environments) aren’t affected by it.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">A shell <i>function</i>—as opposed to a shell script—usually runs within the same shell process. (There’s more about functions in Chapter 13.) So, if you wrote make_proglist as a shell function, you <i>would </i>need to remember the starting current directory and to restore it when the function exits.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">Let’s close with something obscure that’s still worth a mention. We said that a shell function “usually” runs within the same shell process, but it doesn’t when the directory-changing happens within a loop that has a pipe (|) on its output or its input. Remember that a pipe routes the output of one process to the input of another process. Typically, when a loop has input or output redirected with a pipe, the shell starts a new process to run the loop commands. An important consequence of this: variables you add or reset in a “redirected” loop may not take effect outside of that loop. (In zsh, a redirected-input loop runs in the same shell process, but a redirected-output loop requires a new process.) This obscure part of Unix is an example of why it helps to understand how processes work “under the hood” (“under the bonnet”, if you prefer).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part53.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part55.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
