<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Internationalization and Locales</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part222.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part224.htm">Next &gt;</a></p><h4 style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark413">Internationalization and Locales</a></h4><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">In this chapter we see examples where the shell needs to decide how to order characters, or how to classify a character (as a letter, or a punctuation character, or whatever). The results are affected by variations in language, character sets, and other features between countries and even regions. Unix and related systems nowadays have support for local differences of this type. This goes under the heading “internationalization,” sometimes rather obliquely abbrevi- ated to “i18n” (count the letters). A set of information for a particular region is called a <i>locale</i>. The system can be quite complicated, so we’ll just point out some of the more obvious features.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Programs that are sensitive to locales (not all are) look at environment variables to find out which locale to use. Often, the values of these variables are assigned by you or your administrator. The variables consist of a set of names beginning with <span class="s33">LC_</span>, and the variable <span class="s33">LANG</span>. The value of each variable is the name of the locale itself. Typical names look like <span class="s33">en_US</span>, which is the language and the country, but you may see variations such as <span class="s33">en_GB.UTF-8 </span>and <span class="s33">de_DE@euro</span>, where a particular character-encoding or other unique feature is noted in the name. To find out what locales are available on your system, try running <span class="s33">locale -a </span>or looking in <span class="s33">/usr/lib/locale</span>. <span class="s33">zsh </span>4.2 can even complete them, as long as you have the completion system described in Chapter 10 loaded; try <span class="s33">LANG=&lt;tab&gt;</span>.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The default locale is called <span class="s33">C</span>, as in the programming language. It will always exist and so can be selected as a way of disabling the special behaviors associated with internationalization.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Two variables particularly affect the shell:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 59pt;text-indent: 0pt;text-align: left;">1. <span class="s33">LC_COLLATE </span><span class="p">determines the sort order of characters.</span></p><p class="s13" style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">2. <span class="s33">LC_CTYPE </span><span class="p">determines the character handling and classification behavior.</span></p><p class="s29" style="padding-top: 3pt;padding-left: 280pt;text-indent: 0pt;text-align: left;"><a name="bookmark456">CHAPTER 9 </a><span class="s28">■ </span>PATTER N MATCHIN G <span class="s27">207</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can override all of the <span class="s33">LC_ </span>variables by storing a value in <span class="s33">LC_ALL</span>. Furthermore, by storing a value in <span class="s33">LANG</span>, you can specify a fallback for any variable that is left unset.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">One thing to be careful about is the character encoding used by the locale. This isn’t neces- sarily trivial because your terminal emulator, shell, and files could have different ideas of the character encoding. Even the names of files may be encoded differently depending on your filesystem.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The old way of handling non-English characters was to have multiple character sets for different languages. This is gradually being replaced. The new system is based around a character set, called Unicode. (You may also see Unicode referred to as ISO 10646 or UCS, for Universal Character Set.) This is a code table for assigning numbers to characters; there are several alter- natives for how to represent a sequence of characters as a sequence of bytes. The most useful such encoding under Unix is UTF-8, because it has the property that all characters that exist in the ASCII character set have exactly the same encoding as under ASCII. Multibyte sequences of bytes with the eighth bit set are used for other characters. To be clear: Unicode is a set of characters. UTF-8 is (maybe) the way those characters are represented on your system.</p><p class="s33" style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">zsh <span class="p">does not currently handle multibyte character encodings such as UTF-8. There are other multibyte character sets, the most common being those in use for East Asian languages. For best results, you are better off avoiding such character sets in </span>zsh<span class="p">. Recent versions of </span>bash <span class="p">do handle UTF-8, at least for line editing.</span></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If your terminal is set to use an 8-bit character encoding, and you are confused about locales, you can use a simple trick in <span class="s33">zsh</span>: set the option <span class="s33">print_eight_bit</span>. Then the shell will assume it can print 8-bit characters straight to the terminal in completion lists and so on. The shell will ignore the system’s information about which characters are printable. Character encodings where this will work (assuming your terminal is configured properly) include the ISO-8859 family. These are common single-byte extensions of ASCII for adding accented char- acters found in many European languages.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Pattern matching is commonly used when the need arises to detect lower- and uppercase letters. Suppose my directory contains two filenames, one with only English letters, and one with European characters:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>echo *</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Orvieto  Ötztal</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The locale currently in use for deciding on the nature of characters (using the variable <span class="s33">LC_CTYPE</span>) is <span class="s33">en_GB</span>. This only knows about ASCII characters, which don’t include any accented characters. So here’s what happens when we look for words beginning with uppercase letters:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>echo $LC_CTYPE</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">en_GB</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>echo [[:upper:]]*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Orvieto</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">However, there is another locale that is aware of characters in the UTF-8 Unicode encoding: <span class="s33">en_GB.UTF-8</span>. If we set <span class="s33">LC_CTYPE </span>to that value, the shell can now identify all uppercase letters in the character set:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>LC_CTYPE=en_GB.UTF-8</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo [[:upper:]]*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Orvieto  Ötztal</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark457"><span class="s27">208 </span></a>C HA P T E R 9 <span class="s28">■ </span>P A T T ER N M A T C H I N G</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">It may not be easy for you to reproduce this example, however, even if you have a sufficiently recent system. It depends on the locales that are installed on your computer and on the char- acter set that is used by the terminal for output. Furthermore, <span class="s33">bash </span>and <span class="s33">zsh </span>don’t make it easy to create filenames with characters that are not on your keyboard. These matters are well beyond the scope of this book.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part222.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part224.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
