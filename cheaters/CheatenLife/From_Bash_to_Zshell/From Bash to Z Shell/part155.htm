<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Taking Advantage of Shell Variables and System Commands</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part154.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part156.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark296">Taking Advantage of Shell Variables and System Commands</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">If the <span class="s33">shopt </span>option <span class="s33">promptvars </span>is set, which it is by default, <span class="s33">bash </span>will do variable substitution on prompts. Take this example:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">PS1=&#39;[$OLDPWD]  \w\$  &#39;</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">This puts the directory into the prompt, preceded by an indication of the directory you were in immediately before, which is stored in the shell variable <span class="s33">OLDPWD</span>. (Note that when you start the shell, <span class="s33">OLDPWD </span>isn’t yet defined; you must change the directory at least once.) Once again, the single quotes are crucial here—if you had used double quotes, the shell would have substituted <span class="s33">$OLDPWD </span>at the point you created the variable. Then it would have been fixed for the lifetime of the shell instead of being expanded at each prompt.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">In fact, within prompts <span class="s33">bash </span>does any form of substitution it would normally do in double quotes, including command substitution. This means you can get the prompt to show output from commands. Here’s a way of making it show the last two pieces of the current directory:</p><p class="s33" style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">bash$ <b>PS1=&#39;$(pwd | sed -e &quot;s%^.*/\(.*/.*\)%\1%&quot;)\$ &#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">projects/zshbook$</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">It’s messy, but the important thing is the expression inside the outer parentheses. That pipes the output from the <span class="s33">pwd </span>command, which prints the current working directory, to the stream editor sed, which substitutes the path by just its last two components. We say a little more about sed in the sidebar “The Stream Editor, sed.”</p><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">THE STREAM EDITOR, SED</p><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">THE STREAM EDITOR, SED</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 115pt;text-indent: 0pt;text-align: center;">THE STREAM EDITOR, SED</p><p class="s29" style="padding-top: 3pt;padding-left: 39pt;text-indent: 0pt;text-align: right;"><a name="bookmark325">CHAPTER 7 </a><span class="s28">■ </span>PROMPT S <span class="s27">147</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Entire books have been written about sed; therefore we won’t go into much detail here, although for new users the topic is worth a short introduction. The command is used to transform input lines into output lines by sets of instructions passed as arguments. Each instruction is applied to each input line. In the example in the main text, we used the option -e to pass an instruction to sed. The instruction that follows the –e is &quot;s%^.*/\(.*/.*\)%\1%&quot;, where the double quotes are used to quote the special characters inside, in order to prevent the shell from interpreting them. The type of instruction is indicated by the first character. Here it is s, which shows that we want to substitute an occurrence of a pattern with some replacement text. This instruction has the form s%<i>pattern</i>%<i>replacement</i>%. We used the character % because it does not occur in the pattern or the replacement text; it is more common to use /, but that would have caused confusion here since this character does occur in the pattern we want to match. The replacement text was \1; this is an instruction to sed to substitute the string that matched the part of the pattern between the first \( and the \). Substitution is the most common use of sed; there are also instructions to delete or add lines. In addition, the command has a rudimentary form of scripting language. For complicated operations we recommend a more powerful language like Perl, but for straightforward substitutions sed is useful because it is standard on all Unix systems.</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Entire books have been written about sed; therefore we won’t go into much detail here, although for new users the topic is worth a short introduction. The command is used to transform input lines into output lines by sets of instructions passed as arguments. Each instruction is applied to each input line. In the example in the main text, we used the option -e to pass an instruction to sed. The instruction that follows the –e is &quot;s%^.*/\(.*/.*\)%\1%&quot;, where the double quotes are used to quote the special characters inside, in order to prevent the shell from interpreting them. The type of instruction is indicated by the first character. Here it is s, which shows that we want to substitute an occurrence of a pattern with some replacement text. This instruction has the form s%<i>pattern</i>%<i>replacement</i>%. We used the character % because it does not occur in the pattern or the replacement text; it is more common to use /, but that would have caused confusion here since this character does occur in the pattern we want to match. The replacement text was \1; this is an instruction to sed to substitute the string that matched the part of the pattern between the first \( and the \). Substitution is the most common use of sed; there are also instructions to delete or add lines. In addition, the command has a rudimentary form of scripting language. For complicated operations we recommend a more powerful language like Perl, but for straightforward substitutions sed is useful because it is standard on all Unix systems.</p><p style="padding-left: 39pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Entire books have been written about sed; therefore we won’t go into much detail here, although for new users the topic is worth a short introduction. The command is used to transform input lines into output lines by sets of instructions passed as arguments. Each instruction is applied to each input line. In the example in the main text, we used the option -e to pass an instruction to sed. The instruction that follows the –e is &quot;s%^.*/\(.*/.*\)%\1%&quot;, where the double quotes are used to quote the special characters inside, in order to prevent the shell from interpreting them. The type of instruction is indicated by the first character. Here it is s, which shows that we want to substitute an occurrence of a pattern with some replacement text. This instruction has the form s%<i>pattern</i>%<i>replacement</i>%. We used the character % because it does not occur in the pattern or the replacement text; it is more common to use /, but that would have caused confusion here since this character does occur in the pattern we want to match. The replacement text was \1; this is an instruction to sed to substitute the string that matched the part of the pattern between the first \( and the \). Substitution is the most common use of sed; there are also instructions to delete or add lines. In addition, the command has a rudimentary form of scripting language. For complicated operations we recommend a more powerful language like Perl, but for straightforward substitutions sed is useful because it is standard on all Unix systems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part154.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part156.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
