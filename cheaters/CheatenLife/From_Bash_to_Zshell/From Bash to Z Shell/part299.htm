<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Quoted Command Substitution</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part298.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part300.htm">Next &gt;</a></p><p class="s18" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark550">Quoted Command Substitution</a></p><p class="s33" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="p">Both backquotes and the </span>$(<i>...</i>) <span class="p">form work differently when they appear inside double quotes. (As with variable substitution, they don’t work at all inside single quotes.) As we’ve seen, the output from an unquoted substitution gets turned into a whole set of command arguments. However, if the substitution is quoted, there is only one word. This is important if the substitu- tion is to output a single argument that may have spaces in it. Let’s consider an example:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>mkdir &#39;Program Files&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>touch &#39;Program Files/myprog&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo &#39;Program Files&#39; &gt;mydirs</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">%  <b>ls  $(cat  mydirs)</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">ls: Program: No such file or directory ls: Files: No such file or directory</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">%  <b>ls  &quot;$(cat  mydirs)&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">myprog</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark569"><span class="s27">268 </span></a>C HA P T E R 11 <span class="s28">■ </span>J O BS AN D PR OC E S S ES</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">In the first attempt at <span class="s33">ls </span>the space caused the directory name to be split into two, which <span class="s33">ls </span>saw as different filenames. In the second attempt, the quotes stopped that. (Filenames of this kind are extremely common in Windows.)</p><p style="padding-left: 41pt;text-indent: 17pt;line-height: 115%;text-align: right;">(By the way, you might think you could put the quoted form <span class="s33">&#39;Program  Files&#39; </span>into the file <span class="s33">mydirs</span>. Try it if you like; you’ll see it doesn’t work. That’s because when the command substitu- tion takes place, the shell has already parsed quotes. It doesn’t do this again after the command substitution. So any quotes that come out of the file are treated as if they were normal characters.) In the section “Variable Expansion Flags” in Chapter 12 we’ll show how you can embed a command substitution inside a variable expansion to give you more control over the splitting.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">We’ve already mentioned in passing that the output from command substitution doesn’t get re-evaluated. For example, if the output contains <span class="s33">$ </span>characters, they won’t be used to intro- duce substitutions, because the shell has already dealt with those. They’ll simply be inserted onto the command line as literal <span class="s33">$ </span>characters.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">It’s not quite that simple, in fact. The real rule is that the shell continues with substitutions in the same order it always does them. In <span class="s33">bash</span>, that means that pattern characters that come from command substitution are active, because globbing occurs after command substitution:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">bash$  <b>ls  $(echo  &#39;*&#39;)</b></p><p class="s32" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">...files  in  the  current  directory…</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you try that in <span class="s33">zsh</span>, you’ll just see <span class="s33">*</span>. However, <span class="s33">zsh </span>does the substitutions in the same order as <span class="s33">bash</span>. The difference is that characters that come from substitutions are never special in <span class="s33">zsh</span>; they are treated as if they were quoted. You can switch to the <span class="s33">bash </span>behavior by setting the option <span class="s33">glob_subst</span>. (The same effect applies to variable substitutions, too.)</p><p style="padding-left: 41pt;text-indent: 17pt;line-height: 115%;text-align: left;">Sometimes you <i>do </i>want a command line to be reevaluated completely. For that you can use the shell’s <span class="s33">eval </span>command, which we come to in the section “Variable Indirection” in Chapter 12.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part298.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part300.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
