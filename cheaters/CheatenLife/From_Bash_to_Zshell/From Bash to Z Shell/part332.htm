<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Matching Patterns Against Arrays</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part331.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part333.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark597">Matching Patterns Against Arrays</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">In the same way that some common Unix commands such as <span class="s33">cut</span>, <span class="s33">sed</span>, and <span class="s33">awk </span>allow you to repeat an operation on every line of their input, pattern operators, when used with an array, will act separately on each element of the array. Being able to repeat an operation across all elements of an array is one thing that makes arrays very powerful. For example:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>files=( /lib/lib* )</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo ${files[@]##*/}</b></p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">Here we have used filename generation to create a list of files in a directory other than the current one. As you’ll see if you look at the </span>files <span class="p">array here, filename generation includes the full path of the files matched. In </span>zsh <span class="p">we can remove these by using a modifier (</span>/usr/lib*(:t)<span class="p">), but not all arrays are created this way. In the second line, we use the a </span>${<span class="s32">…</span>##<span class="s32">…</span>} <span class="p">style substitution. By using the </span>[@] <span class="p">subscript, we signal to </span>bash <span class="p">that it shouldn’t just take the first element of the array. The result is that the path component is removed from every element in the array in the expansion.</span></p><p class="s33" style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">zsh <span class="p">includes an additional substitution operation, one that is mostly used with arrays. It takes the form </span>${<span class="s32">variable</span>:#<span class="s32">pattern</span>}<span class="p">. Each array element is matched against the pattern and those that match are discarded. So for example, </span>${pipestatus:#0} <span class="p">discards all elements that consist of the single character </span>0 <span class="p">(zero). This leaves only the values in the </span>pipestatus <span class="p">array that are not zero. Whenever you run several commands in a pipeline, the exit status for each of the commands is put in </span>pipestatus<span class="p">. So with this expansion, only the exit status for commands that failed are expanded. </span>bash <span class="p">offers a similar variable named </span>PIPESTATUS<span class="p">.</span></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark622"><span class="s27">300 </span></a>CHAPTER 12 <span class="s28">■ </span>VARIABLES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">What actually tends to be more useful is the opposite—returning just those elements that do match the pattern—much like the <span class="s33">grep </span>command returns just those lines that match a regular expression. The <span class="s33">M </span>variable expansion flag reverses the sense of the pattern operators, causing them to return what they would otherwise remove. The <span class="s33">:# </span>operator allows us to pick just those elements that match a pattern. For example, here we find that the only element of <span class="s33">path </span>matching <span class="s33">*X11* </span>(in other words, containing the string <span class="s33">X11</span>) is <span class="s33">/usr/X11R6/bin</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>echo ${(M)path:#*X11*}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">/usr/X11R6/bin</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part331.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part333.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
