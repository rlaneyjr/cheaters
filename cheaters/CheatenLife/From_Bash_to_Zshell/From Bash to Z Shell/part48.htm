<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Editing Data, Continuing Command Lines</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part47.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part49.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark82">Editing Data, Continuing Command Lines</a></h4><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">The <span class="s33">proglist </span>file contains a single-column list of program names. Assuming that none of those names are very long, it might be nice to have a file with the names in columns. That’s probably hard to manage with most text editors, but it’s simple on Unix. There are several utilities for putting text into columns. Not all systems have the <span class="s33">column </span>utility, but it’s so simple to use that we’ll choose it. Let’s pipe the output of <span class="s33">sort </span>through <span class="s33">column</span>.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If your system doesn’t have <span class="s33">column</span>—if the shell gives you an error like <span class="s33">column: command not found</span>—then try the command <span class="s33">pr -t -l1 -4 </span>or <span class="s33">pr -t -l1 --columns=4 </span>instead. This asks <span class="s33">pr </span>to print four input lines on each output line—that is, in four columns. The second option is a lowercase letter <span class="s33">l </span>followed by the digit <span class="s33">1</span>.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The command line is starting to get long. We’ll continue the command line by putting a backslash (<span class="s33">\</span>) at the end of it. This is one way to tell the shell “I’m not finished yet.” (Note that Bourne-type shells will automatically continue a command line that ends with a pipe symbol. In C shells, though, you have to type the backslash—and you can do that in Bourne shells, too, if you’d like.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_068.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 42pt;text-indent: 0pt;line-height: 111%;text-align: left;">■<span class="s23">Note </span><span class="s19">The backslash (\) must be the very last character on the command line, just before you press Return. Don’t accidentally put a space or other character after the backslash.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_069.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Depending on your shell, it may be hard to recall a previous command line and add a backslash in the middle of it—so, for this demonstration, you retype the whole command line instead of editing a previous one. After you type the backslash and press Return, the shell will probably prompt you at the start of the next line with its secondary prompt—which is some- thing like <span class="s33">&gt; </span>for Bourne-type shells, or <span class="s33">? </span>for C-type shells, or <span class="s33">pipe pipe pipe&gt; </span>on Z shell. You can also just keep typing when your cursor gets to the right-hand edge of the screen; it may not look tidy, but the command line should work as well:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">%  <b>ls  /bin  /usr/bin  |  grep  -v  &#39;/bin:$&#39;  |  grep  -v  &#39;^$&#39;  |  \</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">? <b>sort | column &gt; proglist</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">%</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Read the file with a pager to see how <span class="s33">column </span>worked. If one of the program names was long, then <span class="s33">column </span>probably made only a few widely spaced columns.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">The columns show a problem here. Sometimes you might want to see the program list in columns. Other times, you might want to use the program list as a data source—for instance, searching it to find certain program names—and having the output already in columns could make that tough. Let’s restore the single-column <span class="s33">proglist </span>file, then use it as a base for other commands. Rerun the earlier command line that didn’t use the <span class="s33">column </span>program, then read <span class="s33">proglist </span>(with a pager) to be sure it’s in a single column.</p><p style="padding-left: 60pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Like other Unix programs, <span class="s33">column </span>can read from a file. We’ll have <span class="s33">column </span>read the <span class="s33">proglist</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">file, then pipe the <span class="s33">column </span>output directly into <span class="s33">less </span>(or your favorite pager program):</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">$ column proglist | less</p><p class="s29" style="padding-top: 3pt;padding-left: 224pt;text-indent: 0pt;text-align: left;"><a name="bookmark101">CHAPTER 2 </a><span class="s28">■ </span>USING SHELL FEATURES TOGETHER <span class="s27">37</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The output should look like it did the previous time you used <span class="s33">column</span>. Maybe it has just a few widely spaced columns. Let’s add a command to truncate (shorten) the long filenames. Then <span class="s33">column </span>should make more columns. (Of course, if you really wanted to see the complete names, you wouldn’t do this. But we want to see more columns—and demonstrate more Unix programs.)</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">cut </span>program reads a file or stdin, removes some characters from each line, and writes the result to stdout. We want the <span class="s33">-c </span>option to remove certain character positions from each line. For instance, <span class="s33">cut -c 1-15 </span>will output the first 15 characters from each line, ignoring the rest. (Your system might need <span class="s33">cut -c1-15</span>, without the space after the <span class="s33">-c</span>.)</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">So (review): how can you make <span class="s33">cut </span>read the program file? Give the filename as an argument.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">And how can you send the output of <span class="s33">cut </span>to <span class="s33">column</span>, which will make it into columns? Right, use a pipe. Let’s do it:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>cut -c 1-20 proglist | column | less</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note that we haven’t created any files here; all of the data flows through the pipe to <span class="s33">less</span>, which displays it on your terminal.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s make more columns by changing the <span class="s33">20 </span>to <span class="s33">10</span>. (Each line of <span class="s33">cut </span>output will have 10 characters or less—making more, narrower columns across the screen.) You can use the history substitution operator <span class="s33">^2^1 </span>to change 20 to 10, if you want; it’ll take fewer keystrokes</p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">than using your arrow keys to move up and over. To make that clearer, we’ll start by showing the previous command line. After you type the history substitution, the shell quickly shows the new command line, then executes it:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>cut -c 1-20 proglist | column | less</b></p><p class="s32" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">...output...</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>^2^1</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">cut  -c  1-10  proglist  |  column  |  less</p><p class="s32" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">...output...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Because the <span class="s33">proglist </span>file isn’t in columns, we can also search it with a program like <span class="s33">grep</span>. Let’s repeat the earlier search to find all lines ending with <span class="s33">sh </span>(which will give a list of shells). Please figure out the command line yourself.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Got it? Good.<span class="s43">2</span></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">How could you put the list of shells into columns? Here’s how to solve the problem: think “What Unix utility makes columns?” Right; it’s <span class="s33">column </span>(or another program you’ve used instead of <span class="s33">column</span>). Next, think how to get the data into the column-making program: the <span class="s33">grep </span>utility does searches and writes the results to its stdout. Finally, think how to get data from one program’s stdout to another program: use a pipe, and let the second program read from its stdin. (That’s all review, but it’s an important series of steps that you’ll want to get familiar with doing.) So, let’s do it. You probably won’t need <span class="s33">less </span>to paginate the <span class="s33">column </span>output unless you have a lot of shells:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>grep &#39;sh$&#39; proglist | column</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">ash bash csh</p><p class="s33" style="padding-top: 1pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="226" height="1" alt="image" src="Image_070.png"/></span></p><p class="s14" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">2. The answer is: <span class="s29">grep &#39;sh$&#39; proglist</span>.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark102"><span class="s27">38 </span></a>C HA P T E R 2 <span class="s28">■ </span>U S I N G S H E L L F E A T U R E S T O G E T H E R</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If that command shows lots of non-shells—for instance, a shell script like <span class="s33">lesspipe.sh</span>— you can use the <span class="s33">egrep </span>program, which accepts extended regular expressions. This longer regular expression will match either the shell <span class="s33">sh </span>or any other name that doesn’t have a dot (<span class="s33">.</span>) before the final <span class="s33">sh</span>. Here’s an example. In an extended regular expression, the vertical bar (<span class="s33">|</span>) means “or”:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">$  <b>egrep  &#39;(^sh|[^.]sh)$&#39;  proglist  |  column</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s wrap this up: to do a lot of useful things, you need to learn what programs are on your system—and how shell redirection works, so you can connect those programs. If you’re accus- tomed to using windowing systems, with a mouse and menus, you may also have to break an old mental habit that “each program should have everything you’d ever want to do somewhere on one of its menus.” (A shell and pipes let you make a huge number of combinations.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part47.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part49.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
