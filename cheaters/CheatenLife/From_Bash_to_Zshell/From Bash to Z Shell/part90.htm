<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Configuration and Key Binding: readline and zle</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part89.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part91.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark166">Configuration and Key Binding: readline and zle</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">It’s time to talk a bit more about how to set up the line editor the way you want it. First, we’ll offer some background about the way the shells’ line editors work, which is a bit different between <span class="s33">bash </span>and <span class="s33">zsh</span>.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;"><span class="s33">bash </span>uses the GNU project’s standard library, <i>readline</i>, which does exactly what its name suggests. Because it’s a library, it is used as part of a lot of different programs. For example, if you use the GNU debugger, <span class="s33">gdb</span>, you will find it uses readline to handle command-line editing. readline has its own configuration file, from which you can configure a lot of different tools; the sidebar “readline Configuration” has more information on this. You can still configure readline settings from your <span class="s33">~/.bashrc</span>. To keep things simple, we’ll show you how to do everything from there.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="569" height="363" alt="image" src="Image_135.png"/></span></p><p class="s40" style="padding-top: 10pt;padding-left: 172pt;text-indent: 0pt;text-align: left;">READLINE CONFIGURATION</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Configuration for the readline library goes in a file named ~/.inputrc. (A system-wide /etc/inputrc file also exists but you shouldn’t need to be concerned with that.) Although the syntax of this file is different from the normal shell syntax, it is fairly simple. Each line takes the same form as an argument to the bind built in. So to bind a key you might, for example, use the following command:</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">&quot;\C-u&quot;: kill-whole-line</p><p class="s33" style="padding-top: 8pt;padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">A number of <i>readline variables </i>allow other aspects of readline’s behavior to be configured. One example is mark-modified-lines. It makes readline warn you about lines in the history that have been modified since readline added them to the history. When you recall a modified line, an initial star (“*”) will be displayed at the beginning of the line. To enable this feature, you can put the following line in your .inputrc file:</p><p class="s33" style="padding-top: 7pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">set mark-modified-lines on</p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">You can see what the current settings for all the variables are by typing bind -v. You can also set readline variables direct from bash using the bind command:</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">bind &#39;set mark-modified-lines on&#39;</p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">We mention specific readline variables later in the book, particularly in Chapter 10. Be aware that many are new. They may not work if you don’t have the latest version of bash.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: left;">zsh <span class="p">has its own “</span>zsh <span class="p">line editor,” or “</span>zle<span class="p">” for short. Because it’s always used within </span>zsh<span class="p">, the only way to set up </span>zle <span class="p">is with standard shell commands.</span></p><p class="s29" style="padding-top: 3pt;padding-left: 188pt;text-indent: 0pt;text-align: left;"><a name="bookmark204">CHAPTER 4 </a><span class="s28">■ </span>EN TERING AND ED ITING THE CO MMAND LIN E <span class="s27">89</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The most common action to configure the line editor is to attach a series of keystrokes to an editing command. This is described as “binding” the command. Both shells use this language, and it shows up in the name of the respective commands. The <span class="s33">bash </span>command is <span class="s33">bind </span>and the <span class="s33">zsh </span>command is <span class="s33">bindkey</span>; they have rather different syntaxes.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 185%;text-align: left;">You can find out what commands are bound to keys already. Here’s how to do that in <span class="s33">bash</span>: <span class="s33">bash$ </span><span class="s46">bind -p</span></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">This produces a complete list of editor commands. Each line is in the form you can use for a later <span class="s33">bind </span>command to re-create the binding (although if you’re just looking at the defaults, that’s not so useful). Unbound commands are shown with a comment character (<span class="s33">#</span>) in front. Here is an example of a bound and an unbound command:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;"># vi-yank-to (not bound) &quot;\C-y&quot;: yank</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 58pt;text-indent: 0pt;text-align: left;">The equivalent in <span class="s33">zsh </span>is the following:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>bindkey -L</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">which is better than <span class="s33">bind </span>inone way—it generates acomplete command that you simply paste into your <span class="s33">~/.zshrc</span>—and worse in another—it doesn’t show you unbound commands. Omitting <span class="s33">-L </span>produces a simpler list with the keys and bindings but not in a form you can cut and paste.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">There is another command to generate a complete list of all editor commands that can be bound:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>zle -la</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">It’s just a simple list of names, one per line. The <span class="s33">zle </span>command is used for creating exten- sions to the editor; we’ll meet it in Chapter 14. The <span class="s33">-l </span>option means list, and <span class="s33">-la </span>means list all. Without the <span class="s33">a </span>you just see user-defined commands. These are features you’ve added to the editor yourself; we’ll see how to do this in Chapter 14.</p><p style="padding-left: 60pt;text-indent: 0pt;line-height: 10pt;text-align: left;">In <span class="s33">zsh</span>, you are allowed to query individual bindings to see if they already do something.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Here is an example:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>bindkey &#39;\C-y&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&quot;^Y&quot; yank</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">That’s the binding for Ctrl-y. Don’t put spaces in the argument to <span class="s33">bindkey</span>, since they count as characters. In <span class="s33">bash </span>you can use the <span class="s33">grep </span>command:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>bind -p | grep &#39;&quot;\\C-y&quot;&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&quot;\C-y&quot;: yank</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 20pt;line-height: 115%;text-align: left;">This produces comfortingly similar results. Note that extra backslash inside the quotes, since backslash is special to <span class="s33">grep </span>as well as to the shell.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Finally, you can always find out from <span class="s33">zsh </span>what a command is bound to on the fly by using the editor command <span class="s33">where-is</span>. This isn’t itself bound by default, so you need to use Esc x <span class="s33">where-is </span>unless you have bound it. It then takes an editor command, just like Esc x itself, and will tell you what keys you need to type to get that command.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark205"><span class="s27">90 </span></a>CHAPTER 4 <span class="s28">■ </span>EN TERING AND ED ITING THE CO MMAND LINE </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: left;">For example, I entered the <span class="s33">where-is </span>command, typed <span class="s33">backward-char</span>, and pressed Return, and <span class="s33">zsh </span>reported the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">backward-char is on &quot;^B&quot; &quot;^[OD&quot; &quot;^[[D&quot;</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The last two sets of characters are the two most common strings of characters sent by the Left Arrow key.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note there is nothing stopping you from binding a command to a key sequence that is already in use; the shell will silently replace the old one.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Once you’ve picked the editor command and a key sequence, the commands to bind the two together are the following. For <span class="s33">bash</span>, let’s bind <span class="s33">history-search-backward </span>to Esc-p:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">bash$  <b>bind  &#39;&quot;\M-p&quot;:  history-search-backward&#39;</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">You do need to remember all those quotes. The rationale is that the single quotes surround a string that <span class="s33">bash </span>will pass to the readline library. That in turn expects the name of complex characters such as Esc-p to be quoted, hence the double quotes around the <span class="s33">\M-p </span>inside the single quotes.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">For <span class="s33">zsh</span>, let’s bind <span class="s33">history-beginning-search-backward </span>to Esc-p:</p><p class="s33" style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh% <b>bindkey &#39;\ep&#39; history-beginning-search-backward</b></p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 114%;text-align: left;">Here, the key and the command are separate arguments to <span class="s33">bindkey</span>. You still need the single quotes around <span class="s33">\ep</span>, though. Suppose you issue the following command:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh% <b>bindkey \ep history-beginning-search-backward # Wrong!</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Because of the shell’s quoting roles, the command-line processor uses the backslash to quote the <span class="s33">e </span>that follows, and <span class="s33">bindkey </span>sees only <span class="s33">ep</span>, which just means exactly those two charac- ters—not what you meant. You need to be on your guard in this way any time you see “funny” characters being passed to a command. For <span class="s33">bind </span>and <span class="s33">bindkey</span>, “funny” characters are so common it’s just as well to get into the habit of quoting any reference to keys.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">The sequence <span class="s33">\e </span>for Esc is one of a set of special keys. Other useful sequences include <span class="s33">\t</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">for Tab (strictly a horizontal tab, since there’s a rarely used vertical tab), <span class="s33">\b </span>for Backspace, and</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">\\ <span class="p">for backslash itself. All need the extra quotes when used with </span>bindkey<span class="p">.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_136.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 114%;text-align: justify;">■<span class="s23">Warning </span><span class="s19">You can’t just use the characters Escape in a bind or bindkey command because they just mean exactly those characters: E, s, c, a, p, e. This is one of many places where the backslash is necessary to tell the shell that some special behavior is required.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_137.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">You can bind any 8-bit character in this fashion if you know the character’s number in the character set. The easiest way (in both <span class="s33">bash </span>and <span class="s33">zsh</span>) is to convert the number to two hexadecimal digits <i>HH</i>. The character is then represented as <span class="s33">\x</span><i>HH</i>. For example, character <span class="s33">\x7f </span>(127 decimal) is the Delete key. This might look a little more memorable than the standard but obscure string</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">\C-?<span class="p">.</span></p><p class="s29" style="padding-top: 3pt;padding-left: 188pt;text-indent: 0pt;text-align: left;"><a name="bookmark206">CHAPTER 4 </a><span class="s28">■ </span>EN TERING AND ED ITING THE CO MMAND LIN E <span class="s27">91</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part89.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part91.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
