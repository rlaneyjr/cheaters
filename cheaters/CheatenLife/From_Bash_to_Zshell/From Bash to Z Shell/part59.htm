<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Passing Info to Processes with Environment Variables</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part58.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part60.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark119">Passing Info to Processes with Environment Variables</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Every process on a Unix system has its own environment—attributes and settings that track the process information and maintain its state. One important part of a Unix process environ- ment is its list of <i>environment variables</i>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Environment variables hold information—strings of text that are designed to be passed from process to process, information that processes need to share with each other. For instance, the environment variable named <span class="s33">SHELL </span>contains the pathname of a shell you want to use, and <span class="s33">HOME </span>(also called <span class="s33">LOGDIR </span>on some systems) contains the pathname of your home directory. Some environment variables, like <span class="s33">SHELL </span>and <span class="s33">HOME</span>, are standard, and every process expects them to have been set. But you can also set any other environment variables that you wish—for instance, to communicate information from a parent process to its children.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">When a parent process starts a child process, the parent’s environment variables are copied to the child. Then the child can do whatever it wants to with those values. A simple example is the Unix program <span class="s33">printenv</span>. (If you don’t have <span class="s33">printenv</span>, you can use <span class="s33">env </span>in some cases and <span class="s33">echo </span>in others, as we’ll explain soon.) It simply outputs a list of all the environment variables that it received from its parent process. Typically, that parent process is your shell. Let’s try it:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-top: 4pt;padding-left: 39pt;text-indent: 0pt;text-align: right;">53</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark128"><span class="s27">54 </span></a>CHAPTER 3 <span class="s28">■ </span>MORE SHELL FEATURES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">$ <b>printenv</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">PAGER=less MANPATH=/u/jpeek/.man:/usr/local/man:/usr/man:/usr/share/man:/usr/X11R6/man VISUAL=vi</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">LESS=emqc USER=jpeek</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">MAIL=/var/spool/mail/jpeek EDITOR=vi</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">DISPLAY=:0.0</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">LOGNAME=jpeek SHELL=/bin/bash TERM=xterm TZ=US/Arizona HOME=/u/jpeek</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">PATH=/u/jpeek/.bin:/u/jpeek/mh/show:/usr/local/bin:/bin:/usr/bin:/usr/X11R6/bin</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">We’ve seen some standard variables, ones that certain Unix programs (or most Unix programs) expect. For instance, the <span class="s33">man </span>program looks for manual-page files in the directories listed in <span class="s33">MANPATH</span>, and it also could use the program named in <span class="s33">PAGER </span>to show those files screen by screen. When a program needs a text editor, it may use the editor named in <span class="s33">VISUAL </span>or in <span class="s33">EDITOR</span>.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">As we saw in the previous chapter, the shell handles two types of variables: shell variables and environment variables. Shell variables (sometimes also called <i>parameters</i>) stay in the process where you set them; they aren’t copied to child processes as environment variables are.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Some Unix users—especially C shell users—name shell variables in lowercase, like <span class="s33">myvariable</span>, and environment variables in uppercase, like <span class="s33">MYVARIABLE</span>. The two names are different because variable names are case sensitive in all shells. (In fact, the C and Z shells’ <span class="s33">path </span>has the same list of names as the <span class="s33">PATH</span>, but in a different format.) That lower-versus-uppercase naming scheme is a convention, though, not a rule.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">To see the value of a particular environment variable, you can pass its name to <span class="s33">printenv </span>as an argument. (This won’t work with <span class="s33">env</span>, though.) You also can give <span class="s33">echo </span>the variable name preceded by a currency sign ($) and surrounded by double quotes; the shell expands this into the variable’s value. Consider this example:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">$ <b>printenv TZ</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">US/Arizona</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">$ <b>echo &quot;$TZ&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">US/Arizona</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The <span class="s33">TZ </span>environment variable tells you what time zone you’re in. The time zone name can be in a variety of formats. (Your system has a default time zone. If you use it, you don’t need to set <span class="s33">TZ</span>.) You may want to change the value of <span class="s33">TZ </span>that the system gave you. For instance:</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• You might have a portable computer that you’ve taken on a trip; you want to set the shell (and any child processes it starts) to understand your new time zone. You can change the <span class="s33">TZ </span>environment variable within your shell in each terminal window where you want to use the new time zone.</p><p class="s29" style="padding-top: 3pt;padding-left: 269pt;text-indent: 0pt;text-align: left;"><a name="bookmark129">CHAPTER 3 </a><span class="s28">■ </span>MORE SHELL FEATURES <span class="s27">55</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• You may be doing a remote login, via the Internet, to a system in a time zone other than yours. You can set <span class="s33">TZ </span>in your shell startup file on that remote system to your local time zone. That way, each time you log in to that remote system, <span class="s33">TZ </span>will be set for you.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: justify;">• Maybe your company has an office in Tokyo and you’d like to know what the time is there. On Bourne-type shells, including <span class="s33">zsh</span>, it’s easy to set an environment variable <i>temporarily</i>, just for a single process. (That’s harder to do in C shells.)</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here’s a Bourne shell example with numbered prompts. Read through it to get an idea of what’s happening, and we’ll explain at the end:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1$ <b>printenv TZ</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">US/Arizona 2$ <b>date</b></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Tue Jul 15 09:26:03 MST 2003</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">3$ <b>TZ=&quot;Japan&quot; date</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Wed Jul 16 01:26:08 JST 2003</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">4$ <b>printenv TZ</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">US/Arizona</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">5$ <b>export TZ=GMT</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">6$ <b>date</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Tue Jul 15 16:26:36 GMT 2003</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">7$ <b>printenv TZ</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">GMT</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;"><b>Command 1 </b>shows that <span class="s33">TZ </span>contains <span class="s33">US/Arizona</span>, and <b>command 2 </b>uses that value when it shows the date in that time zone. In <b>command 3</b>, we’re using the Bourne shell’s way to set a variable temporarily, for just a single command: put <i>Name</i><span class="s33">=&quot;</span><i>value</i><span class="s33">&quot; </span>before the command. You can see that the <span class="s33">date </span>command is giving the date in Japan (where it happens to be tomorrow!). After command 3 runs, <b>command 4 </b>shows that the value of <span class="s33">TZ </span>in the shell hasn’t changed. But <b>command 5 </b>does change <span class="s33">TZ </span>in the shell, as you can see by what <span class="s33">date </span>outputs in <b>command 6 </b>and what <span class="s33">printenv </span>shows in <b>command 7</b>. From now on in this shell, the time zone is set to GMT.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">In <span class="s33">csh </span>and <span class="s33">tcsh</span>, replace command 3 with</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;line-height: 186%;text-align: left;">(setenv TZ &quot;Japan&quot;; date) <span class="p">and command 5 with </span>setenv TZ &quot;Japan&quot;</p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">both of which have the same effect. On older Bourne-type shells, replace command 5 with</p><p class="s33" style="padding-top: 8pt;padding-left: 44pt;text-indent: 0pt;text-align: left;">TZ=GMT; export TZ</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">because the original <span class="s33">sh </span>version of <span class="s33">export </span>can’t set an environment variable’s value.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">We’ve used environment variables in other places. One was in the section “Building Our Script” in Chapter 2, and later in that chapter, where the shell expanded <span class="s33">$HOME/proglist </span>into the pathname of your home directory followed by <span class="s33">/proglist</span>.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark130"><span class="s27">56 </span></a>CHAPTER 3 <span class="s28">■ </span>MORE SHELL FEATURES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can use environment variables to store information you want to make available in all of your shells and subprocesses. In this example, we’ll use the C shell syntax for setting envi- ronment variables. For instance, you could put this line in your shell’s <span class="s33">.login </span>startup file:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">setenv COPIES /var/tmp/joanna/backup-copies</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Then, when you’re using the <span class="s33">vi </span>editor and you want to save the file you’re editing into that directory, you could give a file-writing command like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">:w $COPIES/filename</p><p style="text-indent: 0pt;text-align: left;"><span><img width="62" height="248" alt="image" src="Image_084.png"/></span></p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">and the file would be written to<span class="s33">/var/tmp/joanna/backup-copies/filename</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s40" style="text-indent: 0pt;line-height: 13pt;text-align: left;">QUIZ</p><p class="s40" style="text-indent: 0pt;line-height: 13pt;text-align: left;">QUIZ</p><p style="padding-left: 221pt;text-indent: 0pt;text-align: left;"/><p class="s40" style="text-indent: 0pt;line-height: 13pt;text-align: left;">QUIZ</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Let’s say you’re using a portable computer that shows a graphical clock in the corner of your screen. You change the TZ environment variable from your shell by typing, say, setenv TZ CET.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Q: Why doesn’t the graphical clock change?</p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">A: You changed the environment variable <i>in your shell process</i>. As we saw earlier, one Unix process can’t change the environment of another process that’s already running. The graphical clock process has nothing to do with your shell process. You’ll need to use your system’s special tool for changing the graphical clock— possibly by changing the master system clock.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">(Note that changing a clock on a running system is tricky because Unix systems do so much based on the number of seconds since the Epoch, which is the number of seconds since 00:00:00 on January 1, 1970. If your system clock uses UTC (GMT, Zulu) time, then changing the time zone isn’t a problem—but changing the clock time can disrupt processes that are counting seconds. It may be safest to reboot your system and change the time while Unix isn’t running—from the BIOS setup routine on a PC, for instance.</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Let’s say you’re using a portable computer that shows a graphical clock in the corner of your screen. You change the TZ environment variable from your shell by typing, say, setenv TZ CET.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Q: Why doesn’t the graphical clock change?</p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">A: You changed the environment variable <i>in your shell process</i>. As we saw earlier, one Unix process can’t change the environment of another process that’s already running. The graphical clock process has nothing to do with your shell process. You’ll need to use your system’s special tool for changing the graphical clock— possibly by changing the master system clock.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">(Note that changing a clock on a running system is tricky because Unix systems do so much based on the number of seconds since the Epoch, which is the number of seconds since 00:00:00 on January 1, 1970. If your system clock uses UTC (GMT, Zulu) time, then changing the time zone isn’t a problem—but changing the clock time can disrupt processes that are counting seconds. It may be safest to reboot your system and change the time while Unix isn’t running—from the BIOS setup routine on a PC, for instance.</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Let’s say you’re using a portable computer that shows a graphical clock in the corner of your screen. You change the TZ environment variable from your shell by typing, say, setenv TZ CET.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Q: Why doesn’t the graphical clock change?</p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">A: You changed the environment variable <i>in your shell process</i>. As we saw earlier, one Unix process can’t change the environment of another process that’s already running. The graphical clock process has nothing to do with your shell process. You’ll need to use your system’s special tool for changing the graphical clock— possibly by changing the master system clock.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">(Note that changing a clock on a running system is tricky because Unix systems do so much based on the number of seconds since the Epoch, which is the number of seconds since 00:00:00 on January 1, 1970. If your system clock uses UTC (GMT, Zulu) time, then changing the time zone isn’t a problem—but changing the clock time can disrupt processes that are counting seconds. It may be safest to reboot your system and change the time while Unix isn’t running—from the BIOS setup routine on a PC, for instance.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part58.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part60.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
