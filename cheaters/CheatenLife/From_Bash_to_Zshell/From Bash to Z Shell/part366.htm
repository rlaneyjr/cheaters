<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Modifying the Results</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part365.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part367.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark658">Modifying the Results</a></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">When you use the history modifiers in a glob qualifier list as described in the section “Colon Modifiers as Qualifiers” in Chapter 9, you can alter the expanded filenames and the results do not have to be an existing file. There are, however, limits to what you can do with the history modifiers. For instance, they don’t allow substitutions involving patterns. In this section, we will show how you can make changes to the generated filenames using the <span class="s33">e </span>glob qualifier.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">By modifying the <span class="s33">REPLY </span>variable in the shell code for the <span class="s33">(e) </span>glob qualifier, you can replace what appears in the list for the filename. It is perhaps now clearer why the variable is named <span class="s33">REPLY</span>. With this, we can now do a substitution using a pattern:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">print **/*(e:&#39;REPLY=${REPLY/(src|include)/new}&#39;:)</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">So if a file named <span class="s33">src/code.c </span>was found, <span class="s33">new/code.c </span>would be substituted for it.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can also use the <span class="s33">reply </span>array instead. This allows more than one word to be added to the list for each file. You might want to take the filenames and also the same names with a different extension as in this example.</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">print -l *.c(e@&#39;reply=( $REPLY ${REPLY:r}.h )&#39;@)</p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark697">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">341</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note how we’ve had to resort to the character <span class="s33">@ </span>to delimit the shell code because more common choices are used in the shell code.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part365.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part367.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
