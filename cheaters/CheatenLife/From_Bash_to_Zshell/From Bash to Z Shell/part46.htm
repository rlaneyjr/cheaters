<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Using Programs Together: Pipes</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part45.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part47.htm">Next &gt;</a></p><h4 style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark80">Using Programs Together: Pipes</a></h4><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Unix programs can work on their own, without help from other programs. But many of them are also designed to be “building blocks” that can be combined, from a command line, to do even more. In this section and the next, we’ll look into the very handy feature called <i>pipelines</i>.</p><p class="s29" style="padding-top: 3pt;padding-left: 224pt;text-indent: 0pt;text-align: left;"><a name="bookmark97">CHAPTER 2 </a><span class="s28">■ </span>USING SHELL FEATURES TOGETHER <span class="s27">33</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">As we said earlier, the two directories <span class="s33">/bin </span>and <span class="s33">/usr/bin </span>have many of the standard program files. Wouldn’t it be nice to have a list of all of the programs available on your system? There probably are programs in other directories, but let’s start with these two.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">As we saw in the previous section, the output of <span class="s33">ls /bin /usr/bin </span>isn’t perfect. It has the directory names (with a colon after each) and a blank line between the directories’ listings. But we can use other programs to fix that. Let’s look into the wonderful world of pipelines: combining Unix programs to get just the output you want.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">We’ll need the handy Unix program named <span class="s33">grep</span>. It searches through text, looking for lines that match a pattern you give. If you don’t give any filenames on its command line, then <span class="s33">grep </span>(like any well-behaved Unix program) reads from its standard input.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_062.png"/></span></p><p class="s19" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s21">■</span><span class="s23">Definition </span>grep is one of a family of programs for searching through text. (The other two standard programs are egrep and fgrep. You’ll see others with similar names.) This odd name can be thought of as “globally search for a regular expression and print.” There’s more about these search patterns—<i>regular expressions</i>—in the section “Quoting Pattern Characters” in Chapter 9.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_063.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Let’s start by searching for program names that end with <span class="s33">sh</span>. Most of these are shells, like <span class="s33">bash </span>and <span class="s33">ksh</span>. We mentioned earlier (in the section “History” in Chapter 1) that Unix patterns often use a <span class="s33">$ </span>character to mean “end of line.” Let’s tell <span class="s33">grep </span>to search the <span class="s33">proglist </span>files for lines ending with <span class="s33">sh</span>. The first argument is the pattern to search for; put it inside single quotes:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>grep &#39;sh$&#39; proglist</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">ash bash csh</p><p class="s33" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">That list might be long and scroll off your screen. The cure for that is a pager program like <span class="s33">less</span>. (As before, if you don’t have <span class="s33">less</span>, use <span class="s33">more </span>or <span class="s33">pg </span>instead.) You’ve read a file with <span class="s33">less </span>by giving the filename as an argument. But what we want to page with <span class="s33">less </span>here is not a file: we want to page through the standard output of another process.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">How? There’s one clue above: like most Unix programs, if you don’t give <span class="s33">less </span>a filename, it reads its standard input. The missing piece of this puzzle is the shell’s “pipe” operator, which is made with the vertical-bar key: <span class="s33">| </span>(which may be a broken bar on your keyboard). Use a pipe on the command line to send the standard output of one process to the standard input of the next process. We’ll pipe <span class="s33">grep</span>’s stdout to the stdin of <span class="s33">less</span>:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>grep &#39;sh$&#39; proglist | less</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">ash bash csh</p><p class="s33" style="padding-left: 44pt;text-indent: 0pt;line-height: 10pt;text-align: left;">...</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark98"><span class="s27">34 </span></a>CHAPTER 2 <span class="s28">■ </span>USING SHELL FEATURES TOGETHER </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">You should see a prompt from <span class="s33">less </span>at the bottom of the screen. (If you’re using <span class="s33">more</span>, and <span class="s33">grep </span>outputs less than a screenful of text, <span class="s33">more </span>won’t prompt.) As before, you can press the spacebar to see the next screenful (if any) or <span class="s33">q </span>to quit <span class="s33">less </span>(and get another shell prompt).</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">What’s happening here? The process diagram in Figure 2-3 shows the two processes, <span class="s33">grep </span>and <span class="s33">less</span>, that the shell has started. The <span class="s33">less </span>process reads what <span class="s33">grep </span>writes and feeds it to your terminal, page by page. When you press <span class="s33">q </span>to quit <span class="s33">less</span>, its process exits. The system sees that the <span class="s33">less </span>process is gone—so, if <span class="s33">grep </span>hasn’t also finished by this time, the system kills the <span class="s33">grep </span>process (and the shell often outputs a message like <span class="s33">Broken pipe</span>). Then the shell outputs another prompt.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 44pt;text-indent: 0pt;text-align: left;"><span><img width="404" height="124" alt="image" src="Image_064.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">Figure 2-3. <span class="s32">grep’s output piped to less</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">This invisible “plumbing” may seem hard to visualize at first, but it’s a fundamental part of why shells are so powerful. Take a few moments to review Figure 2-3, compare it to what you did on the command line, and look back at the earlier <span class="s33">grep </span>and <span class="s33">less </span>examples until it’s clear what’s happening. We’ll have more practice with pipes soon, but the concept is so useful that it’s worth some careful study.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part45.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part47.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
