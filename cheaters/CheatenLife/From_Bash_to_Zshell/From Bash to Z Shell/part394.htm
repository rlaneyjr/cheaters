<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Summary</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part393.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part395.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark725">Summary</a></h4><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">In this chapter we’ve considered one particular topic, adding your own commands to <span class="s33">zsh</span>’s line editor, in some detail. Here are some of the features of the line editor that we’ve examined.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• We introduced the concept of a <i>widget function</i>, a piece of shell code for a specific editing task. We showed how to create such a function to extend the editor.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">•   We showed two main ways of editing text from a widget function: calling other widgets with the <span class="s33">zle </span>command, and changing the state of the editor with variables such as <span class="s33">BUFFER </span>and <span class="s33">CURSOR</span>.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• To make widget functions behave more like <span class="s33">zsh</span>’s built-in widgets, we discussed numeric arguments and error handling.</p><p style="padding-top: 7pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• We showed you some case studies in writing widgets for common tasks: making the editing behavior depend on the widget’s name; overriding widgets; and examining command-line arguments. We also discussed the usefulness of testing the name of the previous widget to make widgets run smoothly one after the other.</p><p class="s29" style="padding-top: 3pt;padding-left: 241pt;text-indent: 0pt;text-align: left;">CHAP TER 14 <span class="s28">■ </span>WRITING EDITOR COMMANDS <span class="s27">369</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• We introduced <span class="s33">zsh</span>’s mechanism for approximate matching of patterns, often useful in widgets.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• We presented an example widget, for spelling correction, to put a lot of this information together.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• We demonstrated how the line editor can read characters inside your widgets, and how it can output status information separate from the line it is editing.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• At various points we mentioned that example widgets are supplied with <span class="s33">zsh</span>. These make a good starting point if you wish to learn how to write widgets effectively.</p><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: left;">EDITOR OR COMPLETION WIDGET?</p><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: left;">EDITOR OR COMPLETION WIDGET?</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: left;">EDITOR OR COMPLETION WIDGET?</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">In the next chapter, we will consider a more specific task performed by the line editors of both <span class="s33">bash </span>and <span class="s33">zsh</span>: completion. We will you show you how to write functions in both shells to extend completion. As an introduction, the sidebar “Editor or Completion Widget?” discusses how functions that extend <span class="s33">zsh</span>’s completion behavior, also called widgets, differ from the editor widgets we have introduced in this chapter.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">We’ve seen in this chapter that editor widgets give you nearly complete control over what’s on the command line. However, in the next chapter we’re going to discuss a different sort of widget used for completion. Why, and what’s the difference?</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Completion widgets don’t use the low-level ways of changing the command line that we’re talking about here. The special variables introduced in this chapter are available, but they’re read-only. To change the command line, you need to go through a completely different procedure.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Although you can’t change everything in completion widgets, instead you can change the word the cursor is on in quite complicated ways without doing too much work. You tell the completion system the possible ways the final word can look; it does all the tasks necessary to allow the user to pick the one they want. In particular, the completion system is very good at deciding the current context where editor widgets don’t give you much help. By “context”, we mean whether the text is part of a word, if it’s a command, if it’s a piece of special syntax, and so on.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Which to use? The best answer is to consider whether the task you have in mind can be implemented as a set of choices to supply to the user. If it can, use a completion widget as described in the next chapter. If it can’t, you probably want an editor widget, and should look at the information in this chapter.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">That’s not a complete answer, though: some tasks could be implemented either way. In that case, you need to decide between the simplicity of the interface of an editor widget or the power available in a completion widget.</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">We’ve seen in this chapter that editor widgets give you nearly complete control over what’s on the command line. However, in the next chapter we’re going to discuss a different sort of widget used for completion. Why, and what’s the difference?</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Completion widgets don’t use the low-level ways of changing the command line that we’re talking about here. The special variables introduced in this chapter are available, but they’re read-only. To change the command line, you need to go through a completely different procedure.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Although you can’t change everything in completion widgets, instead you can change the word the cursor is on in quite complicated ways without doing too much work. You tell the completion system the possible ways the final word can look; it does all the tasks necessary to allow the user to pick the one they want. In particular, the completion system is very good at deciding the current context where editor widgets don’t give you much help. By “context”, we mean whether the text is part of a word, if it’s a command, if it’s a piece of special syntax, and so on.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Which to use? The best answer is to consider whether the task you have in mind can be implemented as a set of choices to supply to the user. If it can, use a completion widget as described in the next chapter. If it can’t, you probably want an editor widget, and should look at the information in this chapter.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">That’s not a complete answer, though: some tasks could be implemented either way. In that case, you need to decide between the simplicity of the interface of an editor widget or the power available in a completion widget.</p><p style="padding-left: 39pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">We’ve seen in this chapter that editor widgets give you nearly complete control over what’s on the command line. However, in the next chapter we’re going to discuss a different sort of widget used for completion. Why, and what’s the difference?</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Completion widgets don’t use the low-level ways of changing the command line that we’re talking about here. The special variables introduced in this chapter are available, but they’re read-only. To change the command line, you need to go through a completely different procedure.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">Although you can’t change everything in completion widgets, instead you can change the word the cursor is on in quite complicated ways without doing too much work. You tell the completion system the possible ways the final word can look; it does all the tasks necessary to allow the user to pick the one they want. In particular, the completion system is very good at deciding the current context where editor widgets don’t give you much help. By “context”, we mean whether the text is part of a word, if it’s a command, if it’s a piece of special syntax, and so on.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Which to use? The best answer is to consider whether the task you have in mind can be implemented as a set of choices to supply to the user. If it can, use a completion widget as described in the next chapter. If it can’t, you probably want an editor widget, and should look at the information in this chapter.</p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">That’s not a complete answer, though: some tasks could be implemented either way. In that case, you need to decide between the simplicity of the interface of an editor widget or the power available in a completion widget.</p><p style="text-indent: 0pt;text-align: left;"><span><img width="589" height="200" alt="image" src="Image_289.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s41" style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark746">C H A P T E R 1 5</a></p><p class="s42" style="padding-top: 9pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">■ ■ ■</p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part393.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part395.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
