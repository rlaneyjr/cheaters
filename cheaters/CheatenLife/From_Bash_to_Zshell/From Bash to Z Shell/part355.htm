<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Backreferences</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part354.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part356.htm">Next &gt;</a></p><p class="s18" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark647">Backreferences</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s33">zsh </span>has another, very powerful, way of doing this: <i>backreferences</i>. They are enabled in a pattern with the <span class="s33">(#b) </span>globbing flag. When enabled, parentheses in the pattern are active and can be referred back to by using shell variables. Each parenthesis matched where backreferences are turned on causes the shell to set an entry in the array <span class="s33">match </span>to the substring matched, and entries in the arrays <span class="s33">mbegin </span>and <span class="s33">mend </span>to the position of the substring inside the full string. Up to a maximum of nine parentheses are matched.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here’s how we might read in our configuration file using backreferences to break down the lines:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">#!/bin/zsh</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <span class="s32">All  globbing  flags,  including  (#b),  need  this  option  turned  on.</span></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">setopt extended_glob</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <span class="s32">We&#39;ll  store  the  result  in  an  associative  array.</span></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">declare -A results</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">while  read  line;  do case  $line  in</p><p class="s33" style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;"># <span class="s32">ignore any blank lines or comments</span></p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">(|\#*) ;;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 58pt;text-indent: 0pt;text-align: left;"># <span class="s32">match configuration lines using backreferences</span></p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">((#b)([^=]##)=(*))</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: left;"># <span class="s32">store the result</span></p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">results[$match[1]]=&quot;$match[2]&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">;;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 58pt;text-indent: 0pt;text-align: left;">*)</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">echo &quot;Syntax error&quot; &gt;&amp;2</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">exit 1 # <span class="s32">use &#39;return&#39; from a function</span></p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">;;</p><p class="s33" style="padding-top: 1pt;padding-left: 38pt;text-indent: 0pt;text-align: center;">esac</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">done &lt; config.ini</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;"><span class="p">Using a </span>case <span class="p">statement allows us to compare the line against a pattern. We could have used </span>[[ $line = <span class="s32">pattern </span>]] <span class="p">instead.</span></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">If you use backreferences in a function, remember the feature sets three arrays. It’s usually sensible to make all three invisible to anything outside the function by including the statement at the top of the function:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">local match mbegin mend</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">bash <span class="p">3 adds support for a form of backreferences but using regular expressions instead of shell patterns. An additional </span>=~ <span class="p">operator is available in condition tests allowing a value to be matched against a regular expression. After matching, the </span>BASH_REMATCH <span class="p">array contains any matching portions of the value: its first element contains the part of the value that matched the</span></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark688"><span class="s27">332 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: justify;">whole regular expression and subsequent elements contain parts of the value matching sections of the regular expression enclosed in parentheses. Using this to match lines in our configuration file example, we might use the following condition:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">[[  $line  =~  &#39;^([^=]+)=(.*)$&#39;  ]]</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">This should place the option and value from our line in the second (index 1) and third elements of <span class="s33">BASH_REMATCH</span>, respectively. Note that the regular expression needed to be quoted. Unlike shell patterns, regular expressions are not automatically anchored at the beginning and end. This means that the regular expression only needs to match somewhere in the middle of</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">$line<span class="p">. That’s why the initial element of </span>BASH_REMATCH <span class="p">is useful. To ensure that the regular expression matched the whole of </span>$line <span class="p">we included the </span>^ <span class="p">and </span>$ <span class="p">operators at the start and end of our regular expression, respectively. The </span>$ <span class="p">is not actually needed in this example because </span>.* <span class="p">will match as many characters as possible: as with shell patterns, matching is greedy.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part354.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part356.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
