<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Variable Indirection</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part334.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part336.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark600">Variable Indirection</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;"><i>Variable indirection </i>is a very powerful technique. One of the possibilities it opens to us is the ability to mimic associative arrays in <span class="s33">bash</span>. Variable indirection refers to the practice of using a variable to store the name of another variable. We then need to take an indirect route, via the extra variable, to access the actual variable’s value. So for an associative array, we need to arrange for something like <span class="s33">assoc_$key </span>to be evaluated and then treated as a variable name itself.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">First let’s define our <span class="s33">bash </span>“associative array.” The following defines one similar to the <span class="s33">fg </span>associative array used in the <span class="s33">zsh </span>example. We use a string variable for each element of the array. Note how you can assign to more than one variable on a single command line:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark626"><span class="s27">304 </span></a>CHAPTER 12 <span class="s28">■ </span>VARIABLES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">fg_black=$&#39;\e[30m&#39; fg_red=$&#39;\e[31m&#39; fg_green=$&#39;\e[32m&#39; fg_yellow=$&#39;\e[33m&#39; fg_blue=$&#39;\e[34m&#39; fg_magenta=$&#39;\e[35m&#39; fg_cyan=$&#39;\e[36m&#39; fg_white=$&#39;\e[37m&#39;</p><p style="padding-top: 7pt;padding-left: 42pt;text-indent: 17pt;line-height: 115%;text-align: left;">You can already use these variables to display text in a fixed color. To achieve the flexibility of associative arrays, however, we need to be able to store a key in another variable. In this example, the keys are the names of the colors. It is not possible to use a variable substitution such as <span class="s33">${fg_$color} </span>or to use variable substitutions on the left-hand side of an assignment. Instead, we need to make use of the shell’s <span class="s33">eval </span>command.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_250.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 114%;text-align: justify;">■<span class="s23">Note </span><span class="s19">In the section “Constructing an Array” earlier in this chapter we mentioned that there are two ways to assign values to an array. bash only supports the new way, and that is what we use in this book. However, the old method has an advantage when using variable indirection.</span></p><p class="s19" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 119%;text-align: justify;">Let’s see an example. Suppose we want to set the array named arr. That name arr is stored in the variable var. The following example won’t work because the variable expansion ($var) isn’t allowed on the left-hand side of an equals sign:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: justify;">var=arr</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: justify;">$var=( one two three )</p><p class="s19" style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;text-align: justify;">But the old method will work:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 4pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">set -A $var one two three</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_251.png"/></span></p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">eval </span>command takes a complete command line after it. This command line is parsed by the shell twice:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 60pt;text-indent: 0pt;text-align: left;">1. <span class="p">The first time the shell reads the line, it is parsed normally.</span></p><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: left;"><span class="s13">2. </span>The shell then executes the <span class="s33">eval </span>command. All the arguments are turned into a single string. This string is processed exactly like an ordinary command line.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;">Given this double evaluation, <span class="s33">eval </span>lends itself very nicely to doing variable indirection.</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">Let’s see an example. Here, we first store the string “blue” in the variable named <span class="s33">color</span>. We then use this variable in both an assignment and an expansion to manipulate the variable <span class="s33">fg_blue</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">color=blue reset_color=$&#39;\e[0m&#39;</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">eval  &quot;fg_$color=$&#39;\e[34m&#39;&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">eval  &quot;echo  \${fg_$color}Hello\${reset_color}&quot;</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note how it was necessary to put a backslash before the first <span class="s33">$ </span>on the last line. This ensures that the <span class="s33">$ </span>is preserved until the second time the string is evaluated (after <span class="s33">$color </span>has been expanded). The last <span class="s33">$ </span>is also quoted with a backslash to delay the expansion of <span class="s33">reset_color </span>until the second evaluation. This is not essential, but the shell will otherwise see the <span class="s33">[ </span>character and spend time trying to evaluate the string as a glob pattern. In <span class="s33">zsh</span>, this causes an error unless the <span class="s33">bad_pattern </span>option is turned off.</p><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: center;">USES OF EVAL</p><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: center;">USES OF EVAL</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: center;">USES OF EVAL</p><p class="s29" style="padding-top: 3pt;padding-left: 314pt;text-indent: 0pt;text-align: left;">CHAPTER 12 <span class="s28">■ </span>VARIABLES <span class="s27">305</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Variable indirection isn’t the only use of eval. Evaluating a chunk of code contained inside a variable is another use. The variable might contain a command-line input by the user, for example. (You need to be careful since eval allows <i>any </i>shell command line to be executed, including potentially dangerous operations.)</p><p class="s33" style="padding-top: 7pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">bash$ <b>var=&#39;ls -l ~/.zshrc&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">bash$ <b>$var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">ls: ~/.zshrc: No such file or directory bash$ <b>eval $var</b></p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-rw-r--r-- 1 pws users 11780 Jun 20 14:34 /home/pws/.zshrc</p><p class="s33" style="padding-top: 8pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Without using eval, the tilde is not expanded so ls looks for .zshrc in a directory that is actually named ~. When we used eval, $var was expanded first. Then this string was run as a command line. It had the same effect as if the value in the variable had been typed at the command line.</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Variable indirection isn’t the only use of eval. Evaluating a chunk of code contained inside a variable is another use. The variable might contain a command-line input by the user, for example. (You need to be careful since eval allows <i>any </i>shell command line to be executed, including potentially dangerous operations.)</p><p class="s33" style="padding-top: 7pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">bash$ <b>var=&#39;ls -l ~/.zshrc&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">bash$ <b>$var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">ls: ~/.zshrc: No such file or directory bash$ <b>eval $var</b></p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-rw-r--r-- 1 pws users 11780 Jun 20 14:34 /home/pws/.zshrc</p><p class="s33" style="padding-top: 8pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Without using eval, the tilde is not expanded so ls looks for .zshrc in a directory that is actually named ~. When we used eval, $var was expanded first. Then this string was run as a command line. It had the same effect as if the value in the variable had been typed at the command line.</p><p style="padding-left: 40pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Variable indirection isn’t the only use of eval. Evaluating a chunk of code contained inside a variable is another use. The variable might contain a command-line input by the user, for example. (You need to be careful since eval allows <i>any </i>shell command line to be executed, including potentially dangerous operations.)</p><p class="s33" style="padding-top: 7pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">bash$ <b>var=&#39;ls -l ~/.zshrc&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;text-align: left;">bash$ <b>$var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">ls: ~/.zshrc: No such file or directory bash$ <b>eval $var</b></p><p class="s33" style="padding-left: 9pt;text-indent: 0pt;line-height: 10pt;text-align: left;">-rw-r--r-- 1 pws users 11780 Jun 20 14:34 /home/pws/.zshrc</p><p class="s33" style="padding-top: 8pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Without using eval, the tilde is not expanded so ls looks for .zshrc in a directory that is actually named ~. When we used eval, $var was expanded first. Then this string was run as a command line. It had the same effect as if the value in the variable had been typed at the command line.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">bash <span class="p">provides a second, more convenient, way of accessing variables with a level of indi- rection. This involves using an expansion of the form </span>${!<span class="s32">var</span>}<span class="p">. So we could avoid the second </span>eval <span class="p">in the previous example as follows:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">var=fg_$color</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">echo &quot;${!var}Hello${reset_color}&quot;</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">Unfortunately, this required us to first construct the full variable name in an additional variable. This technique is powerful enough that we can do most of the things we covered for </span>zsh <span class="p">associative arrays in the previous section. </span>bash <span class="p">has one further feature that is worth a mention, though. An expansion of the form </span>${!<span class="s32">prefix</span>*} <span class="p">will expand to all the variables with names starting with the given prefix. This is similar to using the </span>(k) <span class="p">flag in </span>zsh <span class="p">to extract all the keys of an associative array. To demonstrate this feature, let’s list all the variables starting with </span>fg_<span class="p">:</span></p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>echo ${!fg_*}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">fg_black fg_blue fg_cyan fg_green fg_magenta fg_red fg_white fg_yellow</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Another common use for variable indirection is when specifying the name of a variable as a parameter to a function. Functions and parameters to them are covered in the next chapter, so you may want to skip over the rest of this section and come back to it later.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Consider this function:</p><p class="s33" style="padding-top: 8pt;padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">double()  { local  i=${!1}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 4pt;padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">(( i = i * 2 )) eval &quot;$1=$i&quot;</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">}</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark627"><span class="s27">306 </span></a>CHAPTER 12 <span class="s28">■ </span>VARIABLES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">This function takes the name of a variable as its parameter. It uses the variable indirection methods we’ve seen to first obtain the value of that variable and then assign a changed value to it. This means we can do the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">bash$ <b>num=3 </b>bash$ <b>double num </b>bash$ <b>echo $num </b>6</p><p style="padding-top: 7pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Being able to have function calls of the form <span class="s33">double num </span>can allow scripts to become much more readable. The alternative would involve calls of the form <span class="s33">num=$(double $num)</span>.</p><p style="padding-left: 60pt;text-indent: 0pt;line-height: 10pt;text-align: left;">This particular trick is also useful in <span class="s33">zsh</span>, but the syntax is slightly different. Instead of using</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">${!<span class="s32">var</span>}<span class="p">, there is a </span>P <span class="p">variable expansion flag (the P stands for “parameter”). So in </span>zsh<span class="p">, the first line of the </span>double <span class="p">function would need to be</span></p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">local i=${(P)1}</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="s33">ksh93 </span>has another, nicer, way of doing variable indirection. This uses something called <i>named references</i>. A named reference is a special type of variable that points to another variable. You can use the reference in exactly the same way as any other variable (no need for <span class="s33">eval</span>), and it will be the same as if you had used the variable it points to. Using this, our <span class="s33">double </span>function would look like this.</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: -9pt;line-height: 115%;text-align: left;">function double { nameref i=$1</p><p class="s33" style="padding-left: 3pt;text-indent: 0pt;line-height: 10pt;text-align: center;">(( i =  i * 2 ))</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">In this function, the variable <span class="s33">i </span>just becomes another name for the variable passed as</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">a parameter. We’ve used the different function syntax so that <span class="s33">ksh93 </span>will make the reference variable local.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part334.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part336.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
