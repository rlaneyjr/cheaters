<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>New Features in Version 4.2 of zsh</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part392.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part394.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark724">New Features in Version 4.2 of zsh</a></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">The line editor is one of the places where there are significant extensions in 4.2, the latest version of the shell. Here, we’ll briefly describe a few of them. See the shell’s documentation for more information.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There are new variables that give you direct access to the cut buffer, where killed text is put first of all, and the kill ring, where it goes when you kill some more text. (See the sidebar “The Kill Ring” in Chapter 4 for a short introduction to the kill ring.) In 4.0, you could do this only indirectly using the built-in widgets. The scalar <span class="s33">CUTBUFFER </span>is the space where the last killed text lives, and which will be inserted by yanking. The array <span class="s33">killring </span>contains the sequence of pieces of text that were killed. Normally, only the <span class="s33">yank-pop </span>widget uses the kill ring. The array <span class="s33">killring </span>provides the chunks of text in the same order as <span class="s33">yank-pop</span>. Both <span class="s33">CUTBUFFER </span>and <span class="s33">killring </span>can be set as well as read. This allows you to make the kill ring larger or smaller.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The two variables <span class="s33">PREDISPLAY </span>and <span class="s33">POSTDISPLAY </span>allow you to set parts of the visible command line that can’t be edited. The widget function <span class="s33">read-from-minibuffer</span>, which is supplied with the shell, uses these in a widget that prompts for and reads input below the main editing area. This gives a much more natural and powerful way of reading extra input than was available in 4.0. It’s much more like the way you enter text to use in searches, for example.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There are extra contributed functions, too. One set gives a powerful way of telling the shell what it should consider as a word for editor commands that move across or kill or delete words, replacing the <span class="s33">WORDCHARS </span>variable. This uses the shell’s <i>styles </i>mechanism, which we met in the sidebar “Configuring Completion Using Styles” in Chapter 10. For more information look for the entry on <span class="s33">select-word-style </span>in the section of the manual on contributed functions.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part392.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part394.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
