<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Quoting Pattern Characters</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part221.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part223.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark412">Quoting Pattern Characters</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">You should know by now that if you want a special character to behave without its special behavior, you need to quote it either with quotation marks or a backslash. Luckily, you don’t need to quote the whole word, so you can have special characters that retain their effect in the same word. In the following example we use quotation marks to suppress the special interpre- tation of square brackets that appear as part of filenames:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>ls</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">FILE.log FILE[1].log OUTPUT.log OUTPUT[1].log FILE[0].log FILE[2].log OUTPUT[0].log OUTPUT[2].log</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">% <b>echo &#39;FILE[&#39;*&#39;].log&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">FILE[0].log FILE[1].log FILE[2].log</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Writing it like that made it quite clear that only the <span class="s33">* </span>was special to the shell. Although this works perfectly well, many people don’t use characters that are special to the shell in the names of files they create, just to avoid having to quote them. Under Unix, the only characters that can’t appear in filenames at all are the NULL character and a slash. That’s because a NULL</p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">is used to mark the termination of the name, and a slash is used to separate directories. In Windows, it’s more complicated; for example, you can’t use colons because they represent drive letters.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_193.png"/></span></p><p class="s40" style="padding-top: 3pt;padding-left: 102pt;text-indent: 0pt;text-align: left;">GLOBBING AND REGULAR EXPRESSIONS</p><p class="s40" style="padding-top: 3pt;padding-left: 102pt;text-indent: 0pt;text-align: left;">GLOBBING AND REGULAR EXPRESSIONS</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 102pt;text-indent: 0pt;text-align: left;">GLOBBING AND REGULAR EXPRESSIONS</p><p class="s19" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 114%;text-align: justify;"><span class="s21">■</span><span class="s23">Tip </span>The patterns we’ve shown you using *, ?, and ranges are not the ones you use in programs that search text, such as grep, or scripting languages other than shells, such as awk and Perl. Those patterns are called <i>regular expressions</i>. See the sidebar “Globbing and Regular Expressions” for a more detailed explanation.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_194.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">A regular expression (or <i>regex </i>as it’s commonly called) is designed for a different task than a globbing pattern. Globbing gives you a short way to match a complete word while regular expressions are useful when more powerful pattern matching is required. In fact, zsh patterns have been extended so far they can do all that most forms of regular expressions can. However, patterns in zsh are still based on the normal globbing form that’s designed to match filenames easily. So the zsh extensions to pattern matching don’t have the usual regular expression syntax. Here are the most obvious surprises:</p><p class="s13" style="padding-top: 6pt;padding-left: 31pt;text-indent: -11pt;line-height: 114%;text-align: justify;">1. <span class="s33">In a regular expression, a dot doesn’t just match a dot, it matches any single character; in other words, it does what a question mark does in globbing. To match a dot in a regular expression, you need to put a backslash before it: the backslash is the only form of quoting regular expressions understand.</span></p><p class="s33" style="padding-top: 6pt;padding-left: 31pt;text-indent: -11pt;line-height: 115%;text-align: left;"><span class="s13">2. </span>The star in a regular expression doesn’t match any number of characters; it matches any number of <i>repetitions </i>of the previous character, including zero repetitions. Thus a* in a regular expression matches any number of a’s. The equivalent of a globbing star is therefore .*—any number of repetitions of any character, and it doesn’t have to be the same character on every repetition.</p><p class="s66" style="padding-top: 6pt;text-indent: 0pt;text-align: right;">Continued</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">A regular expression (or <i>regex </i>as it’s commonly called) is designed for a different task than a globbing pattern. Globbing gives you a short way to match a complete word while regular expressions are useful when more powerful pattern matching is required. In fact, zsh patterns have been extended so far they can do all that most forms of regular expressions can. However, patterns in zsh are still based on the normal globbing form that’s designed to match filenames easily. So the zsh extensions to pattern matching don’t have the usual regular expression syntax. Here are the most obvious surprises:</p><p class="s13" style="padding-top: 6pt;padding-left: 31pt;text-indent: -11pt;line-height: 114%;text-align: justify;">1. <span class="s33">In a regular expression, a dot doesn’t just match a dot, it matches any single character; in other words, it does what a question mark does in globbing. To match a dot in a regular expression, you need to put a backslash before it: the backslash is the only form of quoting regular expressions understand.</span></p><p class="s33" style="padding-top: 6pt;padding-left: 31pt;text-indent: -11pt;line-height: 115%;text-align: left;"><span class="s13">2. </span>The star in a regular expression doesn’t match any number of characters; it matches any number of <i>repetitions </i>of the previous character, including zero repetitions. Thus a* in a regular expression matches any number of a’s. The equivalent of a globbing star is therefore .*—any number of repetitions of any character, and it doesn’t have to be the same character on every repetition.</p><p class="s66" style="padding-top: 6pt;text-indent: 0pt;text-align: right;">Continued</p><p style="padding-left: 39pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">A regular expression (or <i>regex </i>as it’s commonly called) is designed for a different task than a globbing pattern. Globbing gives you a short way to match a complete word while regular expressions are useful when more powerful pattern matching is required. In fact, zsh patterns have been extended so far they can do all that most forms of regular expressions can. However, patterns in zsh are still based on the normal globbing form that’s designed to match filenames easily. So the zsh extensions to pattern matching don’t have the usual regular expression syntax. Here are the most obvious surprises:</p><p class="s13" style="padding-top: 6pt;padding-left: 31pt;text-indent: -11pt;line-height: 114%;text-align: justify;">1. <span class="s33">In a regular expression, a dot doesn’t just match a dot, it matches any single character; in other words, it does what a question mark does in globbing. To match a dot in a regular expression, you need to put a backslash before it: the backslash is the only form of quoting regular expressions understand.</span></p><p class="s33" style="padding-top: 6pt;padding-left: 31pt;text-indent: -11pt;line-height: 115%;text-align: left;"><span class="s13">2. </span>The star in a regular expression doesn’t match any number of characters; it matches any number of <i>repetitions </i>of the previous character, including zero repetitions. Thus a* in a regular expression matches any number of a’s. The equivalent of a globbing star is therefore .*—any number of repetitions of any character, and it doesn’t have to be the same character on every repetition.</p><p class="s66" style="padding-top: 6pt;text-indent: 0pt;text-align: right;">Continued</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark455"><span class="s27">206 </span></a>CHAPTER 9 <span class="s28">■ </span>PATTER N MATCHING </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 30pt;text-indent: -11pt;line-height: 114%;text-align: left;">3. <span class="s33">A question mark in a regular expression designates zero or one of the preceding patterns. So a? means either nothing or a single a. There’s no simple shell equivalent of this because it’s not usually as useful.</span></p><p class="s33" style="padding-top: 4pt;padding-left: 30pt;text-indent: -11pt;line-height: 115%;text-align: left;"><span class="s13">4. </span>Regular expressions are not automatically <i>anchored </i>to a beginning and an end of a string. That means they can match a string in the middle of some text, with other strings before and after. There are special characters for matching the start and end of lines or words. So to convert a regular expression to an equivalent globbing expression, you often have to add a * on either side of the pattern.</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: left;">Since the basic shell never uses regular expressions as part of its filename-matching capabilities, it’s a good idea to get into the habit of putting the whole of any regular expression inside quotes, to make sure it’s passed down intact to the program that does use it. (There is actually an additional feature that uses regular expression syntax, but we won’t discuss it here.) As you’ve seen, many of the same characters are special to both regular expressions and globbing. It’s quite common for both to appear on the same line. Then the globbing expres- sion should not be quoted, while the regular expression should. For example:</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">grep &#39;shell.*script&#39; *.txt</p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: justify;">The first argument is passed intact to grep. The second is expanded to filenames, and those names are passed down as a set of arguments. The whole searches files ending in .txt for lines containing shell and script in that order with any other characters in between.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 30pt;text-indent: -11pt;line-height: 114%;text-align: left;">3. <span class="s33">A question mark in a regular expression designates zero or one of the preceding patterns. So a? means either nothing or a single a. There’s no simple shell equivalent of this because it’s not usually as useful.</span></p><p class="s33" style="padding-top: 4pt;padding-left: 30pt;text-indent: -11pt;line-height: 115%;text-align: left;"><span class="s13">4. </span>Regular expressions are not automatically <i>anchored </i>to a beginning and an end of a string. That means they can match a string in the middle of some text, with other strings before and after. There are special characters for matching the start and end of lines or words. So to convert a regular expression to an equivalent globbing expression, you often have to add a * on either side of the pattern.</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: left;">Since the basic shell never uses regular expressions as part of its filename-matching capabilities, it’s a good idea to get into the habit of putting the whole of any regular expression inside quotes, to make sure it’s passed down intact to the program that does use it. (There is actually an additional feature that uses regular expression syntax, but we won’t discuss it here.) As you’ve seen, many of the same characters are special to both regular expressions and globbing. It’s quite common for both to appear on the same line. Then the globbing expres- sion should not be quoted, while the regular expression should. For example:</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">grep &#39;shell.*script&#39; *.txt</p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: justify;">The first argument is passed intact to grep. The second is expanded to filenames, and those names are passed down as a set of arguments. The whole searches files ending in .txt for lines containing shell and script in that order with any other characters in between.</p><p style="padding-left: 42pt;text-indent: 0pt;text-align: left;"/><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-left: 30pt;text-indent: -11pt;line-height: 114%;text-align: left;">3. <span class="s33">A question mark in a regular expression designates zero or one of the preceding patterns. So a? means either nothing or a single a. There’s no simple shell equivalent of this because it’s not usually as useful.</span></p><p class="s33" style="padding-top: 4pt;padding-left: 30pt;text-indent: -11pt;line-height: 115%;text-align: left;"><span class="s13">4. </span>Regular expressions are not automatically <i>anchored </i>to a beginning and an end of a string. That means they can match a string in the middle of some text, with other strings before and after. There are special characters for matching the start and end of lines or words. So to convert a regular expression to an equivalent globbing expression, you often have to add a * on either side of the pattern.</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: left;">Since the basic shell never uses regular expressions as part of its filename-matching capabilities, it’s a good idea to get into the habit of putting the whole of any regular expression inside quotes, to make sure it’s passed down intact to the program that does use it. (There is actually an additional feature that uses regular expression syntax, but we won’t discuss it here.) As you’ve seen, many of the same characters are special to both regular expressions and globbing. It’s quite common for both to appear on the same line. Then the globbing expres- sion should not be quoted, while the regular expression should. For example:</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">grep &#39;shell.*script&#39; *.txt</p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: justify;">The first argument is passed intact to grep. The second is expanded to filenames, and those names are passed down as a set of arguments. The whole searches files ending in .txt for lines containing shell and script in that order with any other characters in between.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part221.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part223.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
