<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Building Our Script</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part51.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part53.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark86">Building Our Script</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">We want to loop through each directory and test each directory entry to see if it’s a program file. Our code will look something like this:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark108"><span class="s27">44 </span></a>CHAPTER 2 <span class="s28">■ </span>USING SHELL FEATURES TOGETHER </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">for dir in `echo &quot;$PATH&quot; | tr &#39;:&#39; &#39; &#39;` do</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 10pt;text-align: left;">cd &quot;$dir&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s32" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">...test each entry in $dir and output its name if it&#39;s a program...</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">done | sort &gt; proglist</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;">What goes in the gap in the middle of the loop body?</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">We want to test every entry in every directory in the <span class="s33">PATH</span>. We’ll use two <span class="s33">for </span>loops, one inside the other. The first loop, which we’ve seen already, steps through the directories in the <span class="s33">PATH</span>. Inside that, another loop steps through every entry in a directory.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">After entering each directory with <span class="s33">cd</span>, the <span class="s33">for </span>loop <span class="s33">for file in * </span>will step through each entry in that directory—just as we did with the file-copying example earlier. So our code looks like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">for dir in `echo &quot;$PATH&quot; | tr &#39;:&#39; &#39; &#39;` do</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 10pt;text-align: left;">cd &quot;$dir&quot;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">for file in * do</p><p class="s32" style="padding-left: 59pt;text-indent: 0pt;line-height: 115%;text-align: left;">...test each $file in this $dir and output its name if it&#39;s a program...</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;text-align: left;">done | sort &gt; proglist</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s fill in the missing part. Bourne shells also have an <span class="s33">if </span>command that’s designed to work with <span class="s33">test</span>—and, actually, with many Unix programs. <span class="s33">if </span>lets the shell make decisions based on the results of other commands. (By the way, the C shells’ <span class="s33">if </span>works differently.) The <span class="s33">if </span>command runs a program and tests its exit status. If the status is zero (which means “success”), <span class="s33">if </span>executes the command lines after the word <span class="s33">then</span>. Otherwise, for a nonzero (“failure”) status, <span class="s33">if </span>will execute the commands after the word <span class="s33">else </span>(if any). Our code will look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">if <span class="s32">some-command-line</span></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">then</p><p class="s32" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">commands to run if some-command-line returns “true” status</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">else <span class="s32">(optional)</span></p><p class="s32" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">optional commands to run if some-command-line returns “false” status</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">fi</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The exit status isn’t displayed on the screen (unless your shell is configured that way). The exit status of the previous command line is available from <span class="s33">$? </span>in Bourne-type shells and <span class="s33">$status </span>in C shells. You can see it by using <span class="s33">echo</span>. (If you aren’t sure what the status of a command will be and its manual page doesn’t tell you, this is a good way to find out!) As an example, let’s use <span class="s33">test </span>to test the existence of file <span class="s33">foo </span>(which does exist) and file <span class="s33">oof </span>(which doesn’t):</p><p class="s29" style="padding-top: 3pt;padding-left: 224pt;text-indent: 0pt;text-align: left;"><a name="bookmark109">CHAPTER 2 </a><span class="s28">■ </span>USING SHELL FEATURES TOGETHER <span class="s27">45</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>test -f foo</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo $?</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">0</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>test -f oof</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo $?</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Now, back to our program. We’ll use an <span class="s33">if </span>statement to check each directory entry and output its name only if it’s an executable program file (but not a directory or a nonexecutable file). The <i>some-command-line </i>we’ll use is a Unix program named <span class="s33">[</span>. Yes, that’s an opening square bracket; you might have spotted it in the listing of the <span class="s33">/usr/bin </span>directory earlier. (That program is actually also named <span class="s33">test</span>. Unix programs can have multiple names.) It’s designed to make tests on files, directories, strings of characters, and more. If the test succeeds, <span class="s33">[ </span>returns a status of “true”; otherwise it returns “false.”</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_077.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 111%;text-align: left;">■<span class="s23">Definition </span><span class="s19">The test and [ commands test a file or an expression. They return a result that shows whether the test succeeded. They’re typically used with the Bourne shells’ if statement. Some shells have a</span></p><p class="s19" style="padding-left: 40pt;text-indent: 0pt;line-height: 13pt;text-align: left;">built-in test operator, double brackets ([[ <span class="s55">… </span>]]), with better features. You’ll find details of all of this in the</p><p class="s19" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">section “Condition Tests” in Chapter 13.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_078.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">test </span>and <span class="s33">[ </span>commands accept a series of command-line arguments. (To get a complete list, use <span class="s33">man test</span>.) The arguments are mostly mnemonic: for instance, the <span class="s33">-x </span>test is true if a file is e<i>x</i>ecutable, and <span class="s33">-d </span>is true if the file is a <i>d</i>irectory. (Directories are actually a special type of file.) The command name <span class="s33">[ </span>requires a closing bracket (<span class="s33">]</span>) as its last command-line argument. Here’s the test we’ll use:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">[ -x <span class="s32">filename </span>-a ! -d <span class="s32">filename </span>]</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Our test says: if the file <i>filename </i>is executable (<span class="s33">-x</span>), and (<span class="s33">-a</span>) if the file is not (<span class="s33">!</span>) a directory (<span class="s33">-d</span>), then return a status of “true.” In other words, this test has two parts joined by the <span class="s33">-a </span>(“and”) operator: <span class="s33">-x </span><i>filename </i>and <span class="s33">! -d </span><i>filename</i>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If the test is true, the shell will run <span class="s33">echo </span>to output the filename. The <span class="s33">if </span>statement will look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">if [ -x &quot;$file&quot; -a ! -d &quot;$file&quot; ] then</p><p class="s33" style="padding-left: 49pt;text-indent: 0pt;line-height: 10pt;text-align: left;">echo &quot;$file&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">fi</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: right;"><span class="p">Finally, where does </span>$file <span class="p">come from? It’s set to each filename, in turn, by the inner </span>for <span class="p">loop. It’s good programming practice to declare the output filename (which is </span>proglist<span class="p">) at the beginning of the code instead of hiding it at the end. We’ll create a shell variable named </span>outfile <span class="p">for that. To set a shell variable, use the command </span>name=&#39;<span class="s32">value</span>&#39; <span class="p">or </span>name=&quot;<span class="s32">value</span>&quot;<span class="p">. (Which quoting you use depends on whether you want the shell to expand </span><span class="s32">value </span><span class="p">before storing it in the shell</span></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">variable. See the section “Control Shell Interpretation with Quoting” in Chapter 3.)</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark110"><span class="s27">46 </span></a>CHAPTER 2 <span class="s28">■ </span>USING SHELL FEATURES TOGETHER </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s improve this by choosing an absolute pathname for the <span class="s33">proglist </span>file: instead of just <span class="s33">proglist</span>, we’ll use <span class="s33">$HOME/proglist</span>. This means that, no matter what your current directory is when you run the code, the list of programs will always be written to the same place. On many systems, the <span class="s33">HOME </span>environment variable contains the absolute pathname of your home direc- tory. (A few old systems use <span class="s33">LOGDIR </span>instead of <span class="s33">HOME</span>. To find out, type the commands <span class="s33">echo $HOME </span>and <span class="s33">echo $LOGDIR </span>at a prompt. Use <span class="s33">HOME </span>if it gives the right answer, or <span class="s33">LOGDIR </span>otherwise.)</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">(Here are two more “Unix-like” choices for data and configuration files like <span class="s33">proglist</span>. One is to name the file with a leading dot, like <span class="s33">$HOME/.proglist</span>, which “hides” it from commands like <span class="s33">ls </span>(see the section “Relative Pathnames and Your Current Directory” in Chapter 1). The other is to make a subdirectory named <span class="s33">etc</span>, and use the pathname <span class="s33">$HOME/etc/proglist</span>.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part51.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part53.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
