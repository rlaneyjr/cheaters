<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Constructing an Array</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part313.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part315.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark579">Constructing an Array</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">There are two ways to assign values to an array. The 1988 version of <span class="s33">ksh </span>only supports the old way. <span class="s33">bash </span>allows only the new way. <span class="s33">zsh </span>and <span class="s33">ksh93 </span>support both.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s review an example involving storing three strings—<i>one</i>, <i>two</i>, and <i>three</i>—in an array named <span class="s33">arr</span>. If your shell supports both methods, you can use the old way:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">set -A arr one two three</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">or the new way:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">arr=( one two three )</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">It is worth remembering the old syntax because it can be useful if you ever use <span class="s33">ksh88</span>. The old syntax will be mentioned again in the section “Variable Indirection” later in this chapter, but apart from that we will stick to the new syntax. The new-style assignments have the advan- tage of being much more similar to assignments to scalar variables.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Inside an array assignment, you can use any shell substitution or expansion. This allows you to save the result of an expansion, so that you can reuse it or in case you want to inspect the result of the expansion before passing it to a destructive command like <span class="s33">rm</span>. For example, you can save the result of a <span class="s33">zsh </span>recursive file search as follows:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>src_files=( **/*.[ch] )</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">In <span class="s33">bash </span>you can’t match files recursively using globbing, but you can use the <span class="s33">find </span>command in a command substitution. We said that you can use any shell substitution in an assignment, and that includes command substitutions. So a similar example that will work in <span class="s33">bash </span>is as follows:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>src_files=( $(find . -name &#39;*.[ch]&#39; -print) )</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you have filenames containing spaces, such as <span class="s33">A source file.c</span>, you will find that the <span class="s33">bash </span>example won’t correctly create just one array element for each filename. We’ll explain why this happens in the section “Word Splitting” later in this chapter. In order to work at all, this example depends on the fact that the shell allows values in an array assignment to be sepa- rated by newlines—<span class="s33">find </span>outputs the name of each file it finds on a separate line. That the shell allows newlines to separate array elements means that an array assignment can be split over multiple lines without putting backslashes on the end of the line. So, for example, the following creates an array with three elements:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">arr=(</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">&#39;first  element&#39; &#39;second  element&#39; &#39;third  element&#39;</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">)</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">If you want array elements containing spaces or newlines, then you need to use quoting as</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">we’ve done for the spaces in the example above. You can confirm that this command creates an array with only three elements by including the <span class="s33"># </span>flag in a variable expansion. For an array, it makes the expansion return the number of elements in the array. So to see how many elements are in the <span class="s33">arr </span>array, we can do the following:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo ${#arr}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">3</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark604"><span class="s27">282 </span></a>CHAPTER 12 <span class="s28">■ </span>VARIABLES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part313.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part315.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
