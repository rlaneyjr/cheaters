<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Examining User Input</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part389.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part391.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark721">Examining User Input</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">It can be useful for a widget to determine which keys caused the current widget to be executed. The most obvious example of this is for the widget <span class="s33">self-insert</span>. This is bound to every character that inserts itself into the command line when typed. Using the key to determine which char- acter to insert clearly saves writing a huge number of very similar commands. This feature means you can write your own widgets and have them behave differently depending on the keys to which they’re bound. You can use the <span class="s33">KEYS </span>variable to peek at that key or those keys. This is a literal string of characters, not a string as formatted for <span class="s33">bindkey</span>. So, for example, the keystroke Ctrl-e appears as a single character, numbered 5 in ASCII. A simple example is the following function that does the same as <span class="s33">self-insert</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">LBUFFER=&quot;${LBUFFER}$KEYS&quot;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here’s a more complicated example that inserts the name of a digit, which it takes from the last key typed:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <i>Make  a  lookup  table  of  digit  names.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">local names</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">names=(zero  one  two  three  four  five  six  seven  eight  nine)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <i>Extract  the  digit  from  the  last  character  of  $KEYS.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">local digit=${KEYS[-1]}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Make sure it is a digit.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">if [[ $digit = &lt;0-9&gt; ]]; then</p><p class="s33" style="padding-top: 1pt;padding-left: 38pt;text-indent: 0pt;text-align: center;">#  <i>It  is,  so  look  up  the  word  to  add  from  the  table.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 38pt;text-indent: 0pt;text-align: center;">#  <i>Remember  zsh  arrays  start  from  1,  not  0,  so  add  1</i></p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">LBUFFER=${LBUFFER}${names[digit+1]}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">fi</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Create a function widget named <span class="s33">insert-digit </span>containing this code as we’ve already described. Now bind a key sequence ending in a digit, for example <span class="s33">bindkey &#39;\C-x1&#39;  insert-digit</span>. Then when you press Ctrl-x and then 1, the string <span class="s33">one </span>appears on the command line.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Sometimes you may even need to read in a new key, such as when you want the user to select a particular course of action from a list of choices. This is accomplished with the command <span class="s33">read -k </span><span class="s45">variable</span>. The <span class="s33">read </span>built-in usually reads an entire command line into a variable (or a set of variables) at once. We demonstrated this behavior in the section “Reading Input” in Chapter 13. Using the option <span class="s33">-k </span>will cause just a single keystroke to be read. This is handled specially in <span class="s33">zle</span>. The shell takes a single character from the keyboard without disturbing the line you are editing. The value read is raw character stored in the variable in the same way normal line editor input is stored in <span class="s33">KEYS</span>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">When you read a key, it’s stored as the raw character read from the keyboard, not as one of the symbols the shell usually uses for characters. This is exactly the same format we described for the value of the variable <span class="s33">KEYS</span>. Those numbers are hard to remember and it’s much clearer if you can use the symbols instead. The shell’s arithmetic handling provides a little extra syntax for this purpose. Consider the following example. When you execute it as a widget, it reads in a new key and tries to insert that in upper case. However, it treats a couple of keys in a special fashion if it reads them:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark743"><span class="s27">366 </span></a>CHAPTER 14 <span class="s28">■ </span>WRITING EDITOR CO MMANDS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">local key</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>Loop until we read a special key.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">while true; do</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;"># <i>Read in a new key.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">read -k key</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">if (( #key == ##\r )); then</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"># <i>Special action for carriage return (&lt;return&gt;).</i></p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;line-height: 115%;text-align: left;">zle accept-line return</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 10pt;text-align: left;">elif  ((  #key  ==  ##\C-g  ));  then</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"># <i>Special action for &lt;ctrl-g&gt; (abort).</i></p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 8pt;line-height: 115%;text-align: left;">return 1 else</p><p class="s33" style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">#  <i>Assume  it&#39;s  a  real  character  and  insert  the</i></p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"># <i>uppercase version.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">LBUFFER=&quot;${LBUFFER}${(U)key}&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"># <i>Redisplay the line. </i>zle -R</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 9pt;line-height: 115%;text-align: left;">fi done</p><p style="padding-top: 7pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">We’ll discuss the effect of the <span class="s33">zle –R </span>command in the next section. If you turn this into a</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">widget and run it, the shell will read characters from the keyboard and insert the uppercase version of the key until you press either Return to end the line or Ctrl-g to abort what you are doing. It’s a simple caps lock. For example, type <span class="s33">echo</span>, then execute the widget, then some lowercase text, then press Return. The text after the widget appears in upper case, and is then echoed to the terminal. You can probably think of ways to improve it.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The <span class="s33">#key </span>in the arithmetic evaluation takes the first character of <span class="s33">$key </span>and turns it into the number that represents that character. For example, the <span class="s33">a </span>character’s ASCII encoding is 65. Don’t worry about remembering this; just keep in mind that each character has a unique ASCII representation. The <span class="s33">##</span><span class="s45">keynum </span>treats <span class="s45">keynum </span>in the same way as a keystroke used in key bindings and turns that into a number, too. Hence, you can compare characters read in with those in the normal notation.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There are more complicated examples of this sort among the functions distributed with <span class="s33">zsh</span>. In particular the widget function <span class="s33">incremental-complete-word </span>reads in keys one at a time using <span class="s33">read -k </span>and tries to find completions to the word so far as you type. You’ll find it could do with some improvement; there’s a chance for you to use your new knowledge. The commands <span class="s33">predict-on </span>and <span class="s33">predict-off </span>put you into or out of a mode where the characters you type are inserted by examining <span class="s33">KEYS</span>, but the function also searches the history to try to guess the word you are typing. (Both functions are defined inside the file named <span class="s33">predict-on</span>.) If you can follow these functions, you will have a very good understanding of editor widgets.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part389.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part391.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
