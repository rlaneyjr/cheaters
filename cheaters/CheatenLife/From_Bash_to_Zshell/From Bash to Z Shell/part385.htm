<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Case Study 3: Locating Command-Line Arguments</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part384.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part386.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;line-height: 20pt;text-align: left;"><a name="bookmark716">Case Study 3: Locating</a><a name="bookmark736">&zwnj;</a></h4><p class="s29" style="padding-top: 3pt;padding-left: 23pt;text-indent: 0pt;text-align: left;">CHAP TER 14 <span class="s28">■ </span>WRITING EDITOR COMMANDS <span class="s27">359</span></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;">Command-Line Arguments</h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">When you press Return to execute a command line, the shell divides the line up into arguments to pass to the command. Sometimes it’s useful to be able to analyze the arguments in the line editor before the command is edited. This allows your widgets to manipulate complete command arguments in one go, even if they are quoted expressions.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Extracting the full argument is tricky to do using just ordinary pattern matching, but luckily the shell can help you: the variable expansion flag <span class="s33">(z) </span>splits a scalar into an array using the shell word-splitting rules described in the section “Expansion Flags” in Chapter 12. If this flag is applied to the contents of <span class="s33">BUFFER</span>, the array looks much like the command and its arguments the shell will see later. Note, however, that <span class="s33">(z) </span>does not strip quotes from words, so for example the string <span class="s33">&#39;one word&#39; </span>will appear in the array exactly as that, quotes and all. That’s fine for many purposes, but note that this is not the argument the command receives. The equivalent command argument would be <span class="s33">one word</span>, a single argument with an embedded space but no quotes. If, for example, the word was a filename, you would need the expression without the quotes in order to examine the file.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">This isn’t the end of the story, however. Two problems remain:</p><p style="padding-top: 8pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• How do you know where the cursor resides?</p><p style="padding-top: 8pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• The user is still editing the command line, so the word may not yet be complete. How do you find the word so far?</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you feel your heart growing faint at this point, it may be time to consider whether you can use a completion widget instead. Completion handles all the fiddly little details of word splitting for you. However, in a moment we present a chunk of a function for those who feel sufficiently bold to try it out. It determines the word under the cursor and the number of char- acters between the start of the word and the cursor. You can use these values with the <span class="s33">CURSOR </span>and <span class="s33">BUFFER </span>variables to extract the full word from the command line. Later we’ll see an example where this code fragment fits.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The code simply creates a couple of variables for you to use later. (They’re not special variables.) We’ve put them in upper case so that they stick out. The other variables are only needed internally. We have assumed all the default <span class="s33">zsh </span>options are set, but you can safely set <span class="s33">extended_glob </span>and numerous other options without affecting the way the code works. After it has run, the current shell argument under the cursor is stored in <span class="s33">WORD</span>, and the index of the cursor into that word is stored in <span class="s33">WORDPOS</span>.</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Local variables.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>(If you put this into its own separate function, WORD and WORDPOS</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <i>shouldn&#39;t  be  made  local  to  that,  but  to  the  function  calling  it.)</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">declare bufwords wordnum leftchars sofar WORD WORDPOS</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark737"><span class="s27">360 </span></a>CHAPTER 14 <span class="s28">■ </span>WRITING EDITOR CO MMANDS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">#  <i>Split  the  line  up  to  and  including  the  cursor.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">sofar=&quot;$LBUFFER$RBUFFER[1]&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">bufwords=(${(z)sofar})</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">#  <i>This  is  the  index  of  the  word  the  cursor  is  on.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">wordnum=${#bufwords}</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>This is that word up to the cursor position.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">sofar=${bufwords[$wordnum]}</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>This is the distance we are into that word.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">WORDPOS=${#sofar}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">#  <i>Split  the  full  line  into  words.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">bufwords=( ${(z)BUFFER} )</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>Extract the word the cursor is on from the full array.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">WORD=${bufwords[$wordnum]}</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>Possibly the cursor was just after the word; then</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">#  <i>the  last  character  of  the  word  isn&#39;t  the  character  at  the</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>cursor position...</i></p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: -9pt;line-height: 115%;text-align: left;">if [[ $RBUFFER[1] != $WORD[$WORDPOS] ]]; then (( WORDPOS++ ))</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fi</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can use <span class="s33">WORDPOS </span>together with <span class="s33">CURSOR </span>to find parts of the word. You can use the length of the word, given by <span class="s33">${#WORD}</span>, to find where it ends.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part384.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part386.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
