<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Reading Input</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part353.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part355.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark646">Reading Input</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Earlier we saw how to use commands like <span class="s33">echo </span>to output information but haven’t yet focused on reading text as input. The two most common sources from which text can be read are the output of another command or the contents of a file. From within a script, the aim is typically to read this input into a shell variable and then use some form of processing to make sense of it. In this section, we show you first how to read text in and then describe various techniques for parsing the input so that your script can make use of it.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">In the section “Command Substitution” in Chapter 2, we saw one way of getting at the output of another command. For convenience, we often want the input in a shell variable. This is simple with command substitution—we simply use the expansion in an assignment. For example:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">input=&quot;$(ps)&quot;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">This is fine when the input is another command’s output, but what if you want to read in a file? The answer is to use the <span class="s33">cat </span>command. For example:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">input=&quot;$(cat config.ini)&quot;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">This is so common that there is a special form of command substitution that does this without running the external <span class="s33">cat </span>program:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">input=&quot;$(&lt;config.ini)&quot;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The trouble with this is that the entire input has been read into the variable. More often than not, it is more convenient to be able to deal with the input in smaller chunks such as a line</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark686"><span class="s27">330 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">at a time. While you could chop it up, it is easier and more efficient to just read the input in one line at a time. The shell provides a <span class="s33">read </span>built-in for this purpose. <span class="s33">read </span>takes one line of text from standard input and assigns it to a variable, <span class="s33">REPLY </span>by default. If there are no more lines of text available, <span class="s33">read </span>returns false. This is useful with a <span class="s33">while </span>loop as follows:</p><p class="s33" style="padding-top: 7pt;padding-left: 51pt;text-indent: -9pt;line-height: 115%;text-align: left;">while read; do echo $REPLY</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done &lt; config.ini</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Note how we place the redirection after the <span class="s33">done </span>keyword to redirect standard input for the whole <span class="s33">while </span>loop. This is similar to using redirections with commands grouped in braces as we described in the section “Grouping and Subshells” earlier in this chapter. It is also possible to pipe the output of a command into a <span class="s33">while </span>loop as we show here:</p><p class="s33" style="padding-top: 7pt;padding-left: 46pt;text-indent: -4pt;line-height: 115%;text-align: left;">ps | while read; do echo $REPLY</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Depending on the format of the input being read, it is likely that the line will need to be further broken down. Splitting a string into separate words is easy in general because you can use the shell’s usual word splitting as described in the section “Word Splitting” in Chapter 12. In this case, you can ask <span class="s33">read </span>to do the splitting for you. If passed the <span class="s33">-a </span>option in <span class="s33">bash </span>or <span class="s33">-A </span>in <span class="s33">zsh </span>or <span class="s33">ksh93</span>, <span class="s33">read </span>will split the input into words and store the results in an array. Alternatively, you can specify a list of variables, one for each word. That even works in <span class="s33">ksh88</span>. For example, this will read the output from the <span class="s33">ps </span>command and output just the process ID and command:</p><p class="s33" style="padding-top: 6pt;padding-left: 50pt;text-indent: -9pt;line-height: 115%;text-align: left;">ps | while read pid tty time cmd; do echo $cmd $pid</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The shell’s word splitting isn’t confined to splitting up words at space and tab characters. It actually uses the characters listed in the <span class="s33">IFS </span>(internal field separator) variable as separators when splitting things into words. For example, we can use this to separate the fields in a password file:</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: -9pt;line-height: 115%;text-align: left;">while IFS=: read user pw uid gid name home shell; do echo $user $name</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done &lt;/etc/passwd</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Note also how the <span class="s33">IFS </span>variable is only changed for the <span class="s33">read </span>command.</p><p class="s32" style="padding-top: 1pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">Another way of breaking a line of input down is to use patterns. The variable expansion forms we showed in the section “Patterns” in Chapter 12 are powerful enough for most purposes. For example, let’s say we are reading a configuration file where each line is of the form </span>option<span class="s33">=</span>value<span class="p">. We want to split this into the name of the option and the value. To do this, we might use</span></p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">option=&quot;${line%%=*}&quot; value=&quot;${line#*=}&quot;</p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark687">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">331</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part355.htm">Backreferences</a><a class="toc0" href="part356.htm">Asking the User for Input</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part353.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part355.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
