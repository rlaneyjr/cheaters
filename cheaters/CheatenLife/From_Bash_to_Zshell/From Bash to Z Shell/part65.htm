<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Control Shell Interpretation with Quoting</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part64.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part66.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark125">Control Shell Interpretation with Quoting</a></h4><p style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: justify;">When the shell reads a command line, it interprets special characters. Those special characters include spaces to separate arguments from each other, <span class="s33">$ </span>characters that tell the shell to expand a variable name, <span class="s33">* </span>characters that expand into pathnames, and more. There are times you want special characters to be taken literally. For instance, you might have a filename with spaces in it; you want the shell to include the spaces and not treat the filename as several separate files.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">To control the shell’s handling of special characters, use quoting. Quoting works a little differently in different shells, but the basics are about the same everywhere. The idea is that <i>quoting disables the meaning of special characters</i>. Here are some examples with a wildcard:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$ <b>echo a*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">afile.txt apple_tarts azimuth</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$ <b>echo &#39;a*&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">a*</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$  <b>ls  -l  a*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">-rw------- 1 jpeek users 623 Jan 23 09:17 afile.txt</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">-rw-r--r-- 1 jpeek  users 1739 Jul 3 2003 apple_tarts</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">-rw-r--r-- 1 jpeek  users 8462 Jul 2 2003 azimuth</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$  <b>ls  -l  &#39;a*&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">ls: a*: No such file or directory</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">When the wildcard <span class="s33">* </span>has been quoted, the shell doesn’t expand it into matching filenames. Instead, the shell removes the quotes and passes the remaining characters on to the program. So <span class="s33">echo </span>outputs the literal string <span class="s33">a* </span>because that’s the argument that the shell passed to it. In the same way, the <span class="s33">ls </span>program says that it can’t find a file named <span class="s33">a* </span>(which is true: there isn’t one!).</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Of course, trying to list a nonexistent file named <span class="s33">a* </span>(by quoting the wildcard) doesn’t make sense. (You’d only do that to access a file with the literal two-character name <span class="s33">a*</span>.) You want to use unquoted wildcards on an <span class="s33">ls </span>command line so the shell will expand the wildcard into the correct filenames. We’ve shown that example so you’ll see what the shell normally does, and how quoting a wildcard changes that.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">In general, Unix programs depend on the shell to handle special characters. But some Unix programs have their own special characters, and you want the shell to leave those characters alone—that is, not to interpret them, and to pass them to the program as they are. That’s one time you’ll need to use quoting.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">For instance, many Unix programs use <i>regular expressions </i>(sometimes shortened to <i>regex </i>or <i>regexps</i>). The <span class="s33">grep </span>program, which we saw in the section “Using Programs Together: Pipes” in Chapter 2, is one of those. Its first command-line argument is a regular expression; other arguments (if any) are files to search. One handy file to search, available on many Unix systems, is the dictionary file named something like <span class="s33">/usr/dict/words</span>, <span class="s33">/usr/share/dict/linux.words </span>or</p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="s33">/usr/share/dict/web2</span>. This is a great place to search for crossword-puzzle words. For example, you could make a regular expression to search for any word containing <i>ei</i>, followed by two or more characters, followed by <i>le</i>, like this:</p><p class="s29" style="padding-top: 3pt;padding-left: 269pt;text-indent: 0pt;text-align: left;"><a name="bookmark137">CHAPTER 3 </a><span class="s28">■ </span>MORE SHELL FEATURES <span class="s27">63</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>grep &#39;ei...*le&#39; /usr/dict/words</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">conceivable imperceivable inconceivable perceivable receivable reimbursable Weissmuller</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If we hadn’t put quotes around the regular expression, the shell would have tried to turn <span class="s33">ei...*le </span>into a list of matching filenames! (To the shell, <span class="s33">* </span>is a wildcard character. The shell doesn’t know what <span class="s33">grep </span>does.) But, with quotes, the shell passed the expression onto <span class="s33">grep </span>literally (after stripping off the quotes, that is).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_089.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 111%;text-align: left;">■<span class="s23">Note </span><span class="s19">We suggest that, unless you need to do something special, simply put single quotes around any argument containing a character that isn’t a letter, number, dot (.) or underscore (_). That’s usually safe.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_090.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The newline character (which you get by pressing the Return key) is also special to the shell. Why? (Think back on what the shell does when you press that key.) It’s a command-line separator; when the shell sees a newline character, it knows that the command line has ended. If you want to include a newline as part of a command line, you have to quote it. Let’s store a multiline address in a Bourne shell variable. (The previous chapter introduced shell variables.)</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>addr=&#39;Jerry Peek</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt; <b>1234 Main Street</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;  <b>Flagstaff,  AZ     56789&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">When the shell sees the opening quote, it keeps looking for the next matching quote—that is, the closing quote. Since the newlines were inside quotes, they weren’t command separators; they’re simply included in the variable. The shell prints secondary prompts—which, for Bourne shells, is usually <span class="s33">&gt;</span>—until you complete the command line.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">C shells do this differently. That’s the main difference between Bourne- and C-type shell quoting. You have to put a backslash (<span class="s33">\</span>) before each newline character. If you don’t, you’ll get an error message:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>set addr = &#39;Jerry Peek</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Unmatched &#39;.</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>set addr = &#39;Jerry Peek\</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">? <b>1234 Main Street\</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">?  <b>Flagstaff,  AZ     56789&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">%</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s37" style="padding-top: 4pt;text-indent: 0pt;text-align: right;">v</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark138"><span class="s27">64 </span></a>CHAPTER 3 <span class="s28">■ </span>MORE SHELL FEATURES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">The C shells’ secondary prompt is <span class="s33">?</span>. In general, all shells have three kinds of quoting— three different quote marks:</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: left;"><span class="s13">1. </span>When you put <span class="s33">\ </span>(backslash) before a character, that always disables the character’s special meaning. (So, how can you <span class="s33">echo </span>a backslash? Put a backslash before it: <span class="s33">echo \\ </span>does the trick.)</p><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: left;"><span class="s13">2. </span>When you surround a string of characters with a pair of <span class="s33">&#39; </span>(single quote) characters, that disables the special meaning of almost all special characters inside the string. (In most shells, single quotes allow history substitution—with the <span class="s33">! </span>character. And, in C shells, single quotes also don’t disable newlines. In both of those cases, you have to put a back- slash before each <span class="s33">! </span>and newline.)</p><p style="padding-top: 6pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;"><span class="s13">3. </span>When you surround a string of characters with a pair of <span class="s33">&quot; </span>(double quote) characters, that disables the special meaning of most characters inside the string. It allows variable substitution (the <span class="s33">$ </span>character) and command substitution (the <span class="s33">` </span>or <span class="s33">$() </span>operator). Again, in many shells, it also does not disable history substitution or newlines, as we explained earlier.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In a lot of cases, the sort of quoting you use doesn’t matter. For instance, the <span class="s33">grep </span>command we saw previously works with any sort of quoting because all kinds of quoting disable wildcards. Use whichever you like best:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: justify;">grep &#39;ei...*le&#39; /usr/dict/words grep &quot;ei...*le&quot; /usr/dict/words grep ei...\*le /usr/dict/words</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">(The dot (<span class="s33">.</span>) is a special character to <span class="s33">grep</span>, but not to the shell. Because you use quoting to control the shell, there’s no need to quote the dots.)</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Most shells treat spaces and newlines as argument separators inside shell variables and command substitution. That is, if the value of your shell variable or the output of your command has spaces or newlines in it, most shells will break the text into separate arguments there.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">For example, let’s look back at the address we stored earlier in the <span class="s33">addr </span>shell variable.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">When you give that value without quotes, most shells will break it into separate arguments at the spaces and newlines. The <span class="s33">echo </span>command outputs its arguments with a single space between each of them. See what happens when you <span class="s33">echo </span>the variable’s value on Bourne shells: the shell breaks it into arguments and echo adds a space between each:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">$ <b>echo $addr</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Jerry Peek 1234 Main Street Flagstaff, AZ 56789</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">(The C shell does something similar, but it treats a newline as a separate, empty argument, so you get two spaces between each of the original lines.) Notice that we lost the three spaces that we’d stored between <span class="s33">AZ </span>and <span class="s33">56789</span>; the shell used them as an argument separator.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In Bourne and C shells, you have to tell the shell not to break the line into words. To do that, quote the value so the shell will ignore the special meaning of spaces and newlines. Do we want single quotes or double quotes? We want double quotes because they don’t disable the</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">$ <span class="p">character:</span></p><p class="s29" style="padding-top: 3pt;padding-left: 269pt;text-indent: 0pt;text-align: left;"><a name="bookmark139">CHAPTER 3 </a><span class="s28">■ </span>MORE SHELL FEATURES <span class="s27">65</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">$  <b>echo  &#39;$addr&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$addr</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$ <b>echo &quot;$addr&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Jerry Peek</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1234 Main Street</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Flagstaff, AZ 56789</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here’s one area that Z shell is different from other shells. By default (unless you configure it to work like a Bourne shell), <span class="s33">zsh </span>won’t break expanded variables and command substitution at spaces and newlines. So, in the Z shell, there’s no need for double quotes in this case— though you can use them if you want to:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>echo $addr</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Jerry Peek</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1234 Main Street</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Flagstaff, AZ 56789 zsh% <b>echo &quot;$addr&quot; </b>Jerry Peek</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">1234 Main Street</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Flagstaff, AZ 56789</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here again, the C shells do things that some people consider quirky. To quote a newline from a shell variable, you have to use some special C shell-only quoting:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo &quot;$addr&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Unmatched &quot;.</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo ${addr:q}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Jerry Peek</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">1234 Main Street</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Flagstaff, AZ 56789</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here we’re getting into some of the twisty, bizarre corners of the differences between shells. Unless you want to be an expert—or you’re just interested—this sort of arcane detail isn’t very important, but you can find all of it in the latter parts of this book (along with lots of much more practical information).</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s finish quoting by reminding you of the three types of quoting—<span class="s33">&quot;</span>, <span class="s33">&#39;</span>, and <span class="s33">\</span>—and the general rule that, if you don’t need to do anything special, use a pair of single quotes (<span class="s33">&#39;</span>) around an argument; you’ll probably be fine.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part64.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part66.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
