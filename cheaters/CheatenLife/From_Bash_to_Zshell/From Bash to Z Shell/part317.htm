<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Word Splitting</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part316.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part318.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark582">Word Splitting</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">In the section “Constructing an Array” earlier in this chapter, we showed how substitutions such as command substitutions can be used inside an array assignment. An important aspect of the shell you should be aware of when doing this is how the shell decides where to divide the result of the substitution into separate array elements. This is an issue that is not just relevant to array assignments. When the shell executes a command, any parameters are passed to the command in the form of a list. The shell, therefore, needs to split each command line you type into the separate elements of this list. This process is called <i>word splitting </i>and the elements are called <i>words</i>. These “words” are distinct from English words: they are maintained separately like array elements and can contain characters such as spaces.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">When using variables, you need to be careful because word splitting may happen on the result of a variable expansion. So if your variable contains spaces, it will be broken up into</p><p class="s29" style="padding-top: 3pt;padding-left: 314pt;text-indent: 0pt;text-align: left;"><a name="bookmark607">CHAPTER 12 </a><span class="s28">■ </span>VARIABLES <span class="s27">285</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">several words. Before the shell had arrays, this could be useful, but more often than not it is a nuisance. For this reason, <span class="s33">zsh </span>doesn’t do word splitting on variable expansions.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">To demonstrate how a particular command line is broken down into words, we’ll use the <span class="s33">printf </span>command. <span class="s33">printf </span>allows some text to be output in a specific format. It has the useful feature of reusing the format string if more arguments remain. So if you use a format string such as <span class="s33">&#39;%s\n&#39; </span>it will print each word on a new line. We’re going to use it frequently so let’s create an alias for it:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">alias showargs=&quot;printf &#39;&gt;&gt;%s&lt;&lt;\n&#39;&quot;</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">Now we can see just how a command line is broken into words:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>showargs one &#39;two three&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;one&lt;&lt;</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;two three&lt;&lt;</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_236.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 117%;text-align: left;">■<span class="s23">Caution </span><span class="s19">zsh only gained printf as a built-in command in version 4.2 so this may depend on an external printf command. On some Unix systems the external printf command doesn’t reuse the format string until all arguments have been printed so this alias won’t work. If you find that this is the case on your system, you can try using zsh’s print command instead. print has a useful -l option, which makes it print each argument on a new line (the l stands for line).</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_237.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">Returning to word splitting in variable expansions, the examples that follow illustrate how</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash <span class="p">and </span>zsh <span class="p">differ. In the first example, </span>bash <span class="p">expands a variable:</span></p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>var=&#39;one two&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>showargs $var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;one&lt;&lt;</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;two&lt;&lt;</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 19pt;text-align: left;">Let’s repeat that task in <span class="s33">zsh</span>: <span class="s33">zsh% </span><span class="s46">var=&#39;one two&#39;</span></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>showargs $var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;one two&lt;&lt;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">As we saw in the section “Control Shell Interpretation with Quoting” in Chapter 3, quoting can be used to make the shell ignore the special meaning of spaces. So we can prevent the word splitting for <span class="s33">bash </span>by putting the variable reference in double quotes:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>showargs &quot;$var&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;one two&lt;&lt;</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">In <span class="s33">zsh</span>, you can emulate the Bourne shell behavior by turning the <span class="s33">sh_word_split </span>option on.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">In the sidebar “The Dangers of Word Splitting,” we explain why <span class="s33">zsh </span>behaves differently by default. We would only recommend using <span class="s33">sh_word_split </span>for compatibility when you’re running scripts not originally written for <span class="s33">zsh</span>.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark608"><span class="s27">286 </span></a>CHAPTER 12 <span class="s28">■ </span>VARIABLES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There is one situation where the <span class="s33">bash </span>behavior can be useful. If you put a command with parameters in an environment variable, then when the variable is expanded the shell will separate the parameters from the command name. To demonstrate this, consider the <span class="s33">PAGER </span>environment variable. Programs such as <span class="s33">man </span>look at the variable to decide what program to use so that their output can be viewed a page at a time. It is common to set it to <span class="s33">less </span>or <span class="s33">more</span>, but you can actually include options in the variable. So it is perfectly acceptable to set <span class="s33">PAGER </span>to <span class="s33">less -s</span>. The <span class="s33">-s </span>causes consecutive blank lines to be squeezed into one. If, in <span class="s33">zsh</span>, you now try to use the <span class="s33">PAGER </span>environment variable (which is not uncommon in a script) you will see the problem:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>nroff -man zshall.1 | $PAGER</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh: command not found: less -s</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">It is looking for a command named <span class="s33">less -s </span>and not finding one. If you try the same command from <span class="s33">bash</span>, it should successfully run <span class="s33">less </span>with the <span class="s33">-s </span>option. <span class="s33">zsh </span>provides a workaround to let you do this, which we will come to shortly. Using a value such as <span class="s33">less  -s </span>doesn’t cause problems from programs like <span class="s33">man </span>because the value is passed to a shell. This shell then treats it in much the same way as if you had typed it at the command line.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="507" height="452" alt="image" src="Image_238.png"/></span></p><p class="s40" style="padding-top: 11pt;padding-left: 154pt;text-indent: 0pt;text-align: left;">THE DANGERS OF WORD SPLITTING</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">In this section, we explain how the shells behave with respect to word splitting. What may not be clear is why they behave as they do. In particular, why does zsh behave differently?</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: justify;">The first point to note is that word splitting on variable expansions is rarely useful. Without some modern shell features, it would have more uses. It allows, for example, a list of filenames to be separated when passed to a command, but arrays now serve this purpose. Word splitting also allows a command to be separated from its parameters when they are stored together in a variable. This is what we did in the example with PAGER, but if we didn’t want to export PAGER to child processes in the environment, it would be better to use an alias or a function.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: justify;">In addition to not being particularly useful, word splitting can be a nuisance in many situations. For example, it is very common to assign the name of a file to a variable. A common pitfall is to forget to quote this variable when using it. For example you might write a script that looks roughly like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">for file in *.old; do</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;"># <span class="s32">do some other things</span></p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 8pt;line-height: 115%;text-align: left;">rm  $file done</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">When you test this little script, it may appear to work fine. However, try running the script in a directory containing a file with a name that contains a space. In this case, the rm command receives two arguments for this file instead of one. It won’t delete the file as expected and may even delete different files. Even if you’re not using destructive commands like rm, this behavior can cause scripts to fail or do unexpected things.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: justify;">To summarize, word splitting was originally useful because it allowed for a sort of poor man’s array. Given that it is no longer needed for that purpose in modern shells, zsh avoids its disadvantages by disabling word splitting by default. If you use bash, you will find that you need to put double quotes around variables to avoid the split- ting. If you ever want your variable to be split, you almost certainly ought to be using an array.</p><p class="s29" style="padding-top: 3pt;padding-left: 314pt;text-indent: 0pt;text-align: left;"><a name="bookmark609">CHAPTER 12 </a><span class="s28">■ </span>VARIABLES <span class="s27">287</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Sometimes, you may find that you want to have a variable split. This most commonly occurs when a list of values is stored in an environment variable. For example, the <span class="s33">cvs </span>command looks for a list of filenames in the <span class="s33">CVSIGNORE </span>environment variable. One solution is to use a tied array as shown in the previous section. The other way is to specify that you want your variable to be split. You do that with an equals sign like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>var=&#39;one two&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>showargs $=var</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;one&lt;&lt;</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">&gt;&gt;two&lt;&lt;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">So, returning to our earlier example, if you want to make use of <span class="s33">PAGER </span>from a <span class="s33">zsh </span>script, you can make it work when <span class="s33">PAGER </span>includes options by using the expansion <span class="s33">$=PAGER</span>. There are a few other characters that are used in a similar way to equals. Remembering them can be difficult. In this case, it might help if you consider that an equals sign consists of two separate lines that are split from each other.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part316.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part318.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
