<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>An Example Widget: Correcting Spelling</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part387.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part389.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark719">An Example Widget: Correcting Spelling</a></h4><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;"><span class="p">Correcting the spelling of the name of a file is one of the tasks that straddles the boundary between needing an editor widget and a completion widget. In the following example, we’ll depend on the former widget type to implement this feature. The key part of the method we use for correcting spelling is the extended globbing flag </span>(#a<span class="s32">num</span>) <span class="p">that we just discussed.</span></p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">Using completion could improve the example in a couple of ways.</p><p style="padding-top: 8pt;padding-left: 57pt;text-indent: 0pt;text-align: left;">• In completion, the shell itself decides what the current word is.</p><p style="padding-top: 8pt;padding-left: 67pt;text-indent: -10pt;line-height: 115%;text-align: left;">• The shell takes over the task of deciding how to handle the possibility that there are multiple matches.</p><p style="padding-top: 7pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">In this example, we’ve used a simple method to determine where the cursor is positioned.</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 17pt;line-height: 115%;text-align: left;">The function uses the parameter expansion syntax as well as extended globbing. Note in the <span class="s33">after </span>assignment that the first <span class="s33">## </span>and the second have completely different meanings. The first is part of parameter expansion (remove the longest match at the head of the string), as we described in the section “Patterns” in Chapter 12. The second is part of extended globbing (match the previous expression at least once) as we described in the section “Multiple Matches” in Chapter 9. The whole remainder of the expression before the closing brace is passed to the shell’s pattern matcher.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can achieve better handling of embedded spaces by using the previous example for matching the current word. We’ve written this function in such a way that inserting that entire function where we’ve indicated will work correctly.</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">emulate -L zsh</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>We need extended globbing for pattern matching</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">setopt extended_glob</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>We use this to avoid errors when approximation fails.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">setopt null_glob</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">#  <i>The  maximum  number  of  approximations  we  will  allow.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">integer max_approx=3</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>*** You can replace this chunk with the more sophisticated ***</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;"># <i>word-finding code shown above. That&#39;s why we&#39;ve used the same</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">#  <i>names  for  WORD  and  WORDPOS.    The  variables  are  not  special  to  the  shell.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">local WORD before after integer WORDPOS endpos</p><p class="s29" style="padding-top: 3pt;padding-left: 241pt;text-indent: 0pt;text-align: left;"><a name="bookmark740">CHAP TER 14 </a><span class="s28">■ </span>WRITING EDITOR COMMANDS <span class="s27">363</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <i>What&#39;s  before  the  current  word:</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>everything except consecutive non-spaces at the end of the left buffer.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">before=${LBUFFER%%[^[:space:]]##}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Position of the start of the current word.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Add one to the length of the `before&#39; string because we are on the</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>character after.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">(( WORDPOS = ${#before} + 1 ))</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <i>What&#39;s  after  the  current  word:  everything  except  consecutive</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>non-spaces at the start of the right buffer.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">after=${RBUFFER##[^[:space:]]##}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <i>Position  of  the  end  of  the  current  word.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">(( endpos = ${#BUFFER} - ${#after} ))</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Remove quotes in the filename.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">WORD=${(Q)BUFFER[$WORDPOS,$endpos]}</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>*** End of word-finding chunk. ***</i></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">#  <i>Now  try  to  find  a  file  to  match.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">integer n_approx local -a files</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>Start at zero in case there really is a file of the given name</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"># <i>(i.e. no approximations are required to match).</i></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">for (( n_approx = 0; n_approx &lt;= max_approx; n_approx++ )); do</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;"># <i>There may be many matches, so use an array.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;"># <i>Scalar assignment doesn&#39;t do globbing anyway, so wouldn&#39;t work.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;line-height: 115%;text-align: left;">files=(  (#a$n_approx)$WORD  ) if  ((  ${#files}  ));  then</p><p class="s33" style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;"># <i>Found. We don&#39;t make a choice, just insert the first file with</i></p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;"># <i>ordinary shell quoting (the (q) flag).</i></p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;"># <i>For multiple matches, completion would be more appropriate.</i></p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">BUFFER=&quot;${BUFFER[1,$WORDPOS-1]}${(q)files[1]}\</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">${BUFFER[$WORDPOS+${#WORD},-1]}&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">return 0</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 9pt;line-height: 115%;text-align: left;">fi done</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">return 1</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">We’ll demonstrate how the widget works. Suppose the code above is in a file named <span class="s33">example-widget </span>in one of the directories contained in the <span class="s33">fpath </span>array. Let’s load it and bind it to a key sequence to make it easier to use:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>autoload example-widget</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>zle -N example-widget</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>bindkey &#39;\C-xE&#39; example-widget</b></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark741"><span class="s27">364 </span></a>CHAPTER 14 <span class="s28">■ </span>WRITING EDITOR CO MMANDS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 60pt;text-indent: 0pt;text-align: left;">In the same directory as the file <span class="s33">example-widget</span>, we type the following:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>ls eximple-wudget&lt;ctrl-x&gt;&lt;E&gt;</b></p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">The filename changes to the corrected version:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>ls example-widget</b></p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The widget will also add missing characters at the end of the filename. If you type <span class="s33">example-wid</span>, press Ctrl-x, and then press e, it will append <span class="s33">get</span>. Since we’ve limited the maximum number of characters that the function will correct to 3, <span class="s33">example-wi </span>wouldn’t be corrected. Increasing <span class="s33">max_approx </span>inside the function will make it add more characters. However, spelling correction isn’t a very good method for completing filenames. For that you can simply add <span class="s33">* </span>to the existing name rather than looking for corrections. Indeed, you can alter the function so that it performs both correcting and completing. If you’d like an exercise, see if you can work out how to make the function find a complete filename of any length where the part typed by the user contains spelling mistakes. For example, you should be able to make the function turn <span class="s33">exim </span>into <span class="s33">example-widget </span>without increasing the value of <span class="s33">max_approx</span>. Hint: there’s a trivial change to the function that will make this work.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you have experimented by using the widget to correct <span class="s33">example-wid</span>, you will have seen that the cursor stays on the <span class="s33">g </span>that the widget added. That’s because there’s no code in the function to move the cursor after the filename has been corrected. As another exercise, you could try to make the widget work more naturally when the cursor is at the end of the word that’s being corrected. You’ll find the information present in the variables is already sufficient for you to tell whether the cursor is at the end of the word when the widget starts. If it is, you should move the cursor to the end of the new word after the widget has altered the line buffer. Again, all the information is present for you to do this.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_287.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 117%;text-align: left;">■<span class="s23">Tip </span><span class="s19">The example just above offers an interesting trick. The word on the command line may have quotes that are stripped off when it is passed to a command. Sometimes you will need the word as it will be passed as a command-line argument after you press Return. The most common example is if you want to treat the word as a filename, which may have special characters quoted. You can get that with ${(Q)WORD}. Then, for example, the word Program\ Files, with a quoted space, turns into Program Files by the usual rules of quotation. You can use this unquoted form as a filename.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_288.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part387.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part389.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
