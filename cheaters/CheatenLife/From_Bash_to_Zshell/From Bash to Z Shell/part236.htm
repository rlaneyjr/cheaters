<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Multiple Matches</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part235.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part237.htm">Next &gt;</a></p><p class="s18" style="padding-left: 41pt;text-indent: 0pt;text-align: left;"><a name="bookmark426">Multiple Matches</a></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">Sometimes it’s useful to determine whether a character or group of characters is matched an indefinite number of times. For example, a name may have a repeated string in the middle and you want to match however many repetitions there are. The character <span class="s33"># </span>placed after a character or group allows that character or group to be matched any number of times, including zero. (It’s similar to the character <span class="s33">* </span>in a regular expression, but that character was already taken in the shell.)</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note we said a <i>character </i>or <i>group</i>. If you put <span class="s33"># </span>after a single character, only that character is matched multiple times, whereas if you put it after something in parentheses or brackets, the whole expression is matched. Consider the following examples. First, we list the files in the directory. Next, we match a file whose name consists of zero or more uppercase <span class="s33">A</span>’s followed by <span class="s33">readme</span>. Then we display all files consisting of any number of lowercase <span class="s33">a</span>’s and <span class="s33">b</span>’s. Finally, we show all files consisting of pairs of characters; in each pair the first character must be <span class="s33">H</span>, but the second can be anything:</p><p class="s33" style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh%  <b>ls</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">AAreadme    Areadme    HeHiHo    readme    abba zsh%  <b>echo  A#readme</b></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">AAreadme  Areadme  readme zsh%  <b>echo  [ab]#</b></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;text-align: left;">abba</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh%  <b>echo  (H?)#</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">HeHiHo</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">You will probably find that you use this approach mostly with expressions in parentheses; in fact, you probably won’t use it very much with files at all. It really comes into its own when matching against arbitrary patterns, which we discuss in the section “Condition Tests” in Chapter 13. This form is equivalent to the </span>bash <span class="p">and </span>ksh *(<span class="s32">pattern</span>)<span class="p">.</span></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Bear in mind that <span class="s33"># </span>only refers to the character or group immediately preceding it. In <span class="s33">A#readme </span>the <span class="s33"># </span>only refers to the <span class="s33">A </span>just before it. If the pattern had been <span class="s33">BA#readme</span>, it would have matched <span class="s33">Breadme</span>, <span class="s33">BAreadme</span>, <span class="s33">BAAreadme</span>, and so on. If you want it to match <span class="s33">BABAreadme</span>, <span class="s33">BABABAreadme</span>, and so on, you need to introduce parentheses and write the pattern as <span class="s33">(BA)#readme</span>.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">A very close relative of <span class="s33"># </span>is <span class="s33">##</span>. It indicates one or more occurrences of the preceding pattern.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">The two <span class="s33"># </span>characters act together; you should think of the two combined as a single special symbol. Let’s consider another example:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">zsh%  <b>echo  A#readme </b>AAreadme  Areadme  readme zsh%  <b>echo  A##readme </b>AAreadme  Areadme</p><p class="s29" style="padding-top: 3pt;padding-left: 280pt;text-indent: 0pt;text-align: left;"><a name="bookmark466">CHAPTER 9 </a><span class="s28">■ </span>PATTER N MATCHIN G <span class="s27">219</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">That’s just the same as writing <span class="s33">AA#readme</span>; again, the double hash is useful when something complicated appears in square brackets or parentheses before it. These two examples are equivalent to the <span class="s33">bash </span>and <span class="s33">ksh </span>patterns <span class="s33">*(A)readme </span>and <span class="s33">+(A)readme</span>, respectively.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part235.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part237.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
