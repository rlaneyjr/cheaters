<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Patterns</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part324.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part326.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark590">Patterns</a></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">We saw in Chapter 9 that the shell offers a fairly powerful mechanism for matching filenames using patterns. Generating lists of files is not the only place that the shell allows you to use these patterns. As we’ll see, a number of variable substitution forms make use of these patterns. These are very similar in effect to using <span class="s33">sed</span>’s <span class="s33">s </span>command on a variable’s value except that <span class="s33">sed </span>uses real regular expressions. We’ll refer to these substitution forms as <i>pattern operators </i>because they all use a special operator character after the variable name and are followed by a pattern.</p><p class="s33" style="padding-left: 60pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="p">Let’s look first at the operators </span>${<span class="s32">variable</span>#<span class="s32">pattern</span>}<span class="p">, </span>${<span class="s32">variable</span>##<span class="s32">pattern</span>}<span class="p">,</span></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">${<span class="s32">variable</span>%<span class="s32">pattern</span>}<span class="p">, and </span>${<span class="s32">variable</span>%%<span class="s32">pattern</span>}<span class="p">. These operators expand </span><span class="s32">variable</span><span class="p">, removing text that matches </span><span class="s32">pattern</span><span class="p">. The operators </span># <span class="p">and </span>## <span class="p">remove text from the left side (beginning) of the value; </span>% <span class="p">and </span>%% <span class="p">remove text from the right side (end). (Here’s a tip to help you remember which operator removes from which side. The number sign </span># <span class="p">may be used at the left side of a number while writing, for example, “task #1” to mean “task number 1.” Also, the percent sign </span>% <span class="p">is used at the right side of a number as a percentage—for example, “95%” meaning “95 percent.”) The single-character operators </span># <span class="p">and </span>% <span class="p">remove the least text possible; the double-character operators </span>## <span class="p">and </span>%% <span class="p">remove the most text possible. Some examples should make all of this clear.</span></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The following example examines the <span class="s33">HOME </span>variable and removes from the beginning of its value the part matching the pattern:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>echo ${HOME##*/}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">opk</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">In this case my home directory is <span class="s33">/usr/people/opk </span>so the <span class="s33">/usr/people/ </span>part has been removed.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">You may spot here a minor difference in how the pattern is interpreted from how it would be for globbing. The difference is that the star (<span class="s33">*</span>) is able to match slashes (<span class="s33">/</span>) separating direc- tory names: slashes are only considered special when doing globbing. So <span class="s33">zsh</span>’s <span class="s33">**/ </span>and <span class="s33">***/ </span>forms, along with features like <span class="s33">zsh</span>’s glob qualifiers, can’t be used here (though globbing flags such as <span class="s33">(#i) </span>can be).</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">When we are using patterns to match filenames, the question of exactly how much of a filename the pattern matches doesn’t matter: we are only interested in whether the pattern matches the whole filename or not. When removing the matching portion of a variable, however, the question does matter. The pattern <span class="s33">*/ </span>matches all of <span class="s33">/</span>, <span class="s33">/usr/</span>, and <span class="s33">/usr/people/</span>, so how does it decide which to remove?</p><p class="s33" style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;"><span class="p">With the </span>${<span class="s32">variable</span>##<span class="s32">pattern</span>} <span class="p">form we used here, the longest possible match is removed.</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">There is a second form that takes the shortest match:</p><p class="s29" style="padding-top: 3pt;padding-left: 314pt;text-indent: 0pt;text-align: left;"><a name="bookmark617">CHAPTER 12 </a><span class="s28">■ </span>VARIABLES <span class="s27">295</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo ${HOME#*/}</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">usr/people/opk</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The reason we showed the other form first is that that is how regular expressions normally work. Or, to use the standard terminology for this behavior, regular expressions are <i>greedy</i>.</p><p style="padding-left: 40pt;text-indent: 20pt;line-height: 115%;text-align: justify;">As we said, the related pattern operators with <span class="s33">% </span>and <span class="s33">%% </span>allow you to remove from the end of a value the part that matches a pattern. For example, <span class="s33">${HOME%/*} </span>will remove the lastcomponent of the path to your home directory. In <span class="s33">zsh</span>, you can use <span class="s33">${HOME%%[^/]#} </span>to leave a trailing slash.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_242.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">■<span class="s23">Caution </span><span class="s19">When using pattern operators to remove directory names from a path, be careful if the path might contain a single slash (/), which is the root directory. The result might be the empty string being substituted. Though they are less flexible and will only work from zsh, it can often be safer to use C shell style modifiers. For example, ${HOME:h} can be used instead of ${HOME%/*}.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_243.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">The pattern operators we have shown so far anchor the pattern to either the beginning or the end of the word. Modern shells also have a third form that is not anchored. This form is more similar to </span>sed<span class="p">’s </span>s <span class="p">command. It looks like </span>${<span class="s32">variable</span>/<span class="s32">pattern</span>/<span class="s32">string</span>}<span class="p">.</span></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">One common use of this is to access a directory that has a similar path to the current directory. In the following example we expand the <span class="s33">PWD </span>variable, replacing <span class="s33">src </span>with <span class="s33">bin </span>to run the program</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">/home/opk/dev_ws/bin/test-subsystem/test<span class="p">:</span></p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: justify;">% <b>pwd</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: justify;">/home/opk/dev_ws/src/test-subsystem</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: justify;">% <b>${PWD/src/bin}/test</b></p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">In that way you can quickly access a program in a directory parallel to the current one.</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Note that this is similar to using two arguments to <span class="s33">zsh</span>’s <span class="s33">cd </span>command as discussed in the section “Special zsh Directory Features” in Chapter 8 except that <span class="s33">cd </span>doesn’t use patterns.</p><p class="s33" style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">There is another similar form that looks like </span>${<span class="s32">variable</span>//<span class="s32">pattern</span>/<span class="s32">string</span>}<span class="p">. This doesn’t enable greedy matching as you might expect; greedy matching is actually the default for both</span></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">${<span class="s32">variable</span>/<span class="s32">pattern</span>/<span class="s32">string</span>} <span class="p">and </span>${<span class="s32">variable</span>//<span class="s32">pattern</span>/<span class="s32">string</span>} <span class="p">substitutions.</span><span class="s43">2 </span><span class="p">Instead, this</span></p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">form causes all occurrences of the pattern to be replaced. So in <span class="s33">bash </span>you might use <span class="s33">${PATH//:/ } </span>to return the directories of your path split into separate words. (Remember that in <span class="s33">zsh </span>you need to add an equals to enable word splitting (<span class="s33">${=PATH//:/ }</span>)—or you can just use <span class="s33">$path</span>.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part324.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part326.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
