<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Writing Editor Commands</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part371.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part373.htm">Next &gt;</a></p><p class="s17" style="padding-top: 9pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark703">Writing Editor Commands</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 23pt;padding-left: 40pt;text-indent: 0pt;line-height: 88%;text-align: left;"><span class="h2">S</span>ometimes you may find that <span class="s33">zsh</span>’s line editor doesn’t quite provide the features you’d like, or that you’d like a quick way of performing frequent tasks. For example, there are commands</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">to move the cursor by characters, words, and lines; maybe you frequently want to move a certain number of characters, or to a particular character, instead. Maybe a command you use frequently to search in the shell’s history doesn’t leave the cursor in the position you want.</p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Maybe you’d like an editor command to delete a complete command-line argument, even if the argument consists of a complicated quoted expression. Perhaps a command behaves slightly differently from the way it does in another shell; you’ve seen that <span class="s33">bash </span>often differs slightly from <span class="s33">zsh</span>, and you might want to imitate the <span class="s33">bash </span>behavior.</p><p class="s33" style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">zsh <span class="p">allows you to write new editor commands as shell functions. This is the subject of this chapter. These shell functions can call one or more existing editing commands, so you can easily put together a set of commands. What’s more, we’ll see how special shell variables exist that allow you to change the editor buffer directly by the use of substitutions and assignments.</span></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The structure of this chapter is as follows. First we’ll introduce the notion of a <i>widget</i>, an editor command. Then we’ll provide a step-by-step set of instructions for creating shell functions to extend the line editor. Next, we’ll show you how shell variables can add a great deal to your ability to edit the command line. The presentation of features ends with a discussion of a couple of matters we glossed over earlier: numeric arguments, which you can pass to an editor command to modify its behavior, and error handling.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Once we’ve introduced those features, we’ll show you some case studies illustrating various ways that <span class="s33">zsh </span>users have found to make their editing tasks easier. Then we will put a lot of what we’ve learned into a usable example. We’ll finish the chapter with some more advanced features that help when you’re writing widgets that need to read their own input or output messages, and briefly describe some additions that appear in version 4.2 of <span class="s33">zsh</span>. (The rest of the chapter assumes you’re using version 4.0 of <span class="s33">zsh</span>.)</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Note that we’re describing <span class="s33">zsh </span>alone. It’s possible to extend <span class="s33">bash</span>’s command-line editor, the readline library, but you need to write your own functions in the C programming language. Doing so is well outside the scope of this book. Users of <span class="s33">bash </span>should skip to Chapter 15.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part373.htm">Widgets and Functions</a><a class="toc0" href="part374.htm">Simple Recipe for a Widget</a><a class="toc1" href="part375.htm">Step 1: Write the Function</a><a class="toc1" href="part376.htm">Step 2: Create the Widget</a><a class="toc1" href="part377.htm">Step 3: Bind the Widget to a Key</a><a class="toc1" href="part378.htm">Calling Widgets from a Function</a><a class="toc1" href="part379.htm">Special Variables in zle</a><a class="toc0" href="part380.htm">Making Widgets Behave Naturally</a><a class="toc1" href="part381.htm">Passing Numeric Arguments to Widgets</a><a class="toc1" href="part382.htm">Handling Errors</a><a class="toc0" href="part383.htm">Case Study I: Multiple Tasks in Widgets</a><a class="toc0" href="part384.htm">Case Study 2: Overriding Widgets</a><a class="toc0" href="part385.htm">Case Study 3: Locating Command-Line Arguments</a><a class="toc0" href="part386.htm">Case Study 4: Chaining Widgets Together</a><a class="toc0" href="part387.htm">Approximate Matching</a><a class="toc0" href="part388.htm">An Example Widget: Correcting Spelling</a><a class="toc0" href="part389.htm">Input and Output Within Widgets</a><a class="toc1" href="part390.htm">Examining User Input</a><a class="toc1" href="part391.htm">Outputting Messages</a><a class="toc1" href="part392.htm">Keeping Other Input Away from the Command Line</a><a class="toc1" href="part393.htm">New Features in Version 4.2 of zsh</a><a class="toc0" href="part394.htm">Summary</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part371.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part373.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
