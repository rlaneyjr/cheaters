<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Option Parsing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part352.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part354.htm">Next &gt;</a></p><p class="s18" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark645">Option Parsing</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Most Unix commands accept a number of options along with normal arguments. For example, here the arguments to <span class="s33">grep </span>include the <span class="s33">-v </span>option and two further nonoption arguments:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">grep -v &#39;^#&#39; .zshrc</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">It is common when writing a script or function to want to accept options. Unfortunately, having options complicates the job of picking arguments out of the parameters: instead of the first main argument being reliably in <span class="s33">$1</span>, options might move it up to <span class="s33">$2 </span>or beyond.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">A common way to handle parameters is to loop through them. One way to loop through the parameters is with a <span class="s33">for </span>loop. If the <span class="s33">in </span>keyword and following list of words is left out of a <span class="s33">for </span>loop, it will loop through the positional parameters instead. So we might have something like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 49pt;text-indent: -9pt;line-height: 115%;text-align: left;">for  par;  do case  $par  in</p><p class="s33" style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(-a) aopt=1;;</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">(-b) bopt=1;;</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 8pt;line-height: 115%;text-align: left;">(*) arg=$par;; esac</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">A shortcoming of this method would be exposed if we add another option into the mix where that option expects to be followed by an argument of its own. Handling the parameters one at a time in this way doesn’t allow us to look ahead and consume two arguments in one iteration. We could maintain some state information ready for the next loop iteration, but there is an easier way.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">The <span class="s33">shift </span>statement moves all the parameters up a place. So <span class="s33">$2 </span>becomes <span class="s33">$1</span>, <span class="s33">$3 </span>becomes</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">$2<span class="p">, and so on. Used inside a </span>while <span class="p">loop, this makes for another way of looping through the parameters.</span></p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark684"><span class="s27">328 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: -9pt;line-height: 115%;text-align: left;">while [[ $1 = -* ]]; do case $1 in</p><p class="s33" style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(-a) aopt=1;;</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;line-height: 115%;text-align: left;">(-b) bopt=1;; (-c)</p><p class="s33" style="padding-left: 68pt;text-indent: 0pt;line-height: 115%;text-align: left;">carg=$2 shift</p><p class="s33" style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">;;</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: -4pt;line-height: 115%;text-align: center;">esac shift</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">done</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">When processing the <span class="s33">-c </span>option, the code shown picks up the following argument from <span class="s33">$2</span>. At the end, any arguments that haven’t been processed remain in the positional parameters, starting from <span class="s33">$1</span>. This code is sufficiently flexible to handle most option parsing situations.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">One thing that the above code doesn’t allow is for options to be clumped together, for example as <span class="s33">-ab </span>instead of <span class="s33">-a -b</span>. If you program in C, you may be familiar with the <span class="s33">getopt() </span>function, which allows this for C programs. Unix has a similarly named external command for use in scripts. In addition to this, there is a shell built-in named <span class="s33">getopts</span>. The built-in is a little bit more convenient to use, so let’s look at it here.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">To use <span class="s33">getopts</span>, you need to give it a specification describing the expected options. This is just a list of option letters. Any option that expects an argument should be followed by a colon. <span class="s33">getopts </span>is therefore of little use if you want to have long option names, though the previous two methods will work fine for you. Here is our example using <span class="s33">getopts</span>:</p><p class="s33" style="padding-top: 6pt;padding-left: 50pt;text-indent: -9pt;line-height: 115%;text-align: left;">while  getopts  &quot;abc:&quot;  par;  do case  $par  in</p><p class="s33" style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">(a) aopt=1;;</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">(b) bopt=1;;</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;line-height: 115%;text-align: left;">(c) carg=$OPTARG;; (?) exit 1;;</p><p class="s33" style="padding-left: 41pt;text-indent: 9pt;line-height: 115%;text-align: left;">esac done</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">shift $(( OPTIND - 1 ))</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Positioned as the condition of the while loop, <span class="s33">getopts </span>controls the loop, causing it to stop when it reaches a nonoption argument or the argument <span class="s33">--</span>. It uses three variables to provide the status. The first contains the current option with the leading dash removed. This is the one named with an argument to <span class="s33">getopts</span>—in this case <span class="s33">par</span>. The other two variables have fixed names: <span class="s33">OPTARG </span>provides any argument to an option such as for the <span class="s33">-c </span>option here and <span class="s33">OPTIND </span>is an index into the positional parameters and serves as the loop iterator. As shown in this example, <span class="s33">OPTIND </span>can be useful at the end of the loop with <span class="s33">shift </span>to remove all the option arguments. If passed a numeric parameter, <span class="s33">shift </span>will shift the parameters by that many places. <span class="s33">zsh </span>also allows <span class="s33">shift </span>to be used with arrays if given the array name as a parameter.</p><p class="s33" style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">zsh <span class="p">has one further built-in—named </span>zparseopts<span class="p">—for parsing options. It was developed with the peculiarities of completion functions in mind but can be useful elsewhere. What is unusual about completion functions is that they don’t generally want to dissect all the options passed to them: instead they want to just pick out the few that are of interest and have the</span></p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark685">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">329</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">remainder ready for passing on unchanged, either to further completion functions or the <span class="s33">compadd </span>built-in. If you want to accept your own options from a completion function, you need to carefully avoid option letters that clash with <span class="s33">compadd </span>options and, because they may be passed mixed in with the <span class="s33">compadd </span>options, use <span class="s33">zparseopts </span>to extract them.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">To use <span class="s33">zparseopts</span>, first divide up the list of possible options into those you want to throw away, those you want to look at, and those you want to keep ready for passing on. Like <span class="s33">getopts</span>, it needs specifications to describe the possible options. Unlike <span class="s33">getopts</span>, though, each option is in its own word, which means long option names can be handled. Specifications are just the option name followed by a colon if an argument is expected. Here is an example:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zparseopts -D -E -a garbage C=usecc O:=subopts J: V: 1 2 X:</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">By using the <span class="s33">-D </span>option here, all the specified options are removed from the positional parameters. Any others are left in <span class="s33">&quot;$@&quot; </span>ready to be passed on to another completion function. The specified options are put into the <span class="s33">garbage </span>array (defined with the <span class="s33">-a </span>option) where they can subsequently be ignored. The exception to this is the <span class="s33">-C </span>and <span class="s33">-O </span>options for which we have explicitly defined an alternate variable. So in this example <span class="s33">-C </span>or <span class="s33">-O </span>options are put, along with their arguments, into the <span class="s33">usecc </span>and <span class="s33">subopts </span>variables, respectively.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Without the <span class="s33">-E </span>option, it would stop at the first option for which there is no specification. Often you just want to extract one option from the parameters, and this is very useful for doing that. It is also common to just give specifications for options you want to remove.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">That brings us to the end of our coverage of the positional parameters. Next we’ll consider another form that input to a script can take: text read from a file or a command’s output.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part352.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part354.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
