<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Case Study 2: Overriding Widgets</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part383.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part385.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark715">Case Study 2: Overriding Widgets</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">In some cases it’s useful to replace an existing widget with one of your own. This can be quite convenient because any key bindings automatically refer to the replacement widget. Suppose you don’t like <span class="s33">forward-word</span>’s behavior because of what it considers to be a word. You can create a new widget called <span class="s33">forward-word </span>that works the way you want.</p><p style="padding-left: 40pt;text-indent: 20pt;line-height: 115%;text-align: left;">Replacing an existing widget is trivial if the replacement function does everything you want on its own. Use <span class="s33">zle -N </span>to create the widget in the normal way, giving it the name of the editor widget you want to override. The shell will use the widget you’ve created in preference to the built-in widget.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">For example, you could have used the name <span class="s33">delete-word </span>for the widget we called <span class="s33">delete-space-word</span>. Then the shell would call our function instead of the built-in widget when- ever the user asked for the widget, whether by name or key binding. The following example uses the same function, <span class="s33">delete-space-word</span>, but creates widgets with the names <span class="s33">delete-word </span>and <span class="s33">backward-delete-word</span>, overriding the built-in widgets with the same names:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">autoload delete-space-word</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zle -N delete-word delete-space-word</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zle -N backward-delete-word delete-space-word</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note the test for the pattern <span class="s33">backward-* </span>in the function <span class="s33">delete-space-word </span>in the previous section. This causes the replacement widget <span class="s33">backward-delete-word </span>to delete backwards. That’s a good reason for testing the name using a pattern, in this case <span class="s33">backward-*</span>, when you select the widget’s behavior. If the test had been <span class="s33">[[ $WIDGET = backward-delete-space-word ]]</span>, the widget with this name would have deleted forwards. Then you couldn’t have used the same function to override <span class="s33">backward-delete-word</span>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">If you make a mistake overriding a widget such as <span class="s33">delete-word</span>, it’s not a big problem; you can still continue editing. However, it’s possible to override even the most basic widgets. If you make a mistake here, it can stop the shell working entirely. Nonetheless, it can still be useful to override such widgets, since you can add extra functionality to the existing widgets.</p><p style="padding-left: 40pt;text-indent: 19pt;line-height: 115%;text-align: left;">We’ll illustrate this by redefining the widget <span class="s33">accept-line</span>. This is executed when you press Return to execute a line. If you redefine <span class="s33">accept-line</span>, it’s necessary to call the original widget during the execution of your adapted version; otherwise the shell will never see the edited command line. For this purpose the shell has another name for every built-in widget. The alter- native name is identical except that it has a “<span class="s33">.</span>” in front. Therefore in this case the name would be <span class="s33">.accept-line</span>. So to override <span class="s33">accept-line </span>you should define a widget <span class="s33">accept-line </span>of your own that calls your special code and then runs <span class="s33">zle .accept-line</span>.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark735"><span class="s27">358 </span></a>C HA P T E R 14 <span class="s28">■ </span>W R I T I N G E D I T O R CO M M A N D S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here’s a function to be used as the <span class="s33">accept-line </span>widget that puts the first word on the command line into an <span class="s33">xterm </span>title bar:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">print  -n  &quot;\e]2;${BUFFER%%[[:space:]]*}\a&quot; zle  .accept-line</p><p style="padding-top: 7pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In this example, we stripped off everything starting from the first occurrence of a space character to the end of the buffer. Then we added xterm escapes to put this into the title bar. Finally, and crucially, we’ve called <span class="s33">.accept-line </span>to pass the command line to the main shell for execution. Don’t forget that, or you’ll never be able to execute any command line at all! In emacs mode you can press Esc x and type <span class="s33">.accept-line </span>to execute the line. If you want to be careful about such problems redefining widgets, you can create a widget that contains the following code:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">bindkey  -A  main  .safe</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 17pt;line-height: 115%;text-align: left;">When executed, this causes the line editor to use the <span class="s33">.safe </span>keymap, which is guaranteed to allow you to type and execute command lines. You should then repair the damage to the keymap you were using, and switch back to it with another <span class="s33">bindkey  -A </span>command.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">To undo the behavior of the redefined widget, you must tell the shell that the <span class="s33">accept-line</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">widget is now to be the same as the <span class="s33">.accept-line </span>widget. You do that with an alias:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zle  -A  .accept-line  accept-line</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There are more sophisticated possibilities where instead of simply redefining <span class="s33">accept-line </span>you provide commands for switching on the special behavior, and switching it off again. This gives the user an easy way of selecting either the new or the original behavior. The best way of doing this is to give the special version of <span class="s33">accept-line </span>its own name, say <span class="s33">my-accept-line</span>, and use aliases to switch the special behavior on and off. Let’s suppose the function to switch the special behavior on is called <span class="s33">special-on</span>, and the function to switch it off again is called <span class="s33">special-off</span>. You can write the two as follows, regardless of what your function <span class="s33">my-accept-line </span>does:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">special-on()  {</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">zle  -A  my-accept-line  accept-line</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">special-off()  {</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">zle  -A  .accept-line  accept-line</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">For once, we’ve shown the functions in full, instead of as they’d appear for autoloading.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">You can use these as widgets, but if you’re on the ball you may have noticed that they’re perfectly ordinary shell functions. Unlike the use of <span class="s33">zle </span>to call other widgets, which only works inside a widget function, other uses are always available. It would be hard to define a widget if you had to do it from within another widget! So you can simply run <span class="s33">special-on </span>and <span class="s33">special-off </span>as commands, if you prefer.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part383.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part385.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
