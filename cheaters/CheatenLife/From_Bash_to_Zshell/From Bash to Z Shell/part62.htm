<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Stopping a Job</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part61.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part63.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark122">Stopping a Job</a></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">Your Unix system is good at managing multiple processes, giving them time to run when they have something to do and letting them sleep (so other processes can run) when they’re idle. It’s possible, however, to have so many processes running that the system runs low on memory or CPU cycles. When that happens, system response can get sluggish. You can stop a background job completely to let the system do something else. Later, you can restart the job from where it left off; you won’t lose your place. If the job has opened windows of its own, you should mini- mize (iconify) those windows before you stop the job; otherwise, they’ll probably “freeze” when you stop the job, and you won’t be able to do anything with them until you’ve restarted the job.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">On the C shells, you can stop a job using the <span class="s33">stop </span>command and a job number. Job numbers start with a percent sign (<span class="s33">%</span>). For instance, to stop Mozilla, first minimize its window, then stop it—and, if you want to, check its status:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">% <b>stop %1</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">%  <b>jobs</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">[1]    +  Suspended  (signal)         mozilla</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">[2]       Running                             xemacs</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">%</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Most Bourne-type shells don’t have a <span class="s33">stop </span>command, but you can use <span class="s33">kill </span>instead. The <span class="s33">kill </span>command doesn’t necessarily “kill” a job; it sends a <i>signal </i>to the process(es) in the job. The basic idea is that <span class="s33">kill </span>lets you control a job or an individual process.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The first argument to <span class="s33">kill </span>is a signal name or signal number, preceded by a dash (like an option). The other argument(s) to <span class="s33">kill </span>are the job numbers or PIDs that should get the signal.</p><p style="padding-left: 41pt;text-indent: 20pt;line-height: 115%;text-align: left;">Most of the signals are useful for programmers, but a few are handy for all users. One signal, SIGTSTP, sends a “stop from terminal” signal to a process. SIGTSTP gives a process time to organize itself and stop gracefully, so it’s the right signal to send when you can. But a program also can ignore SIGTSTP. A “stronger” stop signal, SIGSTOP, can’t be ignored and will take effect immediately—but it may leave a process in an inconsistent state, so only use it when you have to stop a process and SIGTSTP doesn’t work. Let’s assume that you started Mozilla from the Z shell. To stop it, you’d do the following:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh%  <b>kill  -TSTP  %1</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh%</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh%  <b>jobs</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">[1]    +  suspended  (signal)    mozilla</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">[2]       running                       xemacs</p><p class="s29" style="padding-top: 3pt;padding-left: 269pt;text-indent: 0pt;text-align: left;"><a name="bookmark133">CHAPTER 3 </a><span class="s28">■ </span>MORE SHELL FEATURES <span class="s27">59</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you’d like to add a <span class="s33">stop </span>command to your non-C shell, an alias (see the section “Command Lines” in Chapter 1) should do the trick:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">alias  stop=&#39;kill  -TSTP&#39;</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">You might also want to send a signal to a job that’s not in the background—that is, a job that’s running in a terminal and you don’t have a shell prompt (so you can’t use the <span class="s33">stop </span>or <span class="s33">kill </span>command with the job number). Years ago, when most users had only a single terminal (and no windows), being able to stop what you were doing—get a shell prompt, run another command, then resume the job where you left off—was revolutionary. These days, many users with windows will simply leave one window where it is and open another window. But opening a new window has some disadvantages:</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• The new window won’t have any changes you’ve made to the existing window (its command history, current directory, shell and environment variables you’ve reset, and so on). However, you can save and restore history entries through shell variables like <span class="s33">HISTFILE</span>, as Chapter 6 explains.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• Opening a new window probably requires you to move the mouse, open menus or click a button, move to the new window and click on it, and so on: it takes some time. But getting a new shell prompt in your current window takes just two keystrokes: Ctrl-z.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• A new window takes some system resources (especially memory) to open. On the other hand, stopping the job in your current window takes no resources; in fact, it can free system resources. That may be important on an overloaded system.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part61.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part63.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
