<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Finding the Key Sequences for Function Keys</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part90.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part92.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark167">Finding the Key Sequences for Function Keys</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Your keyboard probably has a row of function keys at the top. If you are using a full-size PC keyboard there is also a group of six named keys above the cursor keys. The keys have names like F1 and Home. It’s very useful to bind these to commands.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Unfortunately, you can’t simply use the name on the key. Shells only have the ability to read strings of characters. The terminal emulator generates a string of characters (often called an <i>escape sequence</i>) for each special key. These bear no relation to the names on the keys. Luckily, it’s easy to bind the escape sequences. The hard part is finding out what sequence of characters the function keys send. The simplest, most general way we know of is to type <span class="s33">read</span>, then press Return, then the key combination you want to investigate. You’ll see the characters the terminal sends. Let’s try the function key F1. On my system this has the following effect:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh% <b>read</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">^[[11~</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: justify;">(If you press Return again, you’ve actually assigned that value to the variable <span class="s33">REPLY</span>. We’ll meet <span class="s33">read </span>in the section “Reading Input” in Chapter 13.) The characters appear literally because neither shell currently uses the line editor for the <span class="s33">read </span>command.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The key sequence <span class="s33">^[[11~ </span>shown above is the one most commonly produced by F1. It’s not guaranteed to be the same in other terminal programs, if you use more than one, but there’s a pretty good chance. However, it doesn’t matter as long as you know what the string is.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">The <span class="s33">^[ </span>represents an escape character. The shells know that as <span class="s33">\e</span>, which is a little more obvious. So here’s how to make F1 perform the command <span class="s33">forward-word </span>in <span class="s33">bash</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">bash$ <b>bind &#39;&quot;\e[11~&quot;: forward-word&#39;</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 185%;text-align: left;">Here’s the corresponding example in <span class="s33">zsh</span>: <span class="s33">zsh% </span><span class="s46">bindkey &#39;\e[11~&#39; forward-word</span></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Very often the key sequences sent by Shift-F1, Ctrl-F1, and Alt-F1 are different from the key sequence sent by F1 alone. I get <span class="s33">\e[23~</span>, <span class="s33">\e[11^</span>, and <span class="s33">\e\e[11~</span>, respectively; you can of course investigate and bind these in just the same way. You may also be able to combine the modi- fiers, for example Shift-Alt-F1, to get yet another key sequence.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_138.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 117%;text-align: left;">■<span class="s23">Warning </span><span class="s19">There is a good chance that one or more of the modified forms of the function keys are inter- cepted by the window manager for some special task. Usually it is possible to get round this by changing key bindings for the window manager, either in a startup file or interactively using the Gnome or KDE control panel or equivalent. Also, the terminal emulator itself may intercept keys; for example, often Shift-PageUp scrolls the terminal window.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_139.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The set of six keys—Insert, Delete, Home, End, PageUp, and PageDown—found on modern PC keyboards can be treated in the same way we just described for function keys. You may decide to make these do what their names suggest. (In modern graphical editors, they already will:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark207"><span class="s27">92 </span></a>CHAPTER 4 <span class="s28">■ </span>EN TERING AND ED ITING THE CO MMAND LINE </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">Home often moves the cursor to the beginning of the line. However, the shell doesn’t have a binding until you give it one.)</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">For example, both shells have an <span class="s33">overwrite-mode </span>editor command that toggles the line editor between two states. In the normal state (insert), typing a character in the middle of a command line inserts the new character and pushes the existing text to the right. In the other state (overwrite), typing a character replaces the character that was there before and leaves the rest of the line where it was. It’s quite useful to bind this to the Insert key. (If you like overwrite mode, in <span class="s33">zsh </span>you can use the command <span class="s33">setopt overstrike </span>to make it the default mode when the line editor starts.)</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Also, you might want to bind Home and End to <span class="s33">beginning-of-history </span>and <span class="s33">end-of-history</span>, which take you to the first and last line in the history.</p><p style="padding-left: 59pt;text-indent: 0pt;line-height: 10pt;text-align: left;">On my terminal, I can bind the keys as follows:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">zsh% <b>bindkey &#39;\e[2~&#39; overwrite-mode </b># Insert zsh% <b>bindkey &#39;\e[1~&#39; beginning-of-history </b># Home zsh% <b>bindkey &#39;\e[4~&#39; end-of-history </b># End</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">As we just noted, <span class="s33">\e[2~ </span>has the same effect as <span class="s33">^[[2~</span>, and so on. The <span class="s33">\e </span>for escape is just a little more readable. Note that the cursor keys, too, send escape sequences of this sort. The shells try to find out what the cursor keys send and bind them for you, but in any case you can use the <span class="s33">read </span>command to find out. What’s more, the cursor keys with modifiers, such as Ctrl-Up Arrow, may send different key sequences from the Up and Down Arrow keys alone. So you can bind those, too.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you use several terminal emulators where the function keys send different escapes, you can use the shell’s <span class="s33">case </span>statement to choose the right binding for the terminal. We show an example of that in the section “Case Statement” in Chapter 13.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part90.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part92.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
