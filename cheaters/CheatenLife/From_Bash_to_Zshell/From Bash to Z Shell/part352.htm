<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Positional Parameters</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part351.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part353.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark644">Positional Parameters</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">One of the more noteworthy forms of input to a shell script or function consists of the param- eters passed on the command line. From within a script or function, these parameters are on hand in a set of variables that are referred to as the <i>positional parameters</i>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">We have seen one of these already: <span class="s33">$1</span>, which contains the first argument passed to our function or script. There is a whole collection of these: <span class="s33">$2</span>, <span class="s33">$3</span>, and so on up to <span class="s33">$9</span>, each containing the next parameter. After 9 you need to use braces: <span class="s33">${10}</span>, though <span class="s33">zsh </span>allows <span class="s33">$10</span>, <span class="s33">$11</span>, and so on. A <span class="s33">$# </span>variable contains the number of parameters that have been supplied. You can also view all the positional parameters together with the <span class="s33">$* </span>string or <span class="s33">$@ </span>array.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The difference between <span class="s33">$* </span>and <span class="s33">$@ </span>is exactly the same as for <span class="s33">${arr[@]} </span>and <span class="s33">${arr[*]} </span>array expansions as was described in the section “Array Expansions” in Chapter 12. Functionally, you will only see the difference when you use them in double quotes:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>set -- one two three</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>printf &#39;%s\n&#39; &quot;$*&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">one two three</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>printf &#39;%s\n&#39; &quot;$@&quot;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">one two three</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: left;">Using the <span class="s33">set </span>command as in this example allows you to set the positional parameters. <span class="s33">zsh </span>also allows conventional assignments to be used for them. For example, <span class="s33">5=five </span>will assign “<span class="s33">five</span>” to <span class="s33">$5</span>.</p><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: center;">THE MANY USES OF SET</p><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: center;">THE MANY USES OF SET</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 114pt;text-indent: 0pt;text-align: center;">THE MANY USES OF SET</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark682"><span class="s27">326 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">You may have noticed that the set command has more than one use. This can be confusing because most commands only do one thing. To clarify the situation for set, here is a summary of its uses:</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Setting options: </span>by using options, and -o in particular, set allows you to turn options on and off. This is similar to zsh’s setopt and bash’s shopt. See the section “Setting Options with set” in Chapter 5.</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Assigning to the positional parameters, </span>which we cover in this section. This is normally seen beginning with set --. The “--” is only actually necessary if the following arguments could cause this form to be confused for one of the other two.</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Assigning to arrays: </span>set -A is the old way of assigning to array variables, which we mentioned in the section “Arrays” in Chapter 12.</p><p class="s33" style="padding-top: 7pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">The first two uses go back to the Bourne shell. In particular, there was no other way of setting options apart from set -o, so this use is still common. (Remember that in bash the options set using set -o are distinct from those set using shopt -s.)</p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">You may have noticed that the set command has more than one use. This can be confusing because most commands only do one thing. To clarify the situation for set, here is a summary of its uses:</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Setting options: </span>by using options, and -o in particular, set allows you to turn options on and off. This is similar to zsh’s setopt and bash’s shopt. See the section “Setting Options with set” in Chapter 5.</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Assigning to the positional parameters, </span>which we cover in this section. This is normally seen beginning with set --. The “--” is only actually necessary if the following arguments could cause this form to be confused for one of the other two.</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Assigning to arrays: </span>set -A is the old way of assigning to array variables, which we mentioned in the section “Arrays” in Chapter 12.</p><p class="s33" style="padding-top: 7pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">The first two uses go back to the Bourne shell. In particular, there was no other way of setting options apart from set -o, so this use is still common. (Remember that in bash the options set using set -o are distinct from those set using shopt -s.)</p><p style="padding-left: 41pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">You may have noticed that the set command has more than one use. This can be confusing because most commands only do one thing. To clarify the situation for set, here is a summary of its uses:</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Setting options: </span>by using options, and -o in particular, set allows you to turn options on and off. This is similar to zsh’s setopt and bash’s shopt. See the section “Setting Options with set” in Chapter 5.</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Assigning to the positional parameters, </span>which we cover in this section. This is normally seen beginning with set --. The “--” is only actually necessary if the following arguments could cause this form to be confused for one of the other two.</p><p class="s33" style="padding-top: 6pt;padding-left: 30pt;text-indent: -12pt;line-height: 114%;text-align: left;">• <span class="s13">Assigning to arrays: </span>set -A is the old way of assigning to array variables, which we mentioned in the section “Arrays” in Chapter 12.</p><p class="s33" style="padding-top: 7pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">The first two uses go back to the Bourne shell. In particular, there was no other way of setting options apart from set -o, so this use is still common. (Remember that in bash the options set using set -o are distinct from those set using shopt -s.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 4pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">There is one positional parameter we haven’t mentioned yet: <span class="s33">$0</span>. It contains the name of the script itself as it was typed on the command line. This has a number of uses. As we saw in the section “Login Shells” in Chapter 5, the shell itself looks at its 0th argument for an initial dash to decide if it is to be a login shell or not. In scripts, it is not uncommon to use a hard link to allow one script to have two different names and alter its behavior slightly depending on the script name. This isn’t unique to scripts: <span class="s33">gzip </span>and <span class="s33">gunzip </span>are typically a hard link to the same file. Another common use for <span class="s33">$0 </span>is when printing the command name in an error message. For example, you might begin your script with</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">if [[ -z $1 ]]; then</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">echo &quot;${0##*/}: parameter expected&quot; &gt;&amp;2 exit 1</p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: left;">fi</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">If you try this out in a function as opposed to a script, you will be in for two nasty surprises. The <span class="s33">exit </span>statement here exits the shell and says that we want to use an exit status of 1. It won’t just return from the function. In a function, we need to use a <span class="s33">return </span>statement instead. So if you tried this in a function, your shell would exit and the window associated with it would disappear and you wouldn’t see the first nasty surprise. The first surprise would be that instead of printing the name of your function the error would look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">-bash: parameter expected</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In <span class="s33">zsh</span>, it would work as expected (unless you turn the <span class="s33">function_arg_zero </span>option off). In <span class="s33">bash</span>, you have to use the <span class="s33">FUNCNAME </span>special variable instead to get the name of the function. Note that as of version 3, <span class="s33">FUNCNAME </span>is an array containing the names of all functions in the current call stack. This means that the first element contains the name of the currently executing function, the second element is the name of the function that called that, and so on. <span class="s33">zsh </span>has a similar array named <span class="s33">funcstack </span>provided by the <span class="s33">zsh/parameter </span>module.</p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark683">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">327</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">One more feature provided by <span class="s33">zsh </span>is that the positional parameters can also be accessed via <span class="s33">argv </span>and <span class="s33">ARGC </span>special variables. These come from C shell, but <span class="s33">zsh </span>is really too unlike C shell for them to ever be useful in running C shell scripts. <span class="s33">argv </span>is an array corresponding to <span class="s33">$@ </span>while <span class="s33">ARGC </span>is a scalar and corresponds to <span class="s33">$#</span>. One use for <span class="s33">argv </span>is if you want to assign to a particular positional parameter where the index of the positional parameter is held in another variable. For example, the following assigns the value <span class="s33">five </span>to <span class="s33">$5</span>:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">index=5 argv[index]=five</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 18pt;line-height: 114%;text-align: justify;">It is not possible to write <span class="s33">@[index]=five</span>. <span class="s33">argv </span>is also sometimes used with subscript flags. So for example, we might use <span class="s33">$argv[(I)-X] </span>to search for the <span class="s33">-X </span>option in the positional parameters. In this case, we could have used <span class="s33">$@[(I)-X] </span>but <span class="s33">argv </span>is somewhat more readable.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part353.htm">Option Parsing</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part351.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part353.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
