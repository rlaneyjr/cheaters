<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Scripting and Functions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part336.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part338.htm">Next &gt;</a></p><p class="s17" style="padding-top: 9pt;padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark629">Scripting and Functions</a></p><p style="text-indent: 0pt;text-align: left;"><br/></p><h2 style="padding-top: 23pt;padding-left: 40pt;text-indent: 0pt;line-height: 88%;text-align: left;">A <span class="p">shell script may contain no more than a few commands, although the shell offers a complete programming language. Using features like loops and condition tests can allow you to do very</span></h2><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">powerful things just from the command line. Often, however, it can be useful to save a set of commands in a file for later reuse. This aspect of scripting was largely covered in Chapter 2. In this chapter we focus on more advanced uses of scripting where the script needs to make deci- sions based on its inputs or to the result of previous operations. A particular aim of this chapter is to introduce ways in which shell programming can be used to extend the base functionality of the shell. That theme continues into the following two chapters, where we show how to write line editor widgets and completion functions to customize the shell’s interactive environment.</p><p style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">The structure of this chapter is as follows:</p><p style="padding-top: 8pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• We start with an overview of the basic programming syntax offered by the shell. This includes how to control the flow of execution by evaluating conditions, how to repeat sections of code in a loop, and how to separate sections of code that you want to run more than once into subroutines, or <i>functions</i>.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• Next, we cover input and output. This includes how to read and write files from a script and how to handle command-line arguments.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• <span class="s33">zsh</span>’s automatic function-loading mechanism is explained next. This is used to manage the many functions that are a part of the completion system, so this is relevant to Chapter 15.</p><p style="padding-top: 7pt;padding-left: 66pt;text-indent: -10pt;line-height: 115%;text-align: left;">• Next we move on to ways to extend the shell using shell code. This includes intercepting certain events to run code and how to write functions that act as additional glob quali- fiers in <span class="s33">zsh</span>.</p><p style="padding-top: 7pt;padding-left: 56pt;text-indent: 0pt;text-align: left;">• Finally, we discuss a number of techniques for debugging shell scripts.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 39pt;text-indent: 0pt;text-align: right;">307</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark664"><span class="s27">308 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="508" height="404" alt="image" src="Image_253.png"/></span></p><p class="s40" style="padding-top: 4pt;padding-left: 167pt;text-indent: 0pt;text-align: left;">WHY WRITE SHELL SCRIPTS?</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">You may wonder why anyone would choose to use the shell when writing a program to perform anything more than the simplest task. After all, there are other scripting languages such as Perl, Python, and Ruby that are in many ways more capable. They certainly have their place and in many situations we would advocate their use over the shell. Nevertheless, you will find situations when a shell script is a good choice:</p><p class="s33" style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;">• When most of what you want to do involves calling other Unix commands. This is a natural application of the shell.</p><p class="s33" style="padding-top: 7pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">• When you have already constructed most of the program interactively from the command line.</p><p class="s33" style="padding-top: 8pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;">• When you want to make changes to the current shell’s environment or current directory. This is only possible from a shell function or sourced script.</p><p class="s33" style="padding-top: 7pt;padding-left: 72pt;text-indent: -12pt;line-height: 115%;text-align: left;">• When portability is an issue: you can rely on the Bourne shell existing anywhere. Scripting languages like Perl and even the newer shells like bash and zsh are potentially unavailable. Note, however, that issues related to writing portable shell scripts are beyond the scope of this book.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">However, if you need complicated data structures, a lot of text parsing, or access to low-level routines, or if speed of execution is a consideration, then the shell is probably not your best option.</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Because the shell is the foremost way of interacting with a Unix system, familiarity with it is perhaps the main reason for using it for scripting. Nevertheless, it is very useful to be aware of what it can do. You’ll need to be comfortable with writing shell code to make the most of the following chapters on programming the shell line editor and completion systems.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part338.htm">Programming with the Shell</a><a class="toc1" href="part339.htm">Control Flow</a><a class="toc2" href="part340.htm">Condition Tests</a><a class="toc2" href="part341.htm">Control Operators</a><a class="toc1" href="part342.htm">Case Statement</a><a class="toc1" href="part343.htm">More Looping</a><a class="toc2" href="part344.htm">The break and continue Statements</a><a class="toc1" href="part345.htm">Parsed Comments</a><a class="toc1" href="part346.htm">Grouping and Subshells</a><a class="toc1" href="part347.htm">Functions and Variable Scope</a><a class="toc1" href="part348.htm">Porting Scripts</a><a class="toc0" href="part349.htm">Input and Output</a><a class="toc1" href="part350.htm">Writing Output</a><a class="toc1" href="part351.htm">Exit Statuses</a><a class="toc1" href="part352.htm">Positional Parameters</a><a class="toc2" href="part353.htm">Option Parsing</a><a class="toc1" href="part354.htm">Reading Input</a><a class="toc2" href="part355.htm">Backreferences</a><a class="toc2" href="part356.htm">Asking the User for Input</a><a class="toc0" href="part357.htm">Propagating Functions</a><a class="toc1" href="part358.htm">Exporting Functions</a><a class="toc1" href="part359.htm">Autoloadable Functions</a><a class="toc0" href="part360.htm">Traps and Special Functions</a><a class="toc1" href="part361.htm">Trapping Signals</a><a class="toc1" href="part362.htm">Special Functions</a><a class="toc1" href="part363.htm">Replacing Built-in Commands</a><a class="toc0" href="part364.htm">Defining New Globbing Qualifiers</a><a class="toc1" href="part365.htm">Restricting the List of Files Generated</a><a class="toc1" href="part366.htm">Modifying the Results</a><a class="toc1" href="part367.htm">Accessing Extended Filesystem Attributes</a><a class="toc0" href="part368.htm">Debugging Scripts</a><a class="toc1" href="part369.htm">Trace Information</a><a class="toc1" href="part370.htm">The bash Debugger</a><a class="toc0" href="part371.htm">Summary</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part336.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part338.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
