<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Finding a Command</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part191.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part193.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark357">Finding a Command</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">If you simply want to find a command in your path, you can use the built-in <span class="s33">type</span>, common to both <span class="s33">bash </span>and <span class="s33">zsh</span>, followed by the name of the command or commands, and the shell will print out its location. It’s not restricted to external commands; if you give it the name of an alias, a shell function, or a shell built-in it will report what they are. Here is an example in <span class="s33">zsh</span>:</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark388"><span class="s27">174 </span></a>CHAPTER 8 <span class="s28">■ </span>FILES AND DIRECTORIES </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">zsh%  <b>type  cvs  ll  chpwd  echo </b>cvs  is  /usr/local/bin/cvs ll  is  an  alias  for  ls  -l chpwd  is  a  shell  function echo  is  a  shell  builtin</p><p style="padding-top: 7pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note that the shell only gives you a location for a file for external commands, <span class="s33">cvs </span>in our example; otherwise it prints a message saying what type of command the shell has found. Here is a similar example using <span class="s33">bash</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">bash$  <b>type  cvs  ll  l  echo </b>cvs  is  /usr/local/bin/cvs ll  is  aliased  to  `ls  –l` l  is  a  function</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">l ()</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">{</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">less &quot;$@&quot;</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">}</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">echo  is  a  shell  builtin</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">We’ve shown a function, <span class="s33">l</span>, which acts as an abbreviation for calling the <span class="s33">less </span>command. As you can see, <span class="s33">bash </span>is a bit more verbose about functions. You can achieve a similar effect in <span class="s33">zsh </span>with one of the following commands or options:</p><p style="padding-top: 7pt;padding-left: 57pt;text-indent: 0pt;text-align: left;">• The <span class="s33">functions </span>command, which lists only functions but lists them in full.</p><p style="padding-top: 8pt;padding-left: 67pt;text-indent: -10pt;line-height: 114%;text-align: left;">• The <span class="s33">which </span>command. This is inherited from the C shell, but has slightly different behavior. This function also exists in recent versions of <span class="s33">bash</span>.</p><p style="padding-top: 7pt;padding-left: 57pt;text-indent: 0pt;text-align: left;">• The option <span class="s33">type -f </span>lists functions in full, but still lists other types of commands, too.</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Actually, the basic command in <span class="s33">zsh </span>that provides all the other ways of finding commands is <span class="s33">whence</span>. It’s used by <span class="s33">which </span>and <span class="s33">type</span>, although <span class="s33">functions </span>is different since you can also use it to set attributes for shell functions. All are simply <span class="s33">whence </span>with different options. That’s useful to know if you’re looking in the <span class="s33">zsh </span>manual pages. Otherwise, just stick with whichever version you like.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Like many <span class="s33">zsh </span>listing commands, <span class="s33">whence </span>takes the option <span class="s33">-m </span>for “match”, which causes it to treat all its arguments like patterns. These are the same patterns used everywhere in <span class="s33">zsh</span>, and are the same patterns used for matching files that we discuss in the next chapter. They are not regular expressions as you use with <span class="s33">grep</span>. Make sure you quote the patterns to stop the shell from expanding them immediately as files in the current directory:</p><p class="s33" style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh%  <b>whence  -m  &#39;xg*&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">/usr/local/bin/xgalaga</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">/usr/X11R6/bin/xgc</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">/usr/bin/xgettext</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">/usr/X11R6/bin/xgamma</p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">A basic <span class="s33">whence </span>is less verbose than <span class="s33">type</span>, which is equivalent to <span class="s33">whence -v</span>. This, too, searches for all types of command, not just external ones:</p><p class="s29" style="padding-top: 3pt;padding-left: 263pt;text-indent: 0pt;text-align: left;"><a name="bookmark389">CHAPTER 8 </a><span class="s28">■ </span>FILES AND D I RECTORIES <span class="s27">175</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;text-align: left;">zsh%  <b>whence  -vm  &#39;*read&#39;</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">_read is a shell function</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">_acroread  is  a  shell  function zftpfn_read  is  a  shell  function read  is  a  shell  builtin</p><p class="s33" style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">timed-read  is  /usr/bin/timed-read kspread  is  /usr/bin/kspread ppmspread  is  /usr/bin/ppmspread acroread  is  /usr/local/bin/acroread</p><p style="padding-top: 7pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">We haven’t talked about what happens when you add a new command somewhere in the command search path. Usually, this isn’t a problem; the shell will search for the new command. However, if there is already a command of the same name later in the search path, the shell will use the old command instead of the new one. This is because the shell keeps a list of commands so that it can quickly find out the location from the name. The list of commands is called a <i>hash table </i>from the way it is stored. You can issue the command <span class="s33">hash -r </span>(or, in <span class="s33">zsh </span>only, <span class="s33">rehash</span>) to fix this. We talked a little about that in the section “Programs and the Path” in Chapter 2.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part191.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part193.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
