<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Programs and the Path</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part54.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part56.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark89">Programs and the Path</a><a name="bookmark113">&zwnj;</a></h4><p class="s29" style="padding-top: 3pt;padding-left: 4pt;text-indent: 0pt;text-align: left;">CHAPTER 2 <span class="s28">■ </span>USING SHELL FEATURES TOGETHER <span class="s27">49</span></p><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">Every time you want to run your script to rebuild the <span class="s33">proglist </span>file, do you have to <span class="s33">cd </span>to the directory where the script file is stored? No—not if you put your script file in one of the directories in your <span class="s33">PATH </span>environment variable. You can change the directory list in your <span class="s33">PATH</span>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s put the new script in a standard place, a directory you can use for all of your personal programs.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 70pt;text-indent: -12pt;line-height: 114%;text-align: left;"><span class="s13">1. </span>The most common setup is to have a directory named <span class="s33">bin </span>that’s under (a subdirectory of) your home directory. To make this subdirectory, go to your home directory first:</p><p class="s33" style="padding-top: 7pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>cd</b></p><p class="s33" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;">% <b>mkdir bin</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 70pt;text-indent: -12pt;line-height: 115%;text-align: left;"><span class="s13">2. </span>The first time you create your <span class="s33">bin </span>directory, you need to add it to the <span class="s33">PATH </span>variable so the shell will search it for programs. See the section “Startup Files, Login and Interactive Shells” in Chapter 5 for details on editing the correct shell startup file. Until you log in next, or start using new terminals, you’ll also need to change the <span class="s33">PATH </span>in all shells you’re running at the moment. Here are the commands to type for C-type and Bourne-type shells:</p><p class="s33" style="padding-top: 7pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">% <b>set path = ($path ~/bin)</b></p><p class="s33" style="padding-top: 1pt;padding-left: 79pt;text-indent: 0pt;text-align: left;">$ <b>PATH=$PATH:$HOME/bin</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 70pt;text-indent: 0pt;line-height: 115%;text-align: left;">(In Bourne shells, you may need to use <span class="s33">$LOGDIR </span>instead of <span class="s33">$HOME</span>. To check, type the command <span class="s33">echo $HOME</span>. If there’s no output, that variable may not be defined; in that case, try <span class="s33">echo $LOGDIR</span>.)</p><p style="padding-top: 6pt;padding-left: 58pt;text-indent: 0pt;text-align: left;"><span class="s13">3. </span>Change to your new <span class="s33">bin </span>directory by typing <span class="s33">cd bin</span>.</p><p style="padding-top: 8pt;padding-left: 70pt;text-indent: -12pt;line-height: 115%;text-align: left;"><span class="s13">4. </span>You can create any new scripts, from now on, in this directory. To move your existing script into your <span class="s33">bin</span>, use the Unix <span class="s33">mv </span>(move) program. An <span class="s33">mv </span>command line can have two arguments, or more than two arguments. If there are just two arguments, the first is the file’s current pathname and the last is the pathname you want the file to have after you move it; the last argument can also be the pathname of a directory. If there are more than two arguments, the last argument is the pathname of the directory where you want to move the files, and the first arguments are the pathnames of the files you want to move to that place. So if you created the script file in your home directory and you’re now in your <span class="s33">bin</span>, you could type <i>one </i>of the following commands:</p><p class="s46" style="padding-top: 6pt;padding-left: 70pt;text-indent: 0pt;text-align: left;"><span class="s33">$ </span>mv -i ../<i>scriptname </i>.</p><p class="s32" style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">-- or --</p><p class="s46" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;"><span class="s33">$  </span>mv  -i  $HOME/<i>scriptname  </i>.</p><p class="s32" style="padding-top: 1pt;padding-left: 88pt;text-indent: 0pt;text-align: left;">-- or --</p><p class="s46" style="padding-top: 1pt;padding-left: 70pt;text-indent: 0pt;text-align: left;"><span class="s33">$  </span>mv  -i  $HOME/<i>scriptname  </i>$HOME/bin</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark114"><span class="s27">50 </span></a>CHAPTER 2 <span class="s28">■ </span>USING SHELL FEATURES TOGETHER </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;line-height: 115%;text-align: left;">The first, using relative pathnames, is easiest to type, of course, but you have to know where the script file is now. (The <span class="s33">.. </span>and <span class="s33">. </span>are explained at the section “Relative Pathnames and Your Current Directory” in Chapter 1.) Your shell may also understand a tilde (<span class="s33">~</span>) instead of <span class="s33">$HOME</span>, as in</p><p class="s46" style="padding-top: 7pt;padding-left: 72pt;text-indent: 0pt;text-align: left;"><span class="s33">$ </span>mv -i ~/<i>scriptname </i>.</p><p class="s32" style="padding-top: 1pt;padding-left: 90pt;text-indent: 0pt;text-align: left;">-- or --</p><p class="s46" style="padding-top: 1pt;padding-left: 72pt;text-indent: 0pt;text-align: left;"><span class="s33">$ </span>mv -i ~/<i>scriptname </i>~/bin</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 72pt;text-indent: 0pt;text-align: left;">The <span class="s33">-i </span>option makes <span class="s33">mv </span>ask before it overwrites (replaces) any destination file.</p><p style="padding-top: 8pt;padding-left: 72pt;text-indent: -12pt;line-height: 114%;text-align: left;"><span class="s13">5. </span>If you use a C shell, you may need to type the command <span class="s33">rehash </span>once. This tells the shell to search its <span class="s33">PATH </span>and rebuild its program lookup table (called a <i>hash table</i>, which is a special kind of table designed to be searched quickly).</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Now, if all’s well, you can change to any directory and type the program name at a shell prompt, and it should run.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><span><img width="507" height="432" alt="image" src="Image_081.png"/></span></p><p class="s40" style="padding-top: 11pt;padding-left: 135pt;text-indent: 0pt;text-align: left;">MAKING ERROR AND PROGRESS MESSAGES</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: left;">Unix utility programs run from the command line usually don’t output status messages to tell you what they’re doing. They simply do the job. Their only output is text, written to the standard output.</p><p class="s33" style="padding-left: 51pt;text-indent: 0pt;line-height: 115%;text-align: justify;">Part of the reason for this is that, as we explained earlier, you can redirect a program’s output to a file or pipe it to another program. If status messages were written to the standard output, along with the good data, you might not see the messages and/or the messages could mix with the data you want to save.</p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">Still, status messages can be useful in long-running programs. There are two important things to know about making a status message or an error message:</p><p class="s13" style="padding-top: 6pt;padding-left: 67pt;text-indent: -6pt;line-height: 114%;text-align: left;">1. <span class="s33">The message should start with the program’s name. This is very helpful when you’re using a pipeline with several programs because you can tell which of those programs the message comes from.</span></p><p class="s13" style="padding-top: 6pt;padding-left: 60pt;text-indent: 0pt;line-height: 115%;text-align: justify;">2. <span class="s33">The message should be written on the standard error. To do this in Bourne-type shells, use echo and add the shell operator 1&gt;&amp;2 to the end of the command line. This redirects the standard output (which is file descriptor number 1) onto the standard error (which is file descriptor number 2). There’s no easy way to do this under tcsh and csh, which is another reason programmers often prefer Bourne shells.</span></p><p class="s33" style="padding-left: 50pt;text-indent: 0pt;line-height: 10pt;text-align: left;">So the following command line would output an error message:</p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;text-align: left;">echo &quot;make_proglist: blah blah blah&quot; 1&gt;&amp;2</p><p class="s33" style="padding-top: 8pt;padding-left: 50pt;text-indent: 0pt;line-height: 115%;text-align: left;">Because you might rename the make_proglist program some day, it’s better to store the program name in a shell variable at the start of the file—where you’re more likely to see it—like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 50pt;text-indent: 0pt;text-align: justify;">myname=make_proglist</p><p class="s33" style="padding-top: 1pt;padding-left: 68pt;text-indent: 0pt;text-align: left;">...</p><p class="s33" style="padding-top: 1pt;padding-left: 50pt;text-indent: 0pt;text-align: justify;">echo  &quot;$myname:  blah  blah  blah&quot;  1&gt;&amp;2</p><p style="text-indent: 0pt;text-align: left;"><span><img width="35" height="169" alt="image" src="Image_082.png"/></span></p><p class="s29" style="padding-top: 3pt;padding-left: 224pt;text-indent: 0pt;text-align: left;"><a name="bookmark115">CHAPTER 2 </a><span class="s28">■ </span>USING SHELL FEATURES TOGETHER <span class="s27">51</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: justify;">(Even better, have the program find its own name. You can get it from the shell parameter $0. Using command substitution, let’s capture the output of the Unix basename program, which will remove any pathname from the front of the program’s filename:</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">myname=`basename $0`</p><p class="s33" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">...</p><p class="s33" style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">echo &quot;$myname: blah blah blah&quot; 1&gt;&amp;2</p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: left;">That’s also handy for another reason: a single file can actually have multiple names—so a program can do multiple things by testing its name, which we’ve stored in the variable myname.)</p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: justify;">(Even better, have the program find its own name. You can get it from the shell parameter $0. Using command substitution, let’s capture the output of the Unix basename program, which will remove any pathname from the front of the program’s filename:</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">myname=`basename $0`</p><p class="s33" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">...</p><p class="s33" style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">echo &quot;$myname: blah blah blah&quot; 1&gt;&amp;2</p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: left;">That’s also handy for another reason: a single file can actually have multiple names—so a program can do multiple things by testing its name, which we’ve stored in the variable myname.)</p><p style="padding-left: 76pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: justify;">(Even better, have the program find its own name. You can get it from the shell parameter $0. Using command substitution, let’s capture the output of the Unix basename program, which will remove any pathname from the front of the program’s filename:</p><p class="s33" style="padding-top: 7pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">myname=`basename $0`</p><p class="s33" style="padding-top: 1pt;padding-left: 25pt;text-indent: 0pt;text-align: left;">...</p><p class="s33" style="padding-top: 1pt;padding-left: 8pt;text-indent: 0pt;text-align: left;">echo &quot;$myname: blah blah blah&quot; 1&gt;&amp;2</p><p class="s33" style="padding-top: 8pt;padding-left: 8pt;text-indent: 0pt;line-height: 115%;text-align: left;">That’s also handy for another reason: a single file can actually have multiple names—so a program can do multiple things by testing its name, which we’ve stored in the variable myname.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part54.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part56.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
