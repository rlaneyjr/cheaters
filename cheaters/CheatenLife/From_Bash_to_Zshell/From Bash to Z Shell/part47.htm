<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Joining Forces</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part46.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part48.htm">Next &gt;</a></p><h4 style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark81">Joining Forces</a></h4><p style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">Let’s start to make a much more useful <span class="s33">proglist </span>file, step by step. The first step is to use <span class="s33">grep </span>to remove the lines of <span class="s33">ls </span>output that aren’t program names. The <span class="s33">-v </span>option tells <span class="s33">grep </span>to output all lines that don’t match the pattern. To get a list of the program names only, we want to remove the lines with the directory names—which, in this case, both end with the string <span class="s33">/bin:</span>. So let’s overwrite the old <span class="s33">proglist </span>file with a new one, piping the standard output of <span class="s33">ls </span>to the standard input of <span class="s33">grep</span>, and redirecting the standard output of <span class="s33">grep </span>to the <span class="s33">proglist </span>file. (If you haven’t seen many shell command lines before, this one may look complicated. Think of it in pieces: two programs, each with its own arguments, connected by a pipe.) Before you start to type this, remember that you can probably use command-line editing to recall a previous <span class="s33">ls </span>command line, then insert the pipe symbol and the <span class="s33">grep </span>before the <span class="s33">&gt; </span>character:</p><p class="s33" style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$  <b>ls  /bin  /usr/bin  |  grep  -v  &#39;/bin:$&#39;  &gt;  proglist</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">$  <b>less  proglist</b></p><p class="s33" style="padding-top: 1pt;padding-left: 46pt;text-indent: 0pt;text-align: left;">...</p><p class="s29" style="padding-top: 3pt;padding-left: 224pt;text-indent: 0pt;text-align: left;"><a name="bookmark99">CHAPTER 2 </a><span class="s28">■ </span>USING SHELL FEATURES TOGETHER <span class="s27">35</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Look through the file with your favorite pager—<span class="s33">less </span>or <span class="s33">more</span>, for instance. The lines <span class="s33">/bin: </span>and <span class="s33">/usr/bin: </span>should be gone (because <span class="s33">grep </span>“ate” them and output the other lines). But there’s still an empty line between the directory listings. We can remove it too. One way to do that is by piping the output of the first <span class="s33">grep </span>to another <span class="s33">grep</span>—this one with the pattern <span class="s33">^$</span>, which matches empty lines, and the option <span class="s33">-v </span>to omit those lines. Alternatively, you may be able to use a single invocation of <span class="s33">grep </span>if your <span class="s33">grep </span>accepts multiple patterns, each preceded by the option <span class="s33">-e</span>. (You could also use <span class="s33">egrep</span>—“extended <span class="s33">grep</span>”—which always allows multiple patterns.) Here goes:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$  <b>ls  /bin  /usr/bin  |  grep  -v  &#39;/bin:$&#39;  |  grep  -v  &#39;^$&#39;  &gt;  proglist</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Let’s review. The <span class="s33">ls </span>process is writing a listing of two directories to its standard output. A pipe sends that text to the standard input of the first <span class="s33">grep -v</span>, which removes the lines with the directory names <span class="s33">/bin: </span>and <span class="s33">/usr/bin:</span>. A second <span class="s33">grep -v </span>removes the blank line. Now <span class="s33">proglist </span>has a list of the programs. (Check the <span class="s33">proglist </span>file, if you want, with <span class="s33">less proglist</span>.)</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_065.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 40pt;text-indent: 0pt;line-height: 111%;text-align: justify;">■<span class="s23">Warning </span><span class="s19">Don’t try to read a file early in a command line, then use redirection to write a modified version of the same file back to itself, like this:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">$ <i>xyz </i><b>proglist | ... &gt; proglist</b></p><p class="s19" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;line-height: 113%;text-align: justify;">Why can’t you do that? <i>Before </i>the shell runs the command line, it <i>empties </i>(removes all of the data from) the file you’ve redirected output to. (Here, that’s the proglist file.) What can you do instead? Write output to a temporary file, then overwrite the original file with it: <span class="s54">1</span></p><p class="s33" style="padding-top: 7pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">$ <i>xyz </i><b>proglist | ... &gt; temp</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 4pt;padding-left: 52pt;text-indent: 0pt;text-align: left;">$ <b>cat temp &gt; proglist</b></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_066.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Our program list still isn’t optimal: all of the programs from <span class="s33">/bin </span>are listed before the programs from <span class="s33">/usr/bin</span>. So let’s sort the listing before writing it to the file. The Unix <span class="s33">sort </span>program reads files or standard input, then sorts it into, by default, alphabetical order. How can we add <span class="s33">sort</span>? It’s simple: pipe the output of the second <span class="s33">grep </span>into <span class="s33">sort</span>. Recall the previous command line and edit it:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">$  <b>ls  /bin  /usr/bin  |  grep  -v  &#39;/bin:$&#39;  |  grep  -v  &#39;^$&#39;  |  sort  &gt;  proglist</b></p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">That example might seem a bit tedious. “After all,” you might say, “couldn’t I do that with a text editor?” You could do some of it with a text editor—what the <span class="s33">grep -v </span>processes are doing, at least—but the sorting could be more difficult. Anyway, this is meant more to demonstrate piping and redirection than as a rule that pipelines are “the only way” to do things with a shell. Shells give you the choice of lots of tools—so, if the best tool is a text editor, just use it!</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="226" height="1" alt="image" src="Image_067.png"/></span></p><p class="s14" style="padding-top: 5pt;padding-left: 52pt;text-indent: -12pt;line-height: 108%;text-align: justify;">1. You can also use the <span class="s29">mv </span>command to replace <span class="s29">proglist </span>with <span class="s29">temp</span>. This may break any hard links to the destination file (<span class="s29">proglist</span>), though. Redirection, as we’ve shown here, doesn’t break hard links. There’s more about hard links in the section “Hard Links” in Chapter 8.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark100"><span class="s27">36 </span></a>CHAPTER 2 <span class="s28">■ </span>USING SHELL FEATURES TOGETHER </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part46.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part48.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
