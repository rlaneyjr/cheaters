<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>zsh Example</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part397.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part399.htm">Next &gt;</a></p><p class="s35" style="padding-left: 42pt;text-indent: 0pt;text-align: left;"><a name="bookmark750">zsh Example</a></p><p style="padding-top: 5pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">As you’ll see, the equivalent <span class="s33">zsh </span>function is no more complicated than the preceding <span class="s33">bash </span>example. Where it does become more complicated in <span class="s33">zsh </span>is when we make use of powerful extra features that are lacking in <span class="s33">bash</span>.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">The first difference is that <span class="s33">zsh </span>uses different names for the special variables. Table 15-1 offers the <span class="s33">zsh </span>equivalents for the <span class="s33">bash </span>special variables, but all the variables used for ordinary <span class="s33">zle </span>widgets are also valid (see the section “Special Variables in zle” in Chapter 14) along with a number of variables for handling prefixes and suffixes (listed in Table 15-3). There is also a <span class="s33">compstate </span>associative array containing further information. The basic outline of the function looks very similar to that for <span class="s33">bash</span>:</p><p class="s33" style="padding-top: 6pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">_chown()  {</p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">if  ((  CURRENT  ==  2  ));  then</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">#  <i>complete  users[.groups]</i></p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">else</p><p class="s33" style="padding-top: 1pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">#  <i>complete  filenames</i></p><p class="s33" style="padding-top: 1pt;padding-left: 51pt;text-indent: 0pt;text-align: left;">fi</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 8pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">Note that because <span class="s33">zsh </span>indexes arrays from one instead of zero, words on the command</p><p style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">line are also counted from one. So there is a slight difference from <span class="s33">bash </span>in that regard.</p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Completing filenames is a simple matter of calling the <span class="s33">_files </span>function. It handles every- thing to do with filename completion for you. Later on, we will show you the direct way to add matches without relying on preexisting functions, but for this function, let’s keep matters simple and just use <span class="s33">_files</span>.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">In <span class="s33">zsh</span>, we have complete control over what parts of the current word are considered for completion and what parts are ignored. So if we want to complete groups ignoring everything preceding the colon or dot in the current word, we can do that. The <span class="s33">compset </span>command allows you to specify parts of the current word to be ignored for the purposes of completion. We want to ignore everything in the word up to the first dot. The command to do this is <span class="s33">compset -P &#39;*.&#39;</span>. The <span class="s33">-P </span>option specifies a prefix to be ignored. Its return status indicates whether or not it was able the remove the specified pattern. So for completing users and groups, we can do this:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">if  compset  -P  &#39;*.&#39;;  then</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 9pt;line-height: 115%;text-align: left;">_groups else</p><p class="s33" style="padding-left: 41pt;text-indent: 9pt;line-height: 115%;text-align: left;">_users fi</p><p style="padding-top: 7pt;padding-left: 42pt;text-indent: 17pt;line-height: 115%;text-align: left;">As you can see, completing usernames or groups is simply a matter of calling the existing functions. We now have a function for <span class="s33">zsh </span>that works at least as well as the <span class="s33">bash </span>example.</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">However, there are still other things we can do to improve it. First, <span class="s33">zsh </span>does not have <span class="s33">bash</span>’s limitations with respect to colons, so we can handle colons by changing the pattern to <span class="s33">&#39;*[.:]&#39;</span>. Next we want to add a suffix after completing users. <span class="s33">zsh </span>handles this in a similar way to <span class="s33">bash</span>:</p><p class="s29" style="padding-top: 3pt;padding-left: 223pt;text-indent: 0pt;text-align: left;"><a name="bookmark790">CHAPTER 15 </a><span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S <span class="s27">379</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">we just pass the option <span class="s33">-S &#39;.&#39; </span>to <span class="s33">_users</span>. There are many common options like this that you can pass to other completion functions.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">You may remember from the section “Prefix Completion” in Chapter 10 that with the <span class="s33">complete_in_word </span>option set, <span class="s33">zsh </span>looks at the word on both sides of the cursor when deciding what matches. For this to work properly, we want it to ignore anything after a dot when completing usernames. This way, if you go back to edit the username, you can use completion and the group is ignored. To specify a suffix to be ignored when completion does matching, <span class="s33">compset </span>supports an <span class="s33">-S </span>option similar to <span class="s33">-P</span>. So before calling <span class="s33">_users</span>, we will run <span class="s33">compset  -S  &#39;[.:]*&#39;</span>. In addition, we need to make the dot suffix when completing usernames conditional on whether this removed a suffix: if a dot is already there, we don’t want to add another one. Our final function looks like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">_chown() {</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">if (( CURRENT == 2 )); then</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">if  compset  -P  &#39;*[.:]&#39;;  then</p><p class="s33" style="padding-top: 1pt;padding-left: 58pt;text-indent: 9pt;line-height: 115%;text-align: left;">_groups else</p><p class="s33" style="padding-left: 67pt;text-indent: 0pt;line-height: 10pt;text-align: left;">if compset -S &#39;[.:]*&#39;; then</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 9pt;line-height: 115%;text-align: left;">_users else</p><p class="s33" style="padding-left: 76pt;text-indent: 0pt;line-height: 10pt;text-align: left;">_users -S &#39;.&#39;</p><p class="s33" style="padding-top: 1pt;padding-left: 67pt;text-indent: 0pt;text-align: left;">fi</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 8pt;line-height: 115%;text-align: left;">fi else</p><p class="s33" style="padding-left: 58pt;text-indent: 0pt;line-height: 10pt;text-align: left;">_files</p><p class="s33" style="padding-top: 1pt;padding-left: 49pt;text-indent: 0pt;text-align: left;">fi</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">}</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">There is a further essential step we need to take before we can use this function: we must</p><p style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">associate the function with the command whose arguments it completes. We have already seen how to do this: either run <span class="s33">compdef _chown chown </span>or make the function autoloadable and put a special tag on its first line:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">#compdef chown</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">You might want to have a look now at the completion functions for <span class="s33">chown </span>that come with <span class="s33">zsh </span>and bash_completion. They do a number of more complicated things. The <span class="s33">bash </span>function handles colons and completes options for GNU <span class="s33">chown</span>. The <span class="s33">zsh </span>function is even clever enough to restrict the completed files to those for which the <span class="s33">chown </span>command would make sense. So if you complete after <span class="s33">chown root</span>, any files that are already owned by root will not be completed. You will also see that the same function additionally handles <span class="s33">chgrp</span>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Another thing you may notice in the completion function <span class="s33">zsh </span>includes for <span class="s33">chown </span>is that it assumes some things about its environment. In particular, it relies on the <span class="s33">extended_glob </span>option for some of the patterns used. This is possible because the completion system sets up some aspects of the environment. The list of options it sets are listed in the <span class="s33">_comp_options </span>variable. These won’t otherwise affect your interactive environment because the options are only set locally using <span class="s33">local_options </span>as we described in the section “Porting Scripts” in Chapter 13.</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark791"><span class="s27">380 </span></a>CHAPTER 15 <span class="s28">■ </span>W RIT ING COMP LET ION F UNCTI ON S</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part397.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part399.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
