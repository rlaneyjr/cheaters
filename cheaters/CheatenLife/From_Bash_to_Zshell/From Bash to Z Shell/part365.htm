<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Restricting the List of Files Generated</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part364.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part366.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark657">Restricting the List of Files Generated</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">The majority of glob qualifiers restrict the list of files generated to only certain types of files. For example, <span class="s33">/ </span>causes only directories to be generated. We’ll start by showing you how to apply your own restriction on the filenames generated.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">The syntax for including shell code in a list of glob qualifiers involves first specifying the letter <span class="s33">e </span>(for evaluate). The <span class="s33">e </span>is followed by a delimited string to specify the shell code to be eval- uated. The rules for this were showed for other qualifiers in the section “More Complicated Qualifiers: String Arguments” in Chapter 9. The shell code is run for each filename with the <span class="s33">REPLY </span>variable set each time to the filename in question. The return status of the shell code then determines whether the filename is to be generated.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s see an example. Suppose that you want to know which files in the current directory also exist (or don’t exist) in another directory. The conventional way to do this is to write a <span class="s33">for </span>loop:</p><p class="s33" style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">for f in *; do</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 9pt;line-height: 115%;text-align: left;">[[ -e /other/directory/$f ]] &amp;&amp; print $f done</p><p style="padding-top: 7pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">With the <span class="s33">(e) </span>glob qualifier, the equivalent would be</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">print -l *(e:&#39;[[ -e /other/directory/$REPLY ]]&#39;:)</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">In addition to being shorter, this has the advantage that you can use it as an argument to any command. To pass all the files together to a command, you would otherwise need to make the script more complicated or use <span class="s33">xargs </span>as we described in the section “Running find in a Pipeline” in Chapter 8.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Quoting can become a little awkward. In the example above, it was necessary to add quotes to preserve the “$” symbol. For this reason, it is a good idea to define short functions for any such pieces of shell code that you use frequently:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">in() { [[ -e $1/$REPLY ]] }</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">Now, we need only write</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">print -l *(e:in /other/directory:)</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">With these functions, it is common to want to negate their effect. In this case, we might want files that are <i>not </i>in the other directory. You actually have two options in this case. You can either use an exclamation mark before the command to negate its return status: <span class="s33">*(e:! in / other/directory:) </span>or you can use the “^” glob qualifier, which negates the meaning of any following qualifiers: <span class="s33">*(^e:in /other/directory:)</span>.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">You might need to be a little careful about this, though. If, for example, your function only works for directories and you include a test for whether <span class="s33">$REPLY </span>is a directory in the function,</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark696"><span class="s27">340 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">then the negation also applies to this test, which won’t be useful. A good demonstration of this is the following function, which checks for empty directories:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">empty() { [ -z $REPLY/*(DN[1]) ] }</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_275.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 117%;text-align: left;">■<span class="s23">Tip </span><span class="s19">The empty function presented in this section demonstrates an unrelated but useful trick. By using the old single bracket ([  ...  ]) condition test instead of the new double bracket one ([[  ...  ]]), we allow filename generation to apply. The “D” qualifier here forces any dot files to be included, “N” allows it to return nothing instead of a “no matches found”, error and “[1]” causes it to only expand one filename. This allows us to test whether a particular glob pattern generates any files.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_276.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 6pt;padding-left: 60pt;text-indent: 0pt;text-align: left;">Create a new empty directory or two and try this out:</p><p class="s33" style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>mkdir empty</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>print *(e:empty:)</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>print *(^e:empty:)</b></p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">In the first of the two lists, all the files in the current directory will be listed. Unfortunately, from within the function, there is no way to prevent ordinary files from getting into one or other of the lists. You just have to remember to use the slash glob qualifier with the function:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>print *(/e:empty:)</b></p><p style="padding-top: 8pt;padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">In <span class="s33">zsh </span>4.2.1, an <span class="s33">F </span>glob qualifier has been added for finding nonempty (full) directories. This issue also applies with it: it needs to be combined with the <span class="s33">/ </span>qualifier if negated unless you want the names of regular files to be generated.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part364.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part366.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
