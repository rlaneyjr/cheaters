<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Basic Globbing</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part217.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part219.htm">Next &gt;</a></p><h4 style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark408">Basic Globbing</a></h4><p style="padding-top: 6pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: justify;">A character or set of characters that have a special meaning in a filename is sometimes called an <i>operator </i>(though other names are used). We’ll meet quite a few operators during the chapter; some of them are only available in one shell or another. Nearly all Unix-style shells support the</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s27" style="padding-left: 39pt;text-indent: 0pt;text-align: right;">197</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark447"><span class="s27">198 </span></a>C HA P T E R 9 <span class="s28">■ </span>P A T T ER N M A T C H I N G</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">simple operators. We summarize them in Table 9-1. Although they are generally available, you need to keep a lookout for subtleties. For example, later we’ll see that there are occasions when</p><p class="s33" style="padding-left: 42pt;text-indent: 0pt;line-height: 10pt;text-align: left;">* <span class="p">doesn’t actually match all characters.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s13" style="padding-bottom: 4pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">Table 9-1. <span class="s32">Common Globbing Operators</span></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="476" height="1" alt="image" src="Image_185.png"/></span></p><p class="s48" style="padding-bottom: 2pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">Operator Meaning</p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="476" height="1" alt="image" src="Image_186.png"/></span></p><p class="s51" style="padding-top: 3pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">* Zero or more characters</p><p class="s51" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">? Any single character</p><p class="s61" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">[abc]                                       <span class="s51">Any of the characters </span>a<span class="s51">, </span>b<span class="s51">, or </span>c</p><p class="s61" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">[a-z]                                       <span class="s51">Any character that lies between </span>a <span class="s51">and </span>z</p><p class="s61" style="padding-top: 6pt;padding-bottom: 4pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">[^a-z] <span class="s51">or </span>[!a-z]                     <span class="s51">Any character other than one that lies between </span>a <span class="s51">and </span>z</p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="476" height="1" alt="image" src="Image_187.png"/></span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-top: 5pt;padding-left: 42pt;text-indent: 17pt;line-height: 115%;text-align: left;">You need to remember it’s the shell that expands patterns—not the program that runs with the file arguments. The shell passes down the expanded filenames, so the program itself never sees the patterns. (If your shell is running under Cygwin and you execute a native Windows command, the program may try to expand patterns in filenames after the shell has finished its own expansions.)</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The most basic pattern character is <span class="s33">*</span>. We’ll refer to it as a “star” in this chapter. It matches any number of characters, including none—in other words, <span class="s33">file* </span>matches anything beginning with those four characters, including just <span class="s33">file</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">%  <b>ls</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">File    Makefile    file    file.c    file.txt</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">% <b>echo *</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">File  Makefile  file  file.c  file.txt</p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">%  <b>echo  file*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">file  file.c  file.txt</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Note that any letter given explicitly, like the <span class="s33">f </span>in <span class="s33">file*</span>, is matched exactly, as long as it’s not part of an operator. Even the case of letters is important. <span class="s33">bash </span>has an option, <span class="s33">nocaseglob</span>, which if turned on makes the matching case insensitive. This is very useful for Cygwin, where the filesystem is case insensitive. For example, on Cygwin the names <span class="s33">File </span>and <span class="s33">file </span>refer to the same file (only one of the two could have appeared in the listings of the previous example).</p><p style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">So the commands <span class="s33">less  file </span>and <span class="s33">less  File </span>have the same effect. It is therefore useful to have <span class="s33">file* </span>match the name <span class="s33">File </span>as well as <span class="s33">file</span>. <span class="s33">zsh </span>4.2 and greater also has the option <span class="s33">no_case_glob</span>. If you are using an older version of <span class="s33">zsh</span>, you can make a particular pattern case insensitive by using one of the <i>globbing flags</i>. We’ll meet these when we talk about extended globbing in the section “Extended Globbing,” later in this chapter.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">Even those simple rules have consequences you may not immediately realize, particularly if you grew up with patterns in DOS or in a Windows Command Prompt window. We’ve discussed some simple differences in the sidebar “Differences from the DOS Command Prompt.”</p><p class="s40" style="padding-top: 3pt;padding-left: 80pt;text-indent: 0pt;text-align: left;">DIFFERENCES FROM THE DOS COMMAND PROMPT</p><p class="s40" style="padding-top: 3pt;padding-left: 80pt;text-indent: 0pt;text-align: left;">DIFFERENCES FROM THE DOS COMMAND PROMPT</p><p style="text-indent: 0pt;text-align: left;"/><p class="s40" style="padding-top: 3pt;padding-left: 80pt;text-indent: 0pt;text-align: left;">DIFFERENCES FROM THE DOS COMMAND PROMPT</p><p class="s29" style="padding-top: 3pt;padding-left: 280pt;text-indent: 0pt;text-align: left;"><a name="bookmark448">CHAPTER 9 </a><span class="s28">■ </span>PATTER N MATCHIN G <span class="s27">199</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">If you have experience using the DOS (or Windows) shell, you will find that under Unix even simple patterns like * behave a little differently. Here are a couple of things to notice.</p><p class="s13" style="padding-top: 6pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">1. <span class="s33">DOS users often attempt to rename a group of files in one go using syntax like this:</span></p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">mv *.c *.bak</p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;line-height: 115%;text-align: left;">Unix shells will not allow this, because the shell expands <i>both </i>of those stars straight away, or tries to. When it’s done that, the mv command receives arguments that look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">mv prog.c utils.c oldprog.bak mydata.bak</p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;line-height: 115%;text-align: left;">As you can see, the arguments consist of all possible expansions. As a result, mv will complain and do nothing. That’s because if mv has more than two arguments, the last must be a directory.</p><p class="s13" style="padding-top: 4pt;padding-left: 31pt;text-indent: -11pt;line-height: 114%;text-align: left;">2. <span class="s33">Unix shells recognize a single star as any character in a filename. In DOS, it doesn’t match a dot; you need *.* to match both the filename and the extension. Under Unix, you can just use * to match both unless you’re looking specifically for those files that contain a dot in the filename.</span></p><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">If you have experience using the DOS (or Windows) shell, you will find that under Unix even simple patterns like * behave a little differently. Here are a couple of things to notice.</p><p class="s13" style="padding-top: 6pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">1. <span class="s33">DOS users often attempt to rename a group of files in one go using syntax like this:</span></p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">mv *.c *.bak</p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;line-height: 115%;text-align: left;">Unix shells will not allow this, because the shell expands <i>both </i>of those stars straight away, or tries to. When it’s done that, the mv command receives arguments that look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">mv prog.c utils.c oldprog.bak mydata.bak</p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;line-height: 115%;text-align: left;">As you can see, the arguments consist of all possible expansions. As a result, mv will complain and do nothing. That’s because if mv has more than two arguments, the last must be a directory.</p><p class="s13" style="padding-top: 4pt;padding-left: 31pt;text-indent: -11pt;line-height: 114%;text-align: left;">2. <span class="s33">Unix shells recognize a single star as any character in a filename. In DOS, it doesn’t match a dot; you need *.* to match both the filename and the extension. Under Unix, you can just use * to match both unless you’re looking specifically for those files that contain a dot in the filename.</span></p><p style="padding-left: 39pt;text-indent: 0pt;text-align: left;"/><p class="s33" style="padding-top: 6pt;padding-left: 9pt;text-indent: 0pt;line-height: 115%;text-align: left;">If you have experience using the DOS (or Windows) shell, you will find that under Unix even simple patterns like * behave a little differently. Here are a couple of things to notice.</p><p class="s13" style="padding-top: 6pt;padding-left: 19pt;text-indent: 0pt;text-align: left;">1. <span class="s33">DOS users often attempt to rename a group of files in one go using syntax like this:</span></p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">mv *.c *.bak</p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;line-height: 115%;text-align: left;">Unix shells will not allow this, because the shell expands <i>both </i>of those stars straight away, or tries to. When it’s done that, the mv command receives arguments that look like this:</p><p class="s33" style="padding-top: 7pt;padding-left: 31pt;text-indent: 0pt;text-align: left;">mv prog.c utils.c oldprog.bak mydata.bak</p><p class="s33" style="padding-top: 8pt;padding-left: 31pt;text-indent: 0pt;line-height: 115%;text-align: left;">As you can see, the arguments consist of all possible expansions. As a result, mv will complain and do nothing. That’s because if mv has more than two arguments, the last must be a directory.</p><p class="s13" style="padding-top: 4pt;padding-left: 31pt;text-indent: -11pt;line-height: 114%;text-align: left;">2. <span class="s33">Unix shells recognize a single star as any character in a filename. In DOS, it doesn’t match a dot; you need *.* to match both the filename and the extension. Under Unix, you can just use * to match both unless you’re looking specifically for those files that contain a dot in the filename.</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: justify;">There is one important exception to the “star matches everything” rule: it doesn’t match a dot at the start of a filename. There is a conspiracy between the shells and the <span class="s33">ls </span>command to keep files beginning with a dot out of your way; the shell won’t match such files with wildcards, and <span class="s33">ls </span>won’t show them.</p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">Here is a simple example. We’ve used <span class="s33">ls -a </span>(for “all”) to show the complete list of files, including those beginning with a dot:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">%  <b>ls  -a</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">. .. .mozilla .zlogin .zprofile .zshrc Mail msg.txt</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">However, if we use <span class="s33">* </span>to match all the files, the ones beginning with a dot won’t appear:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo *</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">Mail  msg.txt</p><p style="padding-top: 8pt;padding-left: 58pt;text-indent: 0pt;text-align: left;">Whenever you specify the first character, the <span class="s33">* </span>can match anything else. This may be a letter:</p><p class="s33" style="padding-top: 8pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo m*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">msg.txt</p><p style="padding-top: 8pt;padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">However, you may also specify that a dot is the first character. Then the shell will match those files that were hidden before. The two examples below show any file beginning with <span class="s33">.z</span>, and any file beginning with a dot and containing an <span class="s33">l</span>:</p><p class="s33" style="padding-top: 7pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo .z*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">.zlogin .zprofile .zshrc</p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">% <b>echo .*l*</b></p><p class="s33" style="padding-top: 1pt;padding-left: 40pt;text-indent: 0pt;text-align: left;">.mozilla .zlogin .zprofile</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark449"><span class="s27">200 </span></a>CHAPTER 9 <span class="s28">■ </span>PATTER N MATCHING </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Under Unix, these are the <i>only </i>places where a leading dot is special—apart from programs such as graphical file browsers, which mimic the way <span class="s33">ls </span>lists files. The underlying filesystem doesn’t care at all. It only cares about the two special files: <span class="s33">. </span>(a single dot), which refers to the current directory, and <span class="s33">.. </span>(two dots), which refers to the parent directory. Any other files beginning with a dot behave like any other file. (If you’re using the shell under Cygwin, things are more complicated, because there are more special characters.)</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">You can make the shells expand files beginning with a dot in patterns, however. In <span class="s33">bash</span>, you need <span class="s33">shopt -s dotglob </span>and in <span class="s33">zsh</span>, <span class="s33">setopt globdots</span>. We recommend you that you don’t do that, except in functions where you only set it for a short time and make sure it is unset at the end; it can have very nasty effects when combined with <span class="s33">rm</span>. This can happen if you run <span class="s33">ls </span>to see what files are in a directory, then <span class="s33">rm * </span>to remove all those files. The <span class="s33">ls </span>command wouldn’t show you files beginning with a dot. However, with the <span class="s33">dotglob </span>(<span class="s33">bash</span>) or <span class="s33">globdots </span>(<span class="s33">zsh</span>) option set, the shell does generate such filenames. Then the <span class="s33">rm </span>command deletes the files that you didn’t even know were there. Since files beginning with a dot are often used for special purposes, such as the shell’s own startup files, this is definitely a bad thing.</p><p class="s33" style="padding-left: 41pt;text-indent: 17pt;line-height: 115%;text-align: left;">zsh <span class="p">never matches the special files </span>. <span class="p">and </span>.. <span class="p">as patterns, though you can type them explicitly, of course. The shell assumes—and it’s nearly always correct—that if you want to refer to the current or parent directory you will say so explicitly. </span>bash <span class="p">is a little less consistent: if you use </span>.* <span class="p">to match leading dots, it will show you both those files, but if you set the option </span>dotglob <span class="p">and use</span></p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: justify;">*<span class="p">, it won’t. The following example shows that happening. First we show all files, then we set the </span>dotglob <span class="p">option and use </span>* <span class="p">to generate filenames, then we use </span>.* <span class="p">to show all files beginning with a dot. You can see that in the second case the two files </span>. <span class="p">and </span>.. <span class="p">are missing, but they are present in the first and third cases:</span></p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">bash$ <b>ls -a</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">. .. Mail .mozilla msg.txt .zlogin .zprofile .zshrc bash$ <b>echo *</b></p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 115%;text-align: left;">Mail  .mozilla  msg.txt  .zlogin  .zprofile  .zshrc bash$  <b>echo  .*</b></p><p class="s33" style="padding-left: 41pt;text-indent: 0pt;line-height: 10pt;text-align: justify;">. .. .mozilla .zlogin .zprofile .zshrc</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="507" height="1" alt="image" src="Image_188.png"/></span></p><p class="s21" style="padding-top: 4pt;padding-left: 41pt;text-indent: 0pt;line-height: 114%;text-align: left;">■<span class="s23">Tip </span><span class="s19">In zsh, you can make a single pattern match dots at the start of the filename. This is usually more useful than making all patterns match dots. The following shows all files, including those beginning with a dot, which contain an l:</span></p><p class="s33" style="padding-top: 7pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">zsh% <b>echo *l*(D)</b></p><p class="s33" style="padding-top: 1pt;padding-left: 42pt;text-indent: 0pt;text-align: left;">.mozilla    .zlogin    .zprofile    Mail</p><p class="s19" style="padding-top: 8pt;padding-left: 42pt;text-indent: 0pt;line-height: 119%;text-align: left;">That “(D)” is one of a set of <i>glob qualifiers </i>we’ll meet in the section “Glob Qualifiers in zsh,” later in this chapter.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 1pt;text-align: left;"><span><img width="504" height="1" alt="image" src="Image_189.png"/></span></p><p class="s29" style="padding-top: 3pt;padding-left: 280pt;text-indent: 0pt;text-align: left;"><a name="bookmark450">CHAPTER 9 </a><span class="s28">■ </span>PATTER N MATCHIN G <span class="s27">201</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="toc">&nbsp;</p><div class="toc"><a class="toc0" href="part219.htm">Matching a Single Character</a><a class="toc0" href="part220.htm">Matching a Restricted Range of Characters</a><a class="toc1" href="part221.htm">Picking the Right Range of Characters</a><a class="toc0" href="part222.htm">Quoting Pattern Characters</a></div><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part217.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part219.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
