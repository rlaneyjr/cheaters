<!DOCTYPE  html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Autoloadable Functions</title><link href="navigation.css" rel="stylesheet" type="text/css"/><link href="document.css" rel="stylesheet" type="text/css"/></head><body><p class="top_nav"><a href="part358.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part360.htm">Next &gt;</a></p><p class="s35" style="padding-left: 40pt;text-indent: 0pt;text-align: left;"><a name="bookmark651">Autoloadable Functions</a></p><p style="padding-top: 5pt;padding-left: 40pt;text-indent: 0pt;line-height: 115%;text-align: left;">We mentioned that the process of loading many shell functions into memory each time the shell starts can be time consuming. Exporting functions in the environment as <span class="s33">bash </span>allows</p><p class="s29" style="padding-top: 3pt;padding-left: 6pt;text-indent: 0pt;text-align: left;"><a name="bookmark690"><span class="s27">334 </span></a>CHAPTER 13 <span class="s28">■ </span>SCRIPTIN G AND FUN CTIONS </p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 42pt;text-indent: 0pt;line-height: 115%;text-align: left;">wastes memory if you have a lot of functions, and it still doesn’t solve the problem of having the definitions of many functions cluttered together in one startup file.</p><p style="padding-left: 42pt;text-indent: 18pt;line-height: 115%;text-align: left;">Consider what happens when you run an ordinary command from the shell. The command is found by searching the directories in <span class="s33">$PATH </span>and only then loaded into memory by the operating system. This is a system that works well. So, what if we could use the same system for shell functions? The operating system can’t run shell functions but it can run scripts, so one solution is to convert our functions to shell scripts and store them somewhere in <span class="s33">$PATH</span>. This solution has a limitation, however: shell scripts are run in a separate shell instance. Often when we write a shell function, we want that function to be run in the current shell instance. A function running in the current shell instance has access to information denied to scripts such as to shell variables, and it has the ability to make changes that affect the current shell, for example to the current directory. Functions controlling the line editor and completion system, which we show you how to write in the following chapters, also need to run in the current shell instance.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: justify;">The function autoloading mechanism of <span class="s33">ksh </span>and <span class="s33">zsh </span>takes the idea of loading commands when they are executed and applies it to functions. The functions are found by searching direc- tories listed in <span class="s33">$FPATH </span>for a file that has the same name as the function.</p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 114%;text-align: left;">In a similar fashion to the <span class="s33">path </span>array dual of <span class="s33">PATH</span>, <span class="s33">zsh </span>has a <span class="s33">fpath </span>array that is somewhat easier to manipulate than the <span class="s33">FPATH </span>string. It is common to create a directory for these functions within your home and add it to <span class="s33">fpath </span>from your startup file:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">fpath=( ~/.zfunc $fpath )</p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">You need to add the directory because unless you have a very old version of <span class="s33">zsh </span>the <span class="s33">fpath</span></p><p style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">will already contain a number of directories for such things as the completion system.</p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;"><span class="p">If you have used </span>ksh<span class="p">’s autoloadable functions, you will find that there are a few differences. One is that in </span>ksh<span class="p">, files containing autoloadable functions include the surrounding </span>function <span class="s32">name </span>{<span class="s32">...</span>} <span class="p">syntax to introduce and name the function. The other difference is that </span>zsh <span class="p">doesn’t automatically pick up functions by searching </span>fpath<span class="p">: you need to use </span>autoload <span class="p">on every func- tion. In </span>ksh<span class="p">, </span>FPATH <span class="p">is searched after </span>PATH <span class="p">so </span>autoload <span class="p">is only used for a function with the same name as an external command.</span></p><p style="padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Let’s try this with a simple function. Create a file named <span class="s33">newfunc </span>in the directory you added to <span class="s33">fpath </span>and put the command <span class="s33">echo hello </span>in it. The file doesn’t need to have any special permissions such as execute—you only need to be able to read it. If you try to run it now, it won’t work because <span class="s33">autoload </span>has not been executed. We’ve already seen <span class="s33">autoload </span>used for functions like <span class="s33">compinit </span>in the section “zsh’s compinit” in Chapter 10 and <span class="s33">promptinit </span>in the section “Prompt Themes” in Chapter 7. We just need to pass <span class="s33">autoload </span>the name of our function:</p><p class="s33" style="padding-top: 6pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>autoload newfunc</b></p><p style="padding-top: 8pt;padding-left: 59pt;text-indent: 0pt;text-align: left;">Now, you should be able to run the function:</p><p class="s33" style="padding-top: 8pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">zsh% <b>newfunc</b></p><p class="s33" style="padding-top: 1pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">hello</p><p style="padding-top: 8pt;padding-left: 41pt;text-indent: 18pt;line-height: 115%;text-align: left;">Having to use <span class="s33">autoload </span>before using every function would obviously be rather tedious, so this is one thing you will want to do from your startup file:</p><p class="s33" style="padding-top: 7pt;padding-left: 41pt;text-indent: 0pt;text-align: left;">autoload -- ~/.zfunc/[^_]*(:t)</p><p class="s29" style="padding-top: 3pt;padding-left: 249pt;text-indent: 0pt;text-align: left;"><a name="bookmark691">CHAPTER 13 </a><span class="s28">■ </span>SCRIPTING AND FUNCTION S <span class="s27">335</span></p><p style="text-indent: 0pt;text-align: left;"><br/></p><p style="padding-left: 40pt;text-indent: 18pt;line-height: 115%;text-align: left;">That omits any files beginning with an underscore because <span class="s33">compinit </span>will autoload them. The <span class="s33">(:t) </span>modifier removes any directory portion from the expansion—we only want the name of the function.</p><p style="text-indent: 0pt;text-align: left;"><br/></p><p class="nav">&nbsp;&nbsp;</p><p class="nav">&nbsp;</p><p class="nav"><a href="part358.htm">&lt; Previous</a><span> | </span><a href="../From Bash to Z Shell.html">Contents</a><span> | </span><a href="part360.htm">Next &gt;</a></p><p class="nav">&nbsp;&nbsp;</p></body></html>
