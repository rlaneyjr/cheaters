
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><title>Python: module pyparsing</title>
<meta charset="utf-8">
</head><body bgcolor="#f0f0f8">

<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="heading">
<tr bgcolor="#7799ee">
<td valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial">&nbsp;<br><big><big><strong>pyparsing</strong></big></big> (version 2.0.6)</font></td
><td align=right valign=bottom
><font color="#ffffff" face="helvetica, arial"><a href=".">index</a><br><a href="file:/usr/local/lib/python2.7/site-packages/pyparsing.py">/usr/local/lib/python2.7/site-packages/pyparsing.py</a></font></td></tr></table>
    <p><tt>pyparsing&nbsp;module&nbsp;-&nbsp;Classes&nbsp;and&nbsp;methods&nbsp;to&nbsp;define&nbsp;and&nbsp;execute&nbsp;parsing&nbsp;grammars<br>
&nbsp;<br>
The&nbsp;pyparsing&nbsp;module&nbsp;is&nbsp;an&nbsp;alternative&nbsp;approach&nbsp;to&nbsp;creating&nbsp;and&nbsp;executing&nbsp;simple&nbsp;grammars,<br>
vs.&nbsp;the&nbsp;traditional&nbsp;lex/yacc&nbsp;approach,&nbsp;or&nbsp;the&nbsp;use&nbsp;of&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;With&nbsp;pyparsing,&nbsp;you<br>
don't&nbsp;need&nbsp;to&nbsp;learn&nbsp;a&nbsp;new&nbsp;syntax&nbsp;for&nbsp;defining&nbsp;grammars&nbsp;or&nbsp;matching&nbsp;expressions&nbsp;-&nbsp;the&nbsp;parsing&nbsp;module<br>
provides&nbsp;a&nbsp;library&nbsp;of&nbsp;classes&nbsp;that&nbsp;you&nbsp;use&nbsp;to&nbsp;construct&nbsp;the&nbsp;grammar&nbsp;directly&nbsp;in&nbsp;Python.<br>
&nbsp;<br>
Here&nbsp;is&nbsp;a&nbsp;program&nbsp;to&nbsp;parse&nbsp;"Hello,&nbsp;World!"&nbsp;(or&nbsp;any&nbsp;greeting&nbsp;of&nbsp;the&nbsp;form&nbsp;C{"&lt;salutation&gt;,&nbsp;&lt;addressee&gt;!"})::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;pyparsing&nbsp;import&nbsp;<a href="#Word">Word</a>,&nbsp;alphas<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;define&nbsp;grammar&nbsp;of&nbsp;a&nbsp;greeting<br>
&nbsp;&nbsp;&nbsp;&nbsp;greet&nbsp;=&nbsp;<a href="#Word">Word</a>(&nbsp;alphas&nbsp;)&nbsp;+&nbsp;","&nbsp;+&nbsp;<a href="#Word">Word</a>(&nbsp;alphas&nbsp;)&nbsp;+&nbsp;"!"<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;hello&nbsp;=&nbsp;"Hello,&nbsp;World!"<br>
&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;(hello,&nbsp;"-&gt;",&nbsp;greet.parseString(&nbsp;hello&nbsp;))<br>
&nbsp;<br>
The&nbsp;program&nbsp;outputs&nbsp;the&nbsp;following::<br>
&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;Hello,&nbsp;World!&nbsp;-&gt;&nbsp;['Hello',&nbsp;',',&nbsp;'World',&nbsp;'!']<br>
&nbsp;<br>
The&nbsp;Python&nbsp;representation&nbsp;of&nbsp;the&nbsp;grammar&nbsp;is&nbsp;quite&nbsp;readable,&nbsp;owing&nbsp;to&nbsp;the&nbsp;self-explanatory<br>
class&nbsp;names,&nbsp;and&nbsp;the&nbsp;use&nbsp;of&nbsp;'+',&nbsp;'|'&nbsp;and&nbsp;'^'&nbsp;operators.<br>
&nbsp;<br>
The&nbsp;parsed&nbsp;results&nbsp;returned&nbsp;from&nbsp;C{parseString()}&nbsp;can&nbsp;be&nbsp;accessed&nbsp;as&nbsp;a&nbsp;nested&nbsp;list,&nbsp;a&nbsp;dictionary,&nbsp;or&nbsp;an<br>
<a href="__builtin__.html#object">object</a>&nbsp;with&nbsp;named&nbsp;attributes.<br>
&nbsp;<br>
The&nbsp;pyparsing&nbsp;module&nbsp;handles&nbsp;some&nbsp;of&nbsp;the&nbsp;problems&nbsp;that&nbsp;are&nbsp;typically&nbsp;vexing&nbsp;when&nbsp;writing&nbsp;text&nbsp;parsers:<br>
&nbsp;-&nbsp;extra&nbsp;or&nbsp;missing&nbsp;whitespace&nbsp;(the&nbsp;above&nbsp;program&nbsp;will&nbsp;also&nbsp;handle&nbsp;"Hello,World!",&nbsp;"Hello&nbsp;&nbsp;,&nbsp;&nbsp;World&nbsp;&nbsp;!",&nbsp;etc.)<br>
&nbsp;-&nbsp;quoted&nbsp;strings<br>
&nbsp;-&nbsp;embedded&nbsp;comments</tt></p>
<p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#aa55cc">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Modules</strong></big></font></td></tr>
    
<tr><td bgcolor="#aa55cc"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><table width="100%" summary="list"><tr><td width="25%" valign=top><a href="__builtin__.html">__builtin__</a><br>
<a href="collections.html">collections</a><br>
<a href="copy.html">copy</a><br>
</td><td width="25%" valign=top><a href="functools.html">functools</a><br>
<a href="itertools.html">itertools</a><br>
<a href="pprint.html">pprint</a><br>
</td><td width="25%" valign=top><a href="re.html">re</a><br>
<a href="sre_constants.html">sre_constants</a><br>
<a href="string.html">string</a><br>
</td><td width="25%" valign=top><a href="sys.html">sys</a><br>
<a href="warnings.html">warnings</a><br>
</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ee77aa">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Classes</strong></big></font></td></tr>
    
<tr><td bgcolor="#ee77aa"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl>
<dt><font face="helvetica, arial"><a href="__builtin__.html#object">__builtin__.object</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#OnlyOnce">OnlyOnce</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#ParseResults">ParseResults</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#ParserElement">ParserElement</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#FollowedBy">FollowedBy</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Forward">Forward</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#NotAny">NotAny</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#OneOrMore">OneOrMore</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Optional">Optional</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#SkipTo">SkipTo</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#TokenConverter">TokenConverter</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#Combine">Combine</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Dict">Dict</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Group">Group</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Suppress">Suppress</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Upcase">Upcase</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="pyparsing.html#ZeroOrMore">ZeroOrMore</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="pyparsing.html#ParseExpression">ParseExpression</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#And">And</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Each">Each</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#MatchFirst">MatchFirst</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Or">Or</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="pyparsing.html#Token">Token</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#CharsNotIn">CharsNotIn</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Empty">Empty</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Keyword">Keyword</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#CaselessKeyword">CaselessKeyword</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="pyparsing.html#Literal">Literal</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#CaselessLiteral">CaselessLiteral</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="pyparsing.html#NoMatch">NoMatch</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#QuotedString">QuotedString</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Regex">Regex</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#White">White</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#Word">Word</a>
</font></dt></dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt><font face="helvetica, arial"><a href="exceptions.html#Exception">exceptions.Exception</a>(<a href="exceptions.html#BaseException">exceptions.BaseException</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#ParseBaseException">ParseBaseException</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#ParseException">ParseException</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#ParseFatalException">ParseFatalException</a>
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#ParseSyntaxException">ParseSyntaxException</a>
</font></dt></dl>
</dd>
</dl>
</dd>
<dt><font face="helvetica, arial"><a href="pyparsing.html#RecursiveGrammarException">RecursiveGrammarException</a>
</font></dt></dl>
</dd>
<dt><font face="helvetica, arial"><a href="pyparsing.html#_PositionToken">_PositionToken</a>(<a href="pyparsing.html#Token">Token</a>)
</font></dt><dd>
<dl>
<dt><font face="helvetica, arial"><a href="pyparsing.html#GoToColumn">GoToColumn</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#LineEnd">LineEnd</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#LineStart">LineStart</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#StringEnd">StringEnd</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#StringStart">StringStart</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#WordEnd">WordEnd</a>
</font></dt><dt><font face="helvetica, arial"><a href="pyparsing.html#WordStart">WordStart</a>
</font></dt></dl>
</dd>
</dl>
 <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="And">class <strong>And</strong></a>(<a href="pyparsing.html#ParseExpression">ParseExpression</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Requires&nbsp;all&nbsp;given&nbsp;C{<a href="#ParseExpression">ParseExpression</a>}s&nbsp;to&nbsp;be&nbsp;found&nbsp;in&nbsp;the&nbsp;given&nbsp;order.<br>
Expressions&nbsp;may&nbsp;be&nbsp;separated&nbsp;by&nbsp;whitespace.<br>
May&nbsp;be&nbsp;constructed&nbsp;using&nbsp;the&nbsp;C{'+'}&nbsp;operator.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#And">And</a></dd>
<dd><a href="pyparsing.html#ParseExpression">ParseExpression</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="And-__iadd__"><strong>__iadd__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-__init__"><strong>__init__</strong></a>(self, exprs, savelist<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="And-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="And-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="And-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseExpression">ParseExpression</a>:<br>
<dl><dt><a name="And-__getitem__"><strong>__getitem__</strong></a>(self, i)</dt></dl>

<dl><dt><a name="And-append"><strong>append</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="And-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Extends&nbsp;C{leaveWhitespace}&nbsp;defined&nbsp;in&nbsp;base&nbsp;class,&nbsp;and&nbsp;also&nbsp;invokes&nbsp;C{leaveWhitespace}&nbsp;on<br>
all&nbsp;contained&nbsp;expressions.</tt></dd></dl>

<dl><dt><a name="And-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="And-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="And-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="And-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="And-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="And-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#And-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#And-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="And-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="And-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="And-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="And-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="And-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="And-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="And-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="And-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="And-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="And-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="And-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="And-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="And-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="And-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="And-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="And-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="And-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="And-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="And-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="And-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="And-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="And-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="And-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="And-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="And-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="And-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="And-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="And-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="And-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="And-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="And-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="And-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#And-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#And-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="And-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="And-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#And-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#And-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="And-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="And-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="And-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="CaselessKeyword">class <strong>CaselessKeyword</strong></a>(<a href="pyparsing.html#Keyword">Keyword</a>)</font></td></tr>
    
<tr><td bgcolor="#ffc8d8"><tt>&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#CaselessKeyword">CaselessKeyword</a></dd>
<dd><a href="pyparsing.html#Keyword">Keyword</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="CaselessKeyword-__init__"><strong>__init__</strong></a>(self, matchString, identChars<font color="#909090">='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'</font>)</dt></dl>

<dl><dt><a name="CaselessKeyword-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#Keyword">Keyword</a>:<br>
<dl><dt><a name="CaselessKeyword-copy"><strong>copy</strong></a>(self)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#Keyword">Keyword</a>:<br>
<dl><dt><a name="CaselessKeyword-setDefaultKeywordChars"><strong>setDefaultKeywordChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;<a href="#Keyword">Keyword</a>&nbsp;chars</tt></dd></dl>

<hr>
Data and other attributes inherited from <a href="pyparsing.html#Keyword">Keyword</a>:<br>
<dl><dt><strong>DEFAULT_KEYWORD_CHARS</strong> = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="CaselessKeyword-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#CaselessKeyword-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#CaselessKeyword-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessKeyword-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessKeyword-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessKeyword-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessKeyword-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessKeyword-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessKeyword-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessKeyword-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessKeyword-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="CaselessKeyword-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="CaselessKeyword-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="CaselessKeyword-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#CaselessKeyword-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessKeyword-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#CaselessKeyword-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#CaselessKeyword-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="CaselessKeyword-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="CaselessKeyword-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#CaselessKeyword-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#CaselessKeyword-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="CaselessKeyword-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="CaselessKeyword-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="CaselessLiteral">class <strong>CaselessLiteral</strong></a>(<a href="pyparsing.html#Literal">Literal</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;to&nbsp;match&nbsp;a&nbsp;specified&nbsp;string,&nbsp;ignoring&nbsp;case&nbsp;of&nbsp;letters.<br>
Note:&nbsp;the&nbsp;matched&nbsp;results&nbsp;will&nbsp;always&nbsp;be&nbsp;in&nbsp;the&nbsp;case&nbsp;of&nbsp;the&nbsp;given<br>
match&nbsp;string,&nbsp;NOT&nbsp;the&nbsp;case&nbsp;of&nbsp;the&nbsp;input&nbsp;text.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#CaselessLiteral">CaselessLiteral</a></dd>
<dd><a href="pyparsing.html#Literal">Literal</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="CaselessLiteral-__init__"><strong>__init__</strong></a>(self, matchString)</dt></dl>

<dl><dt><a name="CaselessLiteral-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes inherited from <a href="pyparsing.html#Literal">Literal</a>:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="CaselessLiteral-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#CaselessLiteral-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#CaselessLiteral-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessLiteral-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessLiteral-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessLiteral-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessLiteral-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessLiteral-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessLiteral-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CaselessLiteral-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessLiteral-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="CaselessLiteral-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="CaselessLiteral-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="CaselessLiteral-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#CaselessLiteral-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="CaselessLiteral-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#CaselessLiteral-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#CaselessLiteral-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="CaselessLiteral-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="CaselessLiteral-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#CaselessLiteral-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#CaselessLiteral-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="CaselessLiteral-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="CaselessLiteral-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="CharsNotIn">class <strong>CharsNotIn</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;for&nbsp;matching&nbsp;words&nbsp;composed&nbsp;of&nbsp;characters&nbsp;*not*&nbsp;in&nbsp;a&nbsp;given&nbsp;set.<br>
Defined&nbsp;with&nbsp;string&nbsp;containing&nbsp;all&nbsp;disallowed&nbsp;characters,&nbsp;and&nbsp;an&nbsp;optional<br>
minimum,&nbsp;maximum,&nbsp;and/or&nbsp;exact&nbsp;length.&nbsp;&nbsp;The&nbsp;default&nbsp;value&nbsp;for&nbsp;C{min}&nbsp;is&nbsp;1&nbsp;(a<br>
minimum&nbsp;value&nbsp;&lt;&nbsp;1&nbsp;is&nbsp;not&nbsp;valid);&nbsp;the&nbsp;default&nbsp;values&nbsp;for&nbsp;C{max}&nbsp;and&nbsp;C{exact}<br>
are&nbsp;0,&nbsp;meaning&nbsp;no&nbsp;maximum&nbsp;or&nbsp;exact&nbsp;length&nbsp;restriction.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#CharsNotIn">CharsNotIn</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="CharsNotIn-__init__"><strong>__init__</strong></a>(self, notChars, min<font color="#909090">=1</font>, max<font color="#909090">=0</font>, exact<font color="#909090">=0</font>)</dt></dl>

<dl><dt><a name="CharsNotIn-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="CharsNotIn-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="CharsNotIn-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#CharsNotIn-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#CharsNotIn-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CharsNotIn-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="CharsNotIn-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CharsNotIn-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="CharsNotIn-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CharsNotIn-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CharsNotIn-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="CharsNotIn-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="CharsNotIn-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="CharsNotIn-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="CharsNotIn-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="CharsNotIn-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="CharsNotIn-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="CharsNotIn-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#CharsNotIn-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="CharsNotIn-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="CharsNotIn-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#CharsNotIn-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#CharsNotIn-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="CharsNotIn-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="CharsNotIn-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#CharsNotIn-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#CharsNotIn-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="CharsNotIn-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="CharsNotIn-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Combine">class <strong>Combine</strong></a>(<a href="pyparsing.html#TokenConverter">TokenConverter</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Converter&nbsp;to&nbsp;concatenate&nbsp;all&nbsp;matching&nbsp;tokens&nbsp;to&nbsp;a&nbsp;single&nbsp;string.<br>
By&nbsp;default,&nbsp;the&nbsp;matching&nbsp;patterns&nbsp;must&nbsp;also&nbsp;be&nbsp;contiguous&nbsp;in&nbsp;the&nbsp;input&nbsp;string;<br>
this&nbsp;can&nbsp;be&nbsp;disabled&nbsp;by&nbsp;specifying&nbsp;C{'adjacent=False'}&nbsp;in&nbsp;the&nbsp;constructor.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Combine">Combine</a></dd>
<dd><a href="pyparsing.html#TokenConverter">TokenConverter</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Combine-__init__"><strong>__init__</strong></a>(self, expr, joinString<font color="#909090">=''</font>, adjacent<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Combine-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Combine-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="Combine-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Combine-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Combine-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="Combine-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Combine-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Combine-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Combine-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Combine-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Combine-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Combine-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Combine-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Combine-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Combine-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Combine-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Combine-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Combine-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Combine-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Combine-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Combine-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Combine-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Combine-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Combine-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Combine-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Combine-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Combine-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Combine-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Combine-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Combine-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Combine-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Combine-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Combine-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Combine-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Combine-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Combine-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Combine-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Combine-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Combine-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Combine-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Combine-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Combine-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Combine-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Combine-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Combine-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Combine-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Combine-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Combine-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Combine-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Combine-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Combine-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Dict">class <strong>Dict</strong></a>(<a href="pyparsing.html#TokenConverter">TokenConverter</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Converter&nbsp;to&nbsp;return&nbsp;a&nbsp;repetitive&nbsp;expression&nbsp;as&nbsp;a&nbsp;list,&nbsp;but&nbsp;also&nbsp;as&nbsp;a&nbsp;dictionary.<br>
<a href="#Each">Each</a>&nbsp;element&nbsp;can&nbsp;also&nbsp;be&nbsp;referenced&nbsp;using&nbsp;the&nbsp;first&nbsp;token&nbsp;in&nbsp;the&nbsp;expression&nbsp;as&nbsp;its&nbsp;key.<br>
Useful&nbsp;for&nbsp;tabular&nbsp;report&nbsp;scraping&nbsp;when&nbsp;the&nbsp;first&nbsp;column&nbsp;can&nbsp;be&nbsp;used&nbsp;as&nbsp;a&nbsp;item&nbsp;key.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Dict">Dict</a></dd>
<dd><a href="pyparsing.html#TokenConverter">TokenConverter</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Dict-__init__"><strong>__init__</strong></a>(self, expr)</dt></dl>

<dl><dt><a name="Dict-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="Dict-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Dict-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Dict-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Dict-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="Dict-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Dict-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Dict-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Dict-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Dict-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Dict-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Dict-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Dict-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Dict-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Dict-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Dict-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Dict-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Dict-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Dict-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Dict-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Dict-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Dict-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Dict-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Dict-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Dict-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Dict-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Dict-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Dict-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Dict-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Dict-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Dict-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Dict-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Dict-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Dict-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Dict-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Dict-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Dict-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Dict-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Dict-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Dict-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Dict-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Dict-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Dict-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Dict-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Dict-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Dict-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Dict-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Dict-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Dict-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Dict-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Dict-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Each">class <strong>Each</strong></a>(<a href="pyparsing.html#ParseExpression">ParseExpression</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Requires&nbsp;all&nbsp;given&nbsp;C{<a href="#ParseExpression">ParseExpression</a>}s&nbsp;to&nbsp;be&nbsp;found,&nbsp;but&nbsp;in&nbsp;any&nbsp;order.<br>
Expressions&nbsp;may&nbsp;be&nbsp;separated&nbsp;by&nbsp;whitespace.<br>
May&nbsp;be&nbsp;constructed&nbsp;using&nbsp;the&nbsp;C{'&amp;'}&nbsp;operator.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Each">Each</a></dd>
<dd><a href="pyparsing.html#ParseExpression">ParseExpression</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Each-__init__"><strong>__init__</strong></a>(self, exprs, savelist<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Each-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Each-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Each-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseExpression">ParseExpression</a>:<br>
<dl><dt><a name="Each-__getitem__"><strong>__getitem__</strong></a>(self, i)</dt></dl>

<dl><dt><a name="Each-append"><strong>append</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Each-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="Each-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Each-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Extends&nbsp;C{leaveWhitespace}&nbsp;defined&nbsp;in&nbsp;base&nbsp;class,&nbsp;and&nbsp;also&nbsp;invokes&nbsp;C{leaveWhitespace}&nbsp;on<br>
all&nbsp;contained&nbsp;expressions.</tt></dd></dl>

<dl><dt><a name="Each-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="Each-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Each-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Each-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Each-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Each-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Each-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Each-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Each-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Each-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Each-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Each-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Each-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Each-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Each-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Each-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Each-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Each-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Each-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Each-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Each-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Each-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Each-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Each-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Each-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Each-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Each-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Each-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Each-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Each-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Each-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Each-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Each-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Each-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Each-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Each-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Each-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Each-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Each-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Each-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Each-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Each-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Each-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Each-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Each-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Empty">class <strong>Empty</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>An&nbsp;empty&nbsp;token,&nbsp;will&nbsp;always&nbsp;match.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Empty">Empty</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Empty-__init__"><strong>__init__</strong></a>(self)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Empty-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Empty-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Empty-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Empty-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Empty-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Empty-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Empty-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Empty-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Empty-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Empty-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Empty-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Empty-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Empty-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Empty-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Empty-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Empty-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Empty-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Empty-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Empty-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="Empty-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="Empty-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Empty-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Empty-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Empty-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Empty-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Empty-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Empty-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Empty-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Empty-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Empty-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Empty-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Empty-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Empty-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Empty-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Empty-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Empty-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Empty-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Empty-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Empty-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Empty-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Empty-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Empty-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Empty-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Empty-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Empty-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Empty-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Empty-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Empty-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Empty-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Empty-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Empty-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="FollowedBy">class <strong>FollowedBy</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Lookahead&nbsp;matching&nbsp;of&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;C{<a href="#FollowedBy">FollowedBy</a>}<br>
does&nbsp;*not*&nbsp;advance&nbsp;the&nbsp;parsing&nbsp;position&nbsp;within&nbsp;the&nbsp;input&nbsp;string,&nbsp;it&nbsp;only<br>
verifies&nbsp;that&nbsp;the&nbsp;specified&nbsp;parse&nbsp;expression&nbsp;matches&nbsp;at&nbsp;the&nbsp;current<br>
position.&nbsp;&nbsp;C{<a href="#FollowedBy">FollowedBy</a>}&nbsp;always&nbsp;returns&nbsp;a&nbsp;null&nbsp;token&nbsp;list.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#FollowedBy">FollowedBy</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="FollowedBy-__init__"><strong>__init__</strong></a>(self, expr)</dt></dl>

<dl><dt><a name="FollowedBy-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="FollowedBy-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="FollowedBy-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="FollowedBy-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="FollowedBy-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="FollowedBy-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="FollowedBy-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="FollowedBy-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#FollowedBy-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#FollowedBy-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="FollowedBy-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="FollowedBy-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="FollowedBy-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="FollowedBy-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="FollowedBy-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="FollowedBy-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="FollowedBy-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="FollowedBy-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="FollowedBy-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="FollowedBy-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="FollowedBy-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="FollowedBy-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="FollowedBy-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="FollowedBy-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="FollowedBy-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="FollowedBy-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="FollowedBy-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="FollowedBy-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="FollowedBy-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="FollowedBy-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#FollowedBy-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="FollowedBy-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="FollowedBy-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="FollowedBy-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#FollowedBy-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#FollowedBy-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="FollowedBy-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="FollowedBy-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#FollowedBy-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#FollowedBy-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="FollowedBy-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="FollowedBy-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="FollowedBy-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Forward">class <strong>Forward</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Forward">Forward</a>&nbsp;declaration&nbsp;of&nbsp;an&nbsp;expression&nbsp;to&nbsp;be&nbsp;defined&nbsp;later&nbsp;-<br>
used&nbsp;for&nbsp;recursive&nbsp;grammars,&nbsp;such&nbsp;as&nbsp;algebraic&nbsp;infix&nbsp;notation.<br>
When&nbsp;the&nbsp;expression&nbsp;is&nbsp;known,&nbsp;it&nbsp;is&nbsp;assigned&nbsp;to&nbsp;the&nbsp;C{<a href="#Forward">Forward</a>}&nbsp;variable&nbsp;using&nbsp;the&nbsp;'&lt;&lt;'&nbsp;operator.<br>
&nbsp;<br>
Note:&nbsp;take&nbsp;care&nbsp;when&nbsp;assigning&nbsp;to&nbsp;C{<a href="#Forward">Forward</a>}&nbsp;not&nbsp;to&nbsp;overlook&nbsp;precedence&nbsp;of&nbsp;operators.<br>
Specifically,&nbsp;'|'&nbsp;has&nbsp;a&nbsp;lower&nbsp;precedence&nbsp;than&nbsp;'&lt;&lt;',&nbsp;so&nbsp;that::<br>
&nbsp;&nbsp;&nbsp;fwdExpr&nbsp;&lt;&lt;&nbsp;a&nbsp;|&nbsp;b&nbsp;|&nbsp;c<br>
will&nbsp;actually&nbsp;be&nbsp;evaluated&nbsp;as::<br>
&nbsp;&nbsp;&nbsp;(fwdExpr&nbsp;&lt;&lt;&nbsp;a)&nbsp;|&nbsp;b&nbsp;|&nbsp;c<br>
thereby&nbsp;leaving&nbsp;b&nbsp;and&nbsp;c&nbsp;out&nbsp;as&nbsp;parseable&nbsp;alternatives.&nbsp;&nbsp;It&nbsp;is&nbsp;recommended&nbsp;that&nbsp;you<br>
explicitly&nbsp;group&nbsp;the&nbsp;values&nbsp;inserted&nbsp;into&nbsp;the&nbsp;C{<a href="#Forward">Forward</a>}::<br>
&nbsp;&nbsp;&nbsp;fwdExpr&nbsp;&lt;&lt;&nbsp;(a&nbsp;|&nbsp;b&nbsp;|&nbsp;c)<br>
Converting&nbsp;to&nbsp;use&nbsp;the&nbsp;'&lt;&lt;='&nbsp;operator&nbsp;instead&nbsp;will&nbsp;avoid&nbsp;this&nbsp;problem.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Forward">Forward</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Forward-__ilshift__"><strong>__ilshift__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-__init__"><strong>__init__</strong></a>(self, other<font color="#909090">=None</font>)</dt></dl>

<dl><dt><a name="Forward-__lshift__"><strong>__lshift__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Forward-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="Forward-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="Forward-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Forward-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="Forward-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Forward-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Forward-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Forward-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Forward-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Forward-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Forward-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Forward-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Forward-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Forward-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Forward-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Forward-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Forward-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Forward-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Forward-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Forward-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Forward-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Forward-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Forward-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Forward-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Forward-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Forward-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Forward-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Forward-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Forward-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Forward-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Forward-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Forward-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Forward-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Forward-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Forward-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Forward-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Forward-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Forward-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Forward-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Forward-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Forward-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Forward-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Forward-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Forward-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Forward-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="GoToColumn">class <strong>GoToColumn</strong></a>(<a href="pyparsing.html#_PositionToken">_PositionToken</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;to&nbsp;advance&nbsp;to&nbsp;a&nbsp;specific&nbsp;column&nbsp;of&nbsp;input&nbsp;text;&nbsp;useful&nbsp;for&nbsp;tabular&nbsp;report&nbsp;scraping.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#GoToColumn">GoToColumn</a></dd>
<dd><a href="pyparsing.html#_PositionToken">_PositionToken</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="GoToColumn-__init__"><strong>__init__</strong></a>(self, colno)</dt></dl>

<dl><dt><a name="GoToColumn-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="GoToColumn-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="GoToColumn-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#GoToColumn-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#GoToColumn-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="GoToColumn-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="GoToColumn-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="GoToColumn-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="GoToColumn-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="GoToColumn-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="GoToColumn-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="GoToColumn-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="GoToColumn-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="GoToColumn-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="GoToColumn-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="GoToColumn-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="GoToColumn-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="GoToColumn-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="GoToColumn-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="GoToColumn-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="GoToColumn-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="GoToColumn-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="GoToColumn-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="GoToColumn-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="GoToColumn-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="GoToColumn-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="GoToColumn-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="GoToColumn-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#GoToColumn-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="GoToColumn-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="GoToColumn-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="GoToColumn-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="GoToColumn-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#GoToColumn-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#GoToColumn-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="GoToColumn-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="GoToColumn-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="GoToColumn-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#GoToColumn-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#GoToColumn-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="GoToColumn-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="GoToColumn-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="GoToColumn-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Group">class <strong>Group</strong></a>(<a href="pyparsing.html#TokenConverter">TokenConverter</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Converter&nbsp;to&nbsp;return&nbsp;the&nbsp;matched&nbsp;tokens&nbsp;as&nbsp;a&nbsp;list&nbsp;-&nbsp;useful&nbsp;for&nbsp;returning&nbsp;tokens&nbsp;of&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}}&nbsp;and&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}}&nbsp;expressions.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Group">Group</a></dd>
<dd><a href="pyparsing.html#TokenConverter">TokenConverter</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Group-__init__"><strong>__init__</strong></a>(self, expr)</dt></dl>

<dl><dt><a name="Group-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="Group-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Group-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Group-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Group-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="Group-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Group-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Group-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Group-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Group-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Group-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Group-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Group-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Group-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Group-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Group-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Group-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Group-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Group-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Group-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Group-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Group-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Group-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Group-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Group-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Group-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Group-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Group-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Group-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Group-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Group-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Group-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Group-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Group-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Group-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Group-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Group-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Group-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Group-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Group-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Group-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Group-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Group-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Group-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Group-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Group-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Group-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Group-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Group-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Group-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Group-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Group-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Keyword">class <strong>Keyword</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string&nbsp;as&nbsp;a&nbsp;keyword,&nbsp;that&nbsp;is,&nbsp;it&nbsp;must&nbsp;be<br>
immediately&nbsp;followed&nbsp;by&nbsp;a&nbsp;non-keyword&nbsp;character.&nbsp;&nbsp;Compare&nbsp;with&nbsp;C{L{<a href="#Literal">Literal</a>}}::<br>
&nbsp;&nbsp;<a href="#Literal">Literal</a>("if")&nbsp;will&nbsp;match&nbsp;the&nbsp;leading&nbsp;C{'if'}&nbsp;in&nbsp;C{'ifAndOnlyIf'}.<br>
&nbsp;&nbsp;<a href="#Keyword">Keyword</a>("if")&nbsp;will&nbsp;not;&nbsp;it&nbsp;will&nbsp;only&nbsp;match&nbsp;the&nbsp;leading&nbsp;C{'if'}&nbsp;in&nbsp;C{'if&nbsp;x=1'},&nbsp;or&nbsp;C{'if(y==2)'}<br>
Accepts&nbsp;two&nbsp;optional&nbsp;constructor&nbsp;arguments&nbsp;in&nbsp;addition&nbsp;to&nbsp;the&nbsp;keyword&nbsp;string:<br>
C{identChars}&nbsp;is&nbsp;a&nbsp;string&nbsp;of&nbsp;characters&nbsp;that&nbsp;would&nbsp;be&nbsp;valid&nbsp;identifier&nbsp;characters,<br>
defaulting&nbsp;to&nbsp;all&nbsp;alphanumerics&nbsp;+&nbsp;"_"&nbsp;and&nbsp;"$";&nbsp;C{caseless}&nbsp;allows&nbsp;case-insensitive<br>
matching,&nbsp;default&nbsp;is&nbsp;C{False}.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Keyword">Keyword</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Keyword-__init__"><strong>__init__</strong></a>(self, matchString, identChars<font color="#909090">='abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'</font>, caseless<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="Keyword-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="Keyword-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="Keyword-setDefaultKeywordChars"><strong>setDefaultKeywordChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;<a href="#Keyword">Keyword</a>&nbsp;chars</tt></dd></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>DEFAULT_KEYWORD_CHARS</strong> = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_$'</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Keyword-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Keyword-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Keyword-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Keyword-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Keyword-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Keyword-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Keyword-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Keyword-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Keyword-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Keyword-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Keyword-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Keyword-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Keyword-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Keyword-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Keyword-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Keyword-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Keyword-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Keyword-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="Keyword-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="Keyword-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Keyword-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Keyword-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Keyword-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Keyword-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Keyword-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Keyword-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Keyword-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Keyword-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Keyword-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Keyword-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Keyword-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Keyword-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Keyword-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Keyword-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Keyword-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Keyword-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Keyword-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Keyword-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Keyword-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Keyword-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Keyword-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Keyword-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Keyword-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Keyword-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Keyword-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Keyword-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Keyword-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Keyword-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Keyword-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LineEnd">class <strong>LineEnd</strong></a>(<a href="pyparsing.html#_PositionToken">_PositionToken</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Matches&nbsp;if&nbsp;current&nbsp;position&nbsp;is&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;a&nbsp;line&nbsp;within&nbsp;the&nbsp;parse&nbsp;string<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#LineEnd">LineEnd</a></dd>
<dd><a href="pyparsing.html#_PositionToken">_PositionToken</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="LineEnd-__init__"><strong>__init__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineEnd-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="LineEnd-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#LineEnd-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#LineEnd-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="LineEnd-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineEnd-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineEnd-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="LineEnd-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineEnd-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineEnd-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineEnd-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineEnd-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineEnd-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineEnd-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="LineEnd-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="LineEnd-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="LineEnd-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="LineEnd-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="LineEnd-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="LineEnd-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="LineEnd-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="LineEnd-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="LineEnd-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="LineEnd-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="LineEnd-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="LineEnd-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="LineEnd-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="LineEnd-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="LineEnd-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="LineEnd-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="LineEnd-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="LineEnd-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="LineEnd-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="LineEnd-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="LineEnd-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="LineEnd-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#LineEnd-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="LineEnd-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="LineEnd-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="LineEnd-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="LineEnd-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#LineEnd-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#LineEnd-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="LineEnd-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="LineEnd-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="LineEnd-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#LineEnd-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#LineEnd-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="LineEnd-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="LineEnd-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="LineEnd-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="LineStart">class <strong>LineStart</strong></a>(<a href="pyparsing.html#_PositionToken">_PositionToken</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Matches&nbsp;if&nbsp;current&nbsp;position&nbsp;is&nbsp;at&nbsp;the&nbsp;beginning&nbsp;of&nbsp;a&nbsp;line&nbsp;within&nbsp;the&nbsp;parse&nbsp;string<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#LineStart">LineStart</a></dd>
<dd><a href="pyparsing.html#_PositionToken">_PositionToken</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="LineStart-__init__"><strong>__init__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineStart-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="LineStart-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="LineStart-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#LineStart-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#LineStart-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="LineStart-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineStart-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineStart-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="LineStart-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineStart-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineStart-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineStart-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineStart-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="LineStart-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="LineStart-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="LineStart-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="LineStart-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="LineStart-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="LineStart-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="LineStart-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="LineStart-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="LineStart-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="LineStart-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="LineStart-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="LineStart-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="LineStart-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="LineStart-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="LineStart-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="LineStart-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="LineStart-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="LineStart-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="LineStart-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="LineStart-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="LineStart-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="LineStart-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="LineStart-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#LineStart-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="LineStart-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="LineStart-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="LineStart-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="LineStart-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#LineStart-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#LineStart-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="LineStart-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="LineStart-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="LineStart-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#LineStart-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#LineStart-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="LineStart-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="LineStart-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="LineStart-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Literal">class <strong>Literal</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Literal">Literal</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Literal-__init__"><strong>__init__</strong></a>(self, matchString)</dt></dl>

<dl><dt><a name="Literal-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt><dd><tt>#&nbsp;Performance&nbsp;tuning:&nbsp;this&nbsp;routine&nbsp;gets&nbsp;called&nbsp;a&nbsp;*lot*<br>
#&nbsp;if&nbsp;this&nbsp;is&nbsp;a&nbsp;single&nbsp;character&nbsp;match&nbsp;string&nbsp;&nbsp;and&nbsp;the&nbsp;first&nbsp;character&nbsp;matches,<br>
#&nbsp;short-circuit&nbsp;as&nbsp;quickly&nbsp;as&nbsp;possible,&nbsp;and&nbsp;avoid&nbsp;calling&nbsp;startswith<br>
#~&nbsp;@profile</tt></dd></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Literal-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Literal-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Literal-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Literal-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Literal-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Literal-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Literal-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Literal-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Literal-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Literal-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Literal-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Literal-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Literal-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Literal-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Literal-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Literal-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Literal-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Literal-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Literal-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="Literal-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="Literal-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Literal-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Literal-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Literal-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Literal-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Literal-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Literal-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Literal-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Literal-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Literal-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Literal-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Literal-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Literal-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Literal-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Literal-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Literal-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Literal-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Literal-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Literal-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Literal-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Literal-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Literal-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Literal-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Literal-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Literal-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Literal-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Literal-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Literal-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Literal-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Literal-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="MatchFirst">class <strong>MatchFirst</strong></a>(<a href="pyparsing.html#ParseExpression">ParseExpression</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Requires&nbsp;that&nbsp;at&nbsp;least&nbsp;one&nbsp;C{<a href="#ParseExpression">ParseExpression</a>}&nbsp;is&nbsp;found.<br>
If&nbsp;two&nbsp;expressions&nbsp;match,&nbsp;the&nbsp;first&nbsp;one&nbsp;listed&nbsp;is&nbsp;the&nbsp;one&nbsp;that&nbsp;will&nbsp;match.<br>
May&nbsp;be&nbsp;constructed&nbsp;using&nbsp;the&nbsp;C{'|'}&nbsp;operator.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#MatchFirst">MatchFirst</a></dd>
<dd><a href="pyparsing.html#ParseExpression">ParseExpression</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="MatchFirst-__init__"><strong>__init__</strong></a>(self, exprs, savelist<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="MatchFirst-__ior__"><strong>__ior__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="MatchFirst-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="MatchFirst-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseExpression">ParseExpression</a>:<br>
<dl><dt><a name="MatchFirst-__getitem__"><strong>__getitem__</strong></a>(self, i)</dt></dl>

<dl><dt><a name="MatchFirst-append"><strong>append</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="MatchFirst-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Extends&nbsp;C{leaveWhitespace}&nbsp;defined&nbsp;in&nbsp;base&nbsp;class,&nbsp;and&nbsp;also&nbsp;invokes&nbsp;C{leaveWhitespace}&nbsp;on<br>
all&nbsp;contained&nbsp;expressions.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="MatchFirst-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="MatchFirst-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="MatchFirst-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#MatchFirst-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#MatchFirst-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="MatchFirst-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="MatchFirst-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="MatchFirst-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="MatchFirst-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="MatchFirst-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="MatchFirst-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="MatchFirst-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="MatchFirst-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="MatchFirst-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="MatchFirst-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="MatchFirst-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="MatchFirst-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="MatchFirst-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="MatchFirst-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="MatchFirst-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="MatchFirst-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="MatchFirst-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="MatchFirst-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#MatchFirst-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#MatchFirst-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="MatchFirst-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="MatchFirst-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#MatchFirst-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#MatchFirst-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="MatchFirst-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="MatchFirst-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="MatchFirst-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="NoMatch">class <strong>NoMatch</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>A&nbsp;token&nbsp;that&nbsp;will&nbsp;never&nbsp;match.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#NoMatch">NoMatch</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="NoMatch-__init__"><strong>__init__</strong></a>(self)</dt></dl>

<dl><dt><a name="NoMatch-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="NoMatch-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#NoMatch-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#NoMatch-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="NoMatch-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NoMatch-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="NoMatch-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="NoMatch-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NoMatch-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="NoMatch-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NoMatch-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NoMatch-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NoMatch-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="NoMatch-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="NoMatch-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="NoMatch-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="NoMatch-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="NoMatch-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="NoMatch-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="NoMatch-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="NoMatch-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="NoMatch-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="NoMatch-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="NoMatch-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="NoMatch-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="NoMatch-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="NoMatch-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="NoMatch-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="NoMatch-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="NoMatch-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="NoMatch-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="NoMatch-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="NoMatch-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="NoMatch-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="NoMatch-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="NoMatch-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#NoMatch-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="NoMatch-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="NoMatch-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="NoMatch-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="NoMatch-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#NoMatch-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#NoMatch-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="NoMatch-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="NoMatch-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="NoMatch-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#NoMatch-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#NoMatch-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="NoMatch-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="NoMatch-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="NoMatch-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="NotAny">class <strong>NotAny</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Lookahead&nbsp;to&nbsp;disallow&nbsp;matching&nbsp;with&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;C{<a href="#NotAny">NotAny</a>}<br>
does&nbsp;*not*&nbsp;advance&nbsp;the&nbsp;parsing&nbsp;position&nbsp;within&nbsp;the&nbsp;input&nbsp;string,&nbsp;it&nbsp;only<br>
verifies&nbsp;that&nbsp;the&nbsp;specified&nbsp;parse&nbsp;expression&nbsp;does&nbsp;*not*&nbsp;match&nbsp;at&nbsp;the&nbsp;current<br>
position.&nbsp;&nbsp;Also,&nbsp;C{<a href="#NotAny">NotAny</a>}&nbsp;does&nbsp;*not*&nbsp;skip&nbsp;over&nbsp;leading&nbsp;whitespace.&nbsp;C{<a href="#NotAny">NotAny</a>}<br>
always&nbsp;returns&nbsp;a&nbsp;null&nbsp;token&nbsp;list.&nbsp;&nbsp;May&nbsp;be&nbsp;constructed&nbsp;using&nbsp;the&nbsp;'~'&nbsp;operator.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#NotAny">NotAny</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="NotAny-__init__"><strong>__init__</strong></a>(self, expr)</dt></dl>

<dl><dt><a name="NotAny-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="NotAny-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="NotAny-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="NotAny-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NotAny-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="NotAny-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="NotAny-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="NotAny-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#NotAny-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#NotAny-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="NotAny-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NotAny-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="NotAny-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="NotAny-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NotAny-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="NotAny-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NotAny-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NotAny-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="NotAny-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="NotAny-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="NotAny-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="NotAny-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="NotAny-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="NotAny-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="NotAny-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="NotAny-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="NotAny-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="NotAny-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="NotAny-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="NotAny-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="NotAny-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="NotAny-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="NotAny-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="NotAny-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="NotAny-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="NotAny-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="NotAny-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="NotAny-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#NotAny-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="NotAny-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="NotAny-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="NotAny-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#NotAny-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#NotAny-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="NotAny-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="NotAny-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#NotAny-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#NotAny-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="NotAny-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="NotAny-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="NotAny-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="OneOrMore">class <strong>OneOrMore</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Repetition&nbsp;of&nbsp;one&nbsp;or&nbsp;more&nbsp;of&nbsp;the&nbsp;given&nbsp;expression.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#OneOrMore">OneOrMore</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="OneOrMore-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="OneOrMore-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="OneOrMore-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="OneOrMore-__init__"><strong>__init__</strong></a>(self, expr, savelist<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="OneOrMore-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="OneOrMore-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="OneOrMore-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="OneOrMore-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="OneOrMore-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="OneOrMore-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#OneOrMore-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#OneOrMore-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="OneOrMore-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="OneOrMore-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="OneOrMore-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="OneOrMore-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="OneOrMore-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="OneOrMore-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="OneOrMore-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="OneOrMore-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="OneOrMore-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="OneOrMore-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="OneOrMore-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="OneOrMore-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="OneOrMore-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="OneOrMore-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="OneOrMore-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="OneOrMore-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="OneOrMore-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="OneOrMore-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="OneOrMore-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="OneOrMore-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="OneOrMore-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="OneOrMore-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="OneOrMore-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="OneOrMore-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="OneOrMore-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="OneOrMore-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="OneOrMore-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="OneOrMore-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="OneOrMore-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#OneOrMore-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#OneOrMore-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="OneOrMore-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="OneOrMore-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#OneOrMore-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#OneOrMore-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="OneOrMore-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="OneOrMore-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="OneOrMore-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="OnlyOnce">class <strong>OnlyOnce</strong></a>(<a href="__builtin__.html#object">__builtin__.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Wrapper&nbsp;for&nbsp;parse&nbsp;actions,&nbsp;to&nbsp;ensure&nbsp;they&nbsp;are&nbsp;only&nbsp;called&nbsp;once.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="OnlyOnce-__call__"><strong>__call__</strong></a>(self, s, l, t)</dt></dl>

<dl><dt><a name="OnlyOnce-__init__"><strong>__init__</strong></a>(self, methodCall)</dt></dl>

<dl><dt><a name="OnlyOnce-reset"><strong>reset</strong></a>(self)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Optional">class <strong>Optional</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Optional">Optional</a>&nbsp;matching&nbsp;of&nbsp;the&nbsp;given&nbsp;expression.<br>
A&nbsp;default&nbsp;return&nbsp;string&nbsp;can&nbsp;also&nbsp;be&nbsp;specified,&nbsp;if&nbsp;the&nbsp;optional&nbsp;expression<br>
is&nbsp;not&nbsp;found.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Optional">Optional</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Optional-__init__"><strong>__init__</strong></a>(self, expr, default<font color="#909090">=&lt;pyparsing._NullToken object&gt;</font>)</dt></dl>

<dl><dt><a name="Optional-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Optional-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="Optional-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Optional-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Optional-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="Optional-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Optional-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Optional-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Optional-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Optional-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Optional-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Optional-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Optional-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Optional-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Optional-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Optional-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Optional-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Optional-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Optional-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Optional-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Optional-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Optional-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Optional-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Optional-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Optional-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Optional-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Optional-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Optional-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Optional-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Optional-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Optional-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Optional-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Optional-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Optional-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Optional-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Optional-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Optional-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Optional-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Optional-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Optional-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Optional-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Optional-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Optional-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Optional-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Optional-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Optional-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Optional-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Optional-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Optional-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Optional-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Optional-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Or">class <strong>Or</strong></a>(<a href="pyparsing.html#ParseExpression">ParseExpression</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Requires&nbsp;that&nbsp;at&nbsp;least&nbsp;one&nbsp;C{<a href="#ParseExpression">ParseExpression</a>}&nbsp;is&nbsp;found.<br>
If&nbsp;two&nbsp;expressions&nbsp;match,&nbsp;the&nbsp;expression&nbsp;that&nbsp;matches&nbsp;the&nbsp;longest&nbsp;string&nbsp;will&nbsp;be&nbsp;used.<br>
May&nbsp;be&nbsp;constructed&nbsp;using&nbsp;the&nbsp;C{'^'}&nbsp;operator.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Or">Or</a></dd>
<dd><a href="pyparsing.html#ParseExpression">ParseExpression</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Or-__init__"><strong>__init__</strong></a>(self, exprs, savelist<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="Or-__ixor__"><strong>__ixor__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Or-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Or-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseExpression">ParseExpression</a>:<br>
<dl><dt><a name="Or-__getitem__"><strong>__getitem__</strong></a>(self, i)</dt></dl>

<dl><dt><a name="Or-append"><strong>append</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="Or-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Extends&nbsp;C{leaveWhitespace}&nbsp;defined&nbsp;in&nbsp;base&nbsp;class,&nbsp;and&nbsp;also&nbsp;invokes&nbsp;C{leaveWhitespace}&nbsp;on<br>
all&nbsp;contained&nbsp;expressions.</tt></dd></dl>

<dl><dt><a name="Or-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="Or-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Or-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Or-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Or-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Or-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Or-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Or-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Or-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Or-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Or-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Or-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Or-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Or-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Or-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Or-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Or-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Or-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Or-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Or-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Or-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Or-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Or-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Or-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Or-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Or-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Or-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Or-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Or-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Or-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Or-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Or-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Or-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Or-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Or-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Or-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Or-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Or-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Or-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Or-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Or-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParseBaseException">class <strong>ParseBaseException</strong></a>(<a href="exceptions.html#Exception">exceptions.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>base&nbsp;exception&nbsp;class&nbsp;for&nbsp;all&nbsp;parsing&nbsp;runtime&nbsp;exceptions<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#ParseBaseException">ParseBaseException</a></dd>
<dd><a href="exceptions.html#Exception">exceptions.Exception</a></dd>
<dd><a href="exceptions.html#BaseException">exceptions.BaseException</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ParseBaseException-__dir__"><strong>__dir__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseBaseException-__getattr__"><strong>__getattr__</strong></a>(self, aname)</dt><dd><tt>supported&nbsp;attributes&nbsp;by&nbsp;name&nbsp;are:<br>
-&nbsp;lineno&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;col&nbsp;-&nbsp;returns&nbsp;the&nbsp;column&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;line&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;containing&nbsp;the&nbsp;exception&nbsp;text</tt></dd></dl>

<dl><dt><a name="ParseBaseException-__init__"><strong>__init__</strong></a>(self, pstr, loc<font color="#909090">=0</font>, msg<font color="#909090">=None</font>, elem<font color="#909090">=None</font>)</dt><dd><tt>#&nbsp;Performance&nbsp;tuning:&nbsp;we&nbsp;construct&nbsp;a&nbsp;*lot*&nbsp;of&nbsp;these,&nbsp;so&nbsp;keep&nbsp;this<br>
#&nbsp;constructor&nbsp;as&nbsp;small&nbsp;and&nbsp;fast&nbsp;as&nbsp;possible</tt></dd></dl>

<dl><dt><a name="ParseBaseException-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseBaseException-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseBaseException-markInputline"><strong>markInputline</strong></a>(self, markerString<font color="#909090">='&gt;!&lt;'</font>)</dt><dd><tt>Extracts&nbsp;the&nbsp;exception&nbsp;line&nbsp;from&nbsp;the&nbsp;input&nbsp;string,&nbsp;and&nbsp;marks<br>
the&nbsp;location&nbsp;of&nbsp;the&nbsp;exception&nbsp;with&nbsp;a&nbsp;special&nbsp;symbol.</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><strong>__new__</strong> = &lt;built-in method __new__ of type object&gt;<dd><tt>T.<a href="#ParseBaseException-__new__">__new__</a>(S,&nbsp;...)&nbsp;-&gt;&nbsp;a&nbsp;new&nbsp;<a href="__builtin__.html#object">object</a>&nbsp;with&nbsp;type&nbsp;S,&nbsp;a&nbsp;subtype&nbsp;of&nbsp;T</tt></dl>

<hr>
Methods inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><a name="ParseBaseException-__delattr__"><strong>__delattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseBaseException-__delattr__">__delattr__</a>('name')&nbsp;&lt;==&gt;&nbsp;del&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseBaseException-__getattribute__"><strong>__getattribute__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseBaseException-__getattribute__">__getattribute__</a>('name')&nbsp;&lt;==&gt;&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseBaseException-__getitem__"><strong>__getitem__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseBaseException-__getitem__">__getitem__</a>(y)&nbsp;&lt;==&gt;&nbsp;x[y]</tt></dd></dl>

<dl><dt><a name="ParseBaseException-__getslice__"><strong>__getslice__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseBaseException-__getslice__">__getslice__</a>(i,&nbsp;j)&nbsp;&lt;==&gt;&nbsp;x[i:j]<br>
&nbsp;<br>
Use&nbsp;of&nbsp;negative&nbsp;indices&nbsp;is&nbsp;not&nbsp;supported.</tt></dd></dl>

<dl><dt><a name="ParseBaseException-__reduce__"><strong>__reduce__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseBaseException-__setattr__"><strong>__setattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseBaseException-__setattr__">__setattr__</a>('name',&nbsp;value)&nbsp;&lt;==&gt;&nbsp;x.name&nbsp;=&nbsp;value</tt></dd></dl>

<dl><dt><a name="ParseBaseException-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseBaseException-__unicode__"><strong>__unicode__</strong></a>(...)</dt></dl>

<hr>
Data descriptors inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
<dl><dt><strong>message</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParseElementEnhance">class <strong>ParseElementEnhance</strong></a>(<a href="pyparsing.html#ParserElement">ParserElement</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;subclass&nbsp;of&nbsp;C{<a href="#ParserElement">ParserElement</a>},&nbsp;for&nbsp;combining&nbsp;and&nbsp;post-processing&nbsp;parsed&nbsp;tokens.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ParseElementEnhance-__init__"><strong>__init__</strong></a>(self, expr, savelist<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseElementEnhance-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="ParseElementEnhance-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseElementEnhance-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseElementEnhance-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="ParseElementEnhance-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseElementEnhance-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="ParseElementEnhance-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#ParseElementEnhance-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#ParseElementEnhance-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseElementEnhance-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="ParseElementEnhance-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="ParseElementEnhance-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#ParseElementEnhance-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#ParseElementEnhance-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#ParseElementEnhance-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="ParseElementEnhance-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#ParseElementEnhance-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#ParseElementEnhance-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="ParseElementEnhance-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="ParseElementEnhance-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParseException">class <strong>ParseException</strong></a>(<a href="pyparsing.html#ParseBaseException">ParseBaseException</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>exception&nbsp;thrown&nbsp;when&nbsp;parse&nbsp;expressions&nbsp;don't&nbsp;match&nbsp;class;<br>
supported&nbsp;attributes&nbsp;by&nbsp;name&nbsp;are:<br>
&nbsp;-&nbsp;lineno&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
&nbsp;-&nbsp;col&nbsp;-&nbsp;returns&nbsp;the&nbsp;column&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
&nbsp;-&nbsp;line&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;containing&nbsp;the&nbsp;exception&nbsp;text<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#ParseException">ParseException</a></dd>
<dd><a href="pyparsing.html#ParseBaseException">ParseBaseException</a></dd>
<dd><a href="exceptions.html#Exception">exceptions.Exception</a></dd>
<dd><a href="exceptions.html#BaseException">exceptions.BaseException</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="pyparsing.html#ParseBaseException">ParseBaseException</a>:<br>
<dl><dt><a name="ParseException-__dir__"><strong>__dir__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseException-__getattr__"><strong>__getattr__</strong></a>(self, aname)</dt><dd><tt>supported&nbsp;attributes&nbsp;by&nbsp;name&nbsp;are:<br>
-&nbsp;lineno&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;col&nbsp;-&nbsp;returns&nbsp;the&nbsp;column&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;line&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;containing&nbsp;the&nbsp;exception&nbsp;text</tt></dd></dl>

<dl><dt><a name="ParseException-__init__"><strong>__init__</strong></a>(self, pstr, loc<font color="#909090">=0</font>, msg<font color="#909090">=None</font>, elem<font color="#909090">=None</font>)</dt><dd><tt>#&nbsp;Performance&nbsp;tuning:&nbsp;we&nbsp;construct&nbsp;a&nbsp;*lot*&nbsp;of&nbsp;these,&nbsp;so&nbsp;keep&nbsp;this<br>
#&nbsp;constructor&nbsp;as&nbsp;small&nbsp;and&nbsp;fast&nbsp;as&nbsp;possible</tt></dd></dl>

<dl><dt><a name="ParseException-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseException-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseException-markInputline"><strong>markInputline</strong></a>(self, markerString<font color="#909090">='&gt;!&lt;'</font>)</dt><dd><tt>Extracts&nbsp;the&nbsp;exception&nbsp;line&nbsp;from&nbsp;the&nbsp;input&nbsp;string,&nbsp;and&nbsp;marks<br>
the&nbsp;location&nbsp;of&nbsp;the&nbsp;exception&nbsp;with&nbsp;a&nbsp;special&nbsp;symbol.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParseBaseException">ParseBaseException</a>:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><strong>__new__</strong> = &lt;built-in method __new__ of type object&gt;<dd><tt>T.<a href="#ParseException-__new__">__new__</a>(S,&nbsp;...)&nbsp;-&gt;&nbsp;a&nbsp;new&nbsp;<a href="__builtin__.html#object">object</a>&nbsp;with&nbsp;type&nbsp;S,&nbsp;a&nbsp;subtype&nbsp;of&nbsp;T</tt></dl>

<hr>
Methods inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><a name="ParseException-__delattr__"><strong>__delattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseException-__delattr__">__delattr__</a>('name')&nbsp;&lt;==&gt;&nbsp;del&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseException-__getattribute__"><strong>__getattribute__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseException-__getattribute__">__getattribute__</a>('name')&nbsp;&lt;==&gt;&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseException-__getitem__"><strong>__getitem__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseException-__getitem__">__getitem__</a>(y)&nbsp;&lt;==&gt;&nbsp;x[y]</tt></dd></dl>

<dl><dt><a name="ParseException-__getslice__"><strong>__getslice__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseException-__getslice__">__getslice__</a>(i,&nbsp;j)&nbsp;&lt;==&gt;&nbsp;x[i:j]<br>
&nbsp;<br>
Use&nbsp;of&nbsp;negative&nbsp;indices&nbsp;is&nbsp;not&nbsp;supported.</tt></dd></dl>

<dl><dt><a name="ParseException-__reduce__"><strong>__reduce__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseException-__setattr__"><strong>__setattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseException-__setattr__">__setattr__</a>('name',&nbsp;value)&nbsp;&lt;==&gt;&nbsp;x.name&nbsp;=&nbsp;value</tt></dd></dl>

<dl><dt><a name="ParseException-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseException-__unicode__"><strong>__unicode__</strong></a>(...)</dt></dl>

<hr>
Data descriptors inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
<dl><dt><strong>message</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParseExpression">class <strong>ParseExpression</strong></a>(<a href="pyparsing.html#ParserElement">ParserElement</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;subclass&nbsp;of&nbsp;<a href="#ParserElement">ParserElement</a>,&nbsp;for&nbsp;combining&nbsp;and&nbsp;post-processing&nbsp;parsed&nbsp;tokens.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#ParseExpression">ParseExpression</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ParseExpression-__getitem__"><strong>__getitem__</strong></a>(self, i)</dt></dl>

<dl><dt><a name="ParseExpression-__init__"><strong>__init__</strong></a>(self, exprs, savelist<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="ParseExpression-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseExpression-append"><strong>append</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseExpression-copy"><strong>copy</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseExpression-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseExpression-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Extends&nbsp;C{leaveWhitespace}&nbsp;defined&nbsp;in&nbsp;base&nbsp;class,&nbsp;and&nbsp;also&nbsp;invokes&nbsp;C{leaveWhitespace}&nbsp;on<br>
all&nbsp;contained&nbsp;expressions.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="ParseExpression-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseExpression-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="ParseExpression-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#ParseExpression-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#ParseExpression-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="ParseExpression-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseExpression-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseExpression-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseExpression-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseExpression-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseExpression-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseExpression-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseExpression-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="ParseExpression-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="ParseExpression-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="ParseExpression-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="ParseExpression-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="ParseExpression-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="ParseExpression-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="ParseExpression-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="ParseExpression-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="ParseExpression-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="ParseExpression-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="ParseExpression-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="ParseExpression-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="ParseExpression-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ParseExpression-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="ParseExpression-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="ParseExpression-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#ParseExpression-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#ParseExpression-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ParseExpression-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="ParseExpression-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#ParseExpression-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#ParseExpression-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="ParseExpression-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="ParseExpression-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="ParseExpression-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParseFatalException">class <strong>ParseFatalException</strong></a>(<a href="pyparsing.html#ParseBaseException">ParseBaseException</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>user-throwable&nbsp;exception&nbsp;thrown&nbsp;when&nbsp;inconsistent&nbsp;parse&nbsp;content<br>
is&nbsp;found;&nbsp;stops&nbsp;all&nbsp;parsing&nbsp;immediately<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#ParseFatalException">ParseFatalException</a></dd>
<dd><a href="pyparsing.html#ParseBaseException">ParseBaseException</a></dd>
<dd><a href="exceptions.html#Exception">exceptions.Exception</a></dd>
<dd><a href="exceptions.html#BaseException">exceptions.BaseException</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods inherited from <a href="pyparsing.html#ParseBaseException">ParseBaseException</a>:<br>
<dl><dt><a name="ParseFatalException-__dir__"><strong>__dir__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseFatalException-__getattr__"><strong>__getattr__</strong></a>(self, aname)</dt><dd><tt>supported&nbsp;attributes&nbsp;by&nbsp;name&nbsp;are:<br>
-&nbsp;lineno&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;col&nbsp;-&nbsp;returns&nbsp;the&nbsp;column&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;line&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;containing&nbsp;the&nbsp;exception&nbsp;text</tt></dd></dl>

<dl><dt><a name="ParseFatalException-__init__"><strong>__init__</strong></a>(self, pstr, loc<font color="#909090">=0</font>, msg<font color="#909090">=None</font>, elem<font color="#909090">=None</font>)</dt><dd><tt>#&nbsp;Performance&nbsp;tuning:&nbsp;we&nbsp;construct&nbsp;a&nbsp;*lot*&nbsp;of&nbsp;these,&nbsp;so&nbsp;keep&nbsp;this<br>
#&nbsp;constructor&nbsp;as&nbsp;small&nbsp;and&nbsp;fast&nbsp;as&nbsp;possible</tt></dd></dl>

<dl><dt><a name="ParseFatalException-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseFatalException-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseFatalException-markInputline"><strong>markInputline</strong></a>(self, markerString<font color="#909090">='&gt;!&lt;'</font>)</dt><dd><tt>Extracts&nbsp;the&nbsp;exception&nbsp;line&nbsp;from&nbsp;the&nbsp;input&nbsp;string,&nbsp;and&nbsp;marks<br>
the&nbsp;location&nbsp;of&nbsp;the&nbsp;exception&nbsp;with&nbsp;a&nbsp;special&nbsp;symbol.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParseBaseException">ParseBaseException</a>:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><strong>__new__</strong> = &lt;built-in method __new__ of type object&gt;<dd><tt>T.<a href="#ParseFatalException-__new__">__new__</a>(S,&nbsp;...)&nbsp;-&gt;&nbsp;a&nbsp;new&nbsp;<a href="__builtin__.html#object">object</a>&nbsp;with&nbsp;type&nbsp;S,&nbsp;a&nbsp;subtype&nbsp;of&nbsp;T</tt></dl>

<hr>
Methods inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><a name="ParseFatalException-__delattr__"><strong>__delattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseFatalException-__delattr__">__delattr__</a>('name')&nbsp;&lt;==&gt;&nbsp;del&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseFatalException-__getattribute__"><strong>__getattribute__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseFatalException-__getattribute__">__getattribute__</a>('name')&nbsp;&lt;==&gt;&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseFatalException-__getitem__"><strong>__getitem__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseFatalException-__getitem__">__getitem__</a>(y)&nbsp;&lt;==&gt;&nbsp;x[y]</tt></dd></dl>

<dl><dt><a name="ParseFatalException-__getslice__"><strong>__getslice__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseFatalException-__getslice__">__getslice__</a>(i,&nbsp;j)&nbsp;&lt;==&gt;&nbsp;x[i:j]<br>
&nbsp;<br>
Use&nbsp;of&nbsp;negative&nbsp;indices&nbsp;is&nbsp;not&nbsp;supported.</tt></dd></dl>

<dl><dt><a name="ParseFatalException-__reduce__"><strong>__reduce__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseFatalException-__setattr__"><strong>__setattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseFatalException-__setattr__">__setattr__</a>('name',&nbsp;value)&nbsp;&lt;==&gt;&nbsp;x.name&nbsp;=&nbsp;value</tt></dd></dl>

<dl><dt><a name="ParseFatalException-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseFatalException-__unicode__"><strong>__unicode__</strong></a>(...)</dt></dl>

<hr>
Data descriptors inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
<dl><dt><strong>message</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParseResults">class <strong>ParseResults</strong></a>(<a href="__builtin__.html#object">__builtin__.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Structured&nbsp;parse&nbsp;results,&nbsp;to&nbsp;provide&nbsp;multiple&nbsp;means&nbsp;of&nbsp;access&nbsp;to&nbsp;the&nbsp;parsed&nbsp;data:<br>
-&nbsp;as&nbsp;a&nbsp;list&nbsp;(C{len(results)})<br>
-&nbsp;by&nbsp;list&nbsp;index&nbsp;(C{results[0],&nbsp;results[1]},&nbsp;etc.)<br>
-&nbsp;by&nbsp;attribute&nbsp;(C{results.&lt;resultsName&gt;})<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="ParseResults-__add__"><strong>__add__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseResults-__bool__"><strong>__bool__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-__contains__"><strong>__contains__</strong></a>(self, k)</dt></dl>

<dl><dt><a name="ParseResults-__delitem__"><strong>__delitem__</strong></a>(self, i)</dt></dl>

<dl><dt><a name="ParseResults-__dir__"><strong>__dir__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-__getattr__"><strong>__getattr__</strong></a>(self, name)</dt></dl>

<dl><dt><a name="ParseResults-__getitem__"><strong>__getitem__</strong></a>(self, i)</dt></dl>

<dl><dt><a name="ParseResults-__getstate__"><strong>__getstate__</strong></a>(self)</dt><dd><tt>#&nbsp;add&nbsp;support&nbsp;for&nbsp;pickle&nbsp;protocol</tt></dd></dl>

<dl><dt><a name="ParseResults-__iadd__"><strong>__iadd__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseResults-__init__"><strong>__init__</strong></a>(self, toklist, name<font color="#909090">=None</font>, asList<font color="#909090">=True</font>, modal<font color="#909090">=True</font>, isinstance<font color="#909090">=&lt;built-in function isinstance&gt;</font>)</dt><dd><tt>#&nbsp;Performance&nbsp;tuning:&nbsp;we&nbsp;construct&nbsp;a&nbsp;*lot*&nbsp;of&nbsp;these,&nbsp;so&nbsp;keep&nbsp;this<br>
#&nbsp;constructor&nbsp;as&nbsp;small&nbsp;and&nbsp;fast&nbsp;as&nbsp;possible</tt></dd></dl>

<dl><dt><a name="ParseResults-__iter__"><strong>__iter__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-__len__"><strong>__len__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-__nonzero__"><strong>__nonzero__</strong></a> = <a href="#ParseResults-__bool__">__bool__</a>(self)</dt></dl>

<dl><dt><a name="ParseResults-__radd__"><strong>__radd__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParseResults-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-__reversed__"><strong>__reversed__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-__setitem__"><strong>__setitem__</strong></a>(self, k, v, isinstance<font color="#909090">=&lt;built-in function isinstance&gt;</font>)</dt></dl>

<dl><dt><a name="ParseResults-__setstate__"><strong>__setstate__</strong></a>(self, state)</dt></dl>

<dl><dt><a name="ParseResults-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-append"><strong>append</strong></a>(self, item)</dt><dd><tt>Add&nbsp;single&nbsp;element&nbsp;to&nbsp;end&nbsp;of&nbsp;<a href="#ParseResults">ParseResults</a>&nbsp;list&nbsp;of&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="ParseResults-asDict"><strong>asDict</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;named&nbsp;parse&nbsp;results&nbsp;as&nbsp;dictionary.</tt></dd></dl>

<dl><dt><a name="ParseResults-asList"><strong>asList</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;parse&nbsp;results&nbsp;as&nbsp;a&nbsp;nested&nbsp;list&nbsp;of&nbsp;matching&nbsp;tokens,&nbsp;all&nbsp;converted&nbsp;to&nbsp;strings.</tt></dd></dl>

<dl><dt><a name="ParseResults-asXML"><strong>asXML</strong></a>(self, doctag<font color="#909090">=None</font>, namedItemsOnly<font color="#909090">=False</font>, indent<font color="#909090">=''</font>, formatted<font color="#909090">=True</font>)</dt><dd><tt>Returns&nbsp;the&nbsp;parse&nbsp;results&nbsp;as&nbsp;XML.&nbsp;Tags&nbsp;are&nbsp;created&nbsp;for&nbsp;tokens&nbsp;and&nbsp;lists&nbsp;that&nbsp;have&nbsp;defined&nbsp;results&nbsp;names.</tt></dd></dl>

<dl><dt><a name="ParseResults-clear"><strong>clear</strong></a>(self)</dt><dd><tt>Clear&nbsp;all&nbsp;elements&nbsp;and&nbsp;results&nbsp;names.</tt></dd></dl>

<dl><dt><a name="ParseResults-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Returns&nbsp;a&nbsp;new&nbsp;copy&nbsp;of&nbsp;a&nbsp;C{<a href="#ParseResults">ParseResults</a>}&nbsp;<a href="__builtin__.html#object">object</a>.</tt></dd></dl>

<dl><dt><a name="ParseResults-dump"><strong>dump</strong></a>(self, indent<font color="#909090">=''</font>, depth<font color="#909090">=0</font>)</dt><dd><tt>Diagnostic&nbsp;method&nbsp;for&nbsp;listing&nbsp;out&nbsp;the&nbsp;contents&nbsp;of&nbsp;a&nbsp;C{<a href="#ParseResults">ParseResults</a>}.<br>
Accepts&nbsp;an&nbsp;optional&nbsp;C{indent}&nbsp;argument&nbsp;so&nbsp;that&nbsp;this&nbsp;string&nbsp;can&nbsp;be&nbsp;embedded<br>
in&nbsp;a&nbsp;nested&nbsp;display&nbsp;of&nbsp;other&nbsp;data.</tt></dd></dl>

<dl><dt><a name="ParseResults-extend"><strong>extend</strong></a>(self, itemseq)</dt><dd><tt>Add&nbsp;sequence&nbsp;of&nbsp;elements&nbsp;to&nbsp;end&nbsp;of&nbsp;<a href="#ParseResults">ParseResults</a>&nbsp;list&nbsp;of&nbsp;elements.</tt></dd></dl>

<dl><dt><a name="ParseResults-get"><strong>get</strong></a>(self, key, defaultValue<font color="#909090">=None</font>)</dt><dd><tt>Returns&nbsp;named&nbsp;result&nbsp;matching&nbsp;the&nbsp;given&nbsp;key,&nbsp;or&nbsp;if&nbsp;there&nbsp;is&nbsp;no<br>
such&nbsp;name,&nbsp;then&nbsp;returns&nbsp;the&nbsp;given&nbsp;C{defaultValue}&nbsp;or&nbsp;C{None}&nbsp;if&nbsp;no<br>
C{defaultValue}&nbsp;is&nbsp;specified.</tt></dd></dl>

<dl><dt><a name="ParseResults-getName"><strong>getName</strong></a>(self)</dt><dd><tt>Returns&nbsp;the&nbsp;results&nbsp;name&nbsp;for&nbsp;this&nbsp;token&nbsp;expression.</tt></dd></dl>

<dl><dt><a name="ParseResults-haskeys"><strong>haskeys</strong></a>(self)</dt><dd><tt>Since&nbsp;<a href="#ParseResults-keys">keys</a>()&nbsp;returns&nbsp;an&nbsp;iterator,&nbsp;this&nbsp;method&nbsp;is&nbsp;helpful&nbsp;in&nbsp;bypassing<br>
code&nbsp;that&nbsp;looks&nbsp;for&nbsp;the&nbsp;existence&nbsp;of&nbsp;any&nbsp;defined&nbsp;results&nbsp;names.</tt></dd></dl>

<dl><dt><a name="ParseResults-insert"><strong>insert</strong></a>(self, index, insStr)</dt><dd><tt>Inserts&nbsp;new&nbsp;element&nbsp;at&nbsp;location&nbsp;index&nbsp;in&nbsp;the&nbsp;list&nbsp;of&nbsp;parsed&nbsp;tokens.</tt></dd></dl>

<dl><dt><a name="ParseResults-items"><strong>items</strong></a>(self)</dt><dd><tt>Returns&nbsp;all&nbsp;named&nbsp;result&nbsp;keys&nbsp;and&nbsp;values&nbsp;as&nbsp;a&nbsp;list&nbsp;of&nbsp;tuples.</tt></dd></dl>

<dl><dt><a name="ParseResults-iteritems"><strong>iteritems</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseResults-iterkeys"><strong>iterkeys</strong></a>(self)</dt><dd><tt>Returns&nbsp;all&nbsp;named&nbsp;result&nbsp;keys.</tt></dd></dl>

<dl><dt><a name="ParseResults-itervalues"><strong>itervalues</strong></a>(self)</dt><dd><tt>Returns&nbsp;all&nbsp;named&nbsp;result&nbsp;values.</tt></dd></dl>

<dl><dt><a name="ParseResults-keys"><strong>keys</strong></a>(self)</dt><dd><tt>Returns&nbsp;all&nbsp;named&nbsp;result&nbsp;keys.</tt></dd></dl>

<dl><dt><a name="ParseResults-pop"><strong>pop</strong></a>(self, *args, **kwargs)</dt><dd><tt>Removes&nbsp;and&nbsp;returns&nbsp;item&nbsp;at&nbsp;specified&nbsp;index&nbsp;(default=last).<br>
Supports&nbsp;both&nbsp;list&nbsp;and&nbsp;dict&nbsp;semantics&nbsp;for&nbsp;<a href="#ParseResults-pop">pop</a>().&nbsp;If&nbsp;passed&nbsp;no<br>
argument&nbsp;or&nbsp;an&nbsp;integer&nbsp;argument,&nbsp;it&nbsp;will&nbsp;use&nbsp;list&nbsp;semantics<br>
and&nbsp;pop&nbsp;tokens&nbsp;from&nbsp;the&nbsp;list&nbsp;of&nbsp;parsed&nbsp;tokens.&nbsp;If&nbsp;passed&nbsp;a&nbsp;<br>
non-integer&nbsp;argument&nbsp;(most&nbsp;likely&nbsp;a&nbsp;string),&nbsp;it&nbsp;will&nbsp;use&nbsp;dict<br>
semantics&nbsp;and&nbsp;pop&nbsp;the&nbsp;corresponding&nbsp;value&nbsp;from&nbsp;any&nbsp;defined&nbsp;<br>
results&nbsp;names.&nbsp;A&nbsp;second&nbsp;default&nbsp;return&nbsp;value&nbsp;argument&nbsp;is&nbsp;<br>
supported,&nbsp;just&nbsp;as&nbsp;in&nbsp;dict.<a href="#ParseResults-pop">pop</a>().</tt></dd></dl>

<dl><dt><a name="ParseResults-pprint"><strong>pprint</strong></a>(self, *args, **kwargs)</dt><dd><tt>Pretty-printer&nbsp;for&nbsp;parsed&nbsp;results&nbsp;as&nbsp;a&nbsp;list,&nbsp;using&nbsp;the&nbsp;C{pprint}&nbsp;module.<br>
Accepts&nbsp;additional&nbsp;positional&nbsp;or&nbsp;keyword&nbsp;args&nbsp;as&nbsp;defined&nbsp;for&nbsp;the&nbsp;<br>
C{pprint.pprint}&nbsp;method.&nbsp;(U{<a href="http://docs.python.org/3/library/pprint.html#pprint.pprint">http://docs.python.org/3/library/pprint.html#pprint.pprint</a>})</tt></dd></dl>

<dl><dt><a name="ParseResults-values"><strong>values</strong></a>(self)</dt><dd><tt>Returns&nbsp;all&nbsp;named&nbsp;result&nbsp;values.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="ParseResults-__new__"><strong>__new__</strong></a>(cls, toklist, name<font color="#909090">=None</font>, asList<font color="#909090">=True</font>, modal<font color="#909090">=True</font>)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParseSyntaxException">class <strong>ParseSyntaxException</strong></a>(<a href="pyparsing.html#ParseFatalException">ParseFatalException</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>just&nbsp;like&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}},&nbsp;but&nbsp;thrown&nbsp;internally&nbsp;when&nbsp;an<br>
C{L{ErrorStop&lt;<a href="#And">And</a>._ErrorStop&gt;}}&nbsp;('-'&nbsp;operator)&nbsp;indicates&nbsp;that&nbsp;parsing&nbsp;is&nbsp;to&nbsp;stop&nbsp;immediately&nbsp;because<br>
an&nbsp;unbacktrackable&nbsp;syntax&nbsp;error&nbsp;has&nbsp;been&nbsp;found<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#ParseSyntaxException">ParseSyntaxException</a></dd>
<dd><a href="pyparsing.html#ParseFatalException">ParseFatalException</a></dd>
<dd><a href="pyparsing.html#ParseBaseException">ParseBaseException</a></dd>
<dd><a href="exceptions.html#Exception">exceptions.Exception</a></dd>
<dd><a href="exceptions.html#BaseException">exceptions.BaseException</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ParseSyntaxException-__init__"><strong>__init__</strong></a>(self, pe)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseBaseException">ParseBaseException</a>:<br>
<dl><dt><a name="ParseSyntaxException-__dir__"><strong>__dir__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseSyntaxException-__getattr__"><strong>__getattr__</strong></a>(self, aname)</dt><dd><tt>supported&nbsp;attributes&nbsp;by&nbsp;name&nbsp;are:<br>
-&nbsp;lineno&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;col&nbsp;-&nbsp;returns&nbsp;the&nbsp;column&nbsp;number&nbsp;of&nbsp;the&nbsp;exception&nbsp;text<br>
-&nbsp;line&nbsp;-&nbsp;returns&nbsp;the&nbsp;line&nbsp;containing&nbsp;the&nbsp;exception&nbsp;text</tt></dd></dl>

<dl><dt><a name="ParseSyntaxException-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseSyntaxException-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParseSyntaxException-markInputline"><strong>markInputline</strong></a>(self, markerString<font color="#909090">='&gt;!&lt;'</font>)</dt><dd><tt>Extracts&nbsp;the&nbsp;exception&nbsp;line&nbsp;from&nbsp;the&nbsp;input&nbsp;string,&nbsp;and&nbsp;marks<br>
the&nbsp;location&nbsp;of&nbsp;the&nbsp;exception&nbsp;with&nbsp;a&nbsp;special&nbsp;symbol.</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParseBaseException">ParseBaseException</a>:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><strong>__new__</strong> = &lt;built-in method __new__ of type object&gt;<dd><tt>T.<a href="#ParseSyntaxException-__new__">__new__</a>(S,&nbsp;...)&nbsp;-&gt;&nbsp;a&nbsp;new&nbsp;<a href="__builtin__.html#object">object</a>&nbsp;with&nbsp;type&nbsp;S,&nbsp;a&nbsp;subtype&nbsp;of&nbsp;T</tt></dl>

<hr>
Methods inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><a name="ParseSyntaxException-__delattr__"><strong>__delattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseSyntaxException-__delattr__">__delattr__</a>('name')&nbsp;&lt;==&gt;&nbsp;del&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseSyntaxException-__getattribute__"><strong>__getattribute__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseSyntaxException-__getattribute__">__getattribute__</a>('name')&nbsp;&lt;==&gt;&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="ParseSyntaxException-__getitem__"><strong>__getitem__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseSyntaxException-__getitem__">__getitem__</a>(y)&nbsp;&lt;==&gt;&nbsp;x[y]</tt></dd></dl>

<dl><dt><a name="ParseSyntaxException-__getslice__"><strong>__getslice__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseSyntaxException-__getslice__">__getslice__</a>(i,&nbsp;j)&nbsp;&lt;==&gt;&nbsp;x[i:j]<br>
&nbsp;<br>
Use&nbsp;of&nbsp;negative&nbsp;indices&nbsp;is&nbsp;not&nbsp;supported.</tt></dd></dl>

<dl><dt><a name="ParseSyntaxException-__reduce__"><strong>__reduce__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseSyntaxException-__setattr__"><strong>__setattr__</strong></a>(...)</dt><dd><tt>x.<a href="#ParseSyntaxException-__setattr__">__setattr__</a>('name',&nbsp;value)&nbsp;&lt;==&gt;&nbsp;x.name&nbsp;=&nbsp;value</tt></dd></dl>

<dl><dt><a name="ParseSyntaxException-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="ParseSyntaxException-__unicode__"><strong>__unicode__</strong></a>(...)</dt></dl>

<hr>
Data descriptors inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
<dl><dt><strong>message</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ParserElement">class <strong>ParserElement</strong></a>(<a href="__builtin__.html#object">__builtin__.object</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;base&nbsp;level&nbsp;parser&nbsp;element&nbsp;class.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%">Methods defined here:<br>
<dl><dt><a name="ParserElement-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#ParserElement-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#ParserElement-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="ParserElement-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParserElement-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParserElement-__init__"><strong>__init__</strong></a>(self, savelist<font color="#909090">=False</font>)</dt></dl>

<dl><dt><a name="ParserElement-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="ParserElement-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParserElement-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParserElement-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParserElement-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParserElement-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ParserElement-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ParserElement-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="ParserElement-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="ParserElement-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="ParserElement-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="ParserElement-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="ParserElement-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="ParserElement-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="ParserElement-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="ParserElement-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="ParserElement-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="ParserElement-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="ParserElement-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="ParserElement-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="ParserElement-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="ParserElement-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="ParserElement-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="ParserElement-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="ParserElement-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="ParserElement-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="ParserElement-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="ParserElement-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="ParserElement-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="ParserElement-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ParserElement-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#ParserElement-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="ParserElement-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="ParserElement-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="ParserElement-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="ParserElement-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#ParserElement-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#ParserElement-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ParserElement-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="ParserElement-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods defined here:<br>
<dl><dt><a name="ParserElement-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#ParserElement-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#ParserElement-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="ParserElement-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="ParserElement-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="ParserElement-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="QuotedString">class <strong>QuotedString</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;for&nbsp;matching&nbsp;strings&nbsp;that&nbsp;are&nbsp;delimited&nbsp;by&nbsp;quoting&nbsp;characters.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#QuotedString">QuotedString</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="QuotedString-__init__"><strong>__init__</strong></a>(self, quoteChar, escChar<font color="#909090">=None</font>, escQuote<font color="#909090">=None</font>, multiline<font color="#909090">=False</font>, unquoteResults<font color="#909090">=True</font>, endQuoteChar<font color="#909090">=None</font>)</dt><dd><tt>Defined&nbsp;with&nbsp;the&nbsp;following&nbsp;parameters:<br>
&nbsp;-&nbsp;quoteChar&nbsp;-&nbsp;string&nbsp;of&nbsp;one&nbsp;or&nbsp;more&nbsp;characters&nbsp;defining&nbsp;the&nbsp;quote&nbsp;delimiting&nbsp;string<br>
&nbsp;-&nbsp;escChar&nbsp;-&nbsp;character&nbsp;to&nbsp;escape&nbsp;quotes,&nbsp;typically&nbsp;backslash&nbsp;(default=None)<br>
&nbsp;-&nbsp;escQuote&nbsp;-&nbsp;special&nbsp;quote&nbsp;sequence&nbsp;to&nbsp;escape&nbsp;an&nbsp;embedded&nbsp;quote&nbsp;string&nbsp;(such&nbsp;as&nbsp;SQL's&nbsp;""&nbsp;to&nbsp;escape&nbsp;an&nbsp;embedded&nbsp;")&nbsp;(default=None)<br>
&nbsp;-&nbsp;multiline&nbsp;-&nbsp;boolean&nbsp;indicating&nbsp;whether&nbsp;quotes&nbsp;can&nbsp;span&nbsp;multiple&nbsp;lines&nbsp;(default=C{False})<br>
&nbsp;-&nbsp;unquoteResults&nbsp;-&nbsp;boolean&nbsp;indicating&nbsp;whether&nbsp;the&nbsp;matched&nbsp;text&nbsp;should&nbsp;be&nbsp;unquoted&nbsp;(default=C{True})<br>
&nbsp;-&nbsp;endQuoteChar&nbsp;-&nbsp;string&nbsp;of&nbsp;one&nbsp;or&nbsp;more&nbsp;characters&nbsp;defining&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;quote&nbsp;delimited&nbsp;string&nbsp;(default=C{None}&nbsp;=&gt;&nbsp;same&nbsp;as&nbsp;quoteChar)</tt></dd></dl>

<dl><dt><a name="QuotedString-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="QuotedString-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="QuotedString-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#QuotedString-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#QuotedString-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="QuotedString-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="QuotedString-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="QuotedString-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="QuotedString-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="QuotedString-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="QuotedString-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="QuotedString-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="QuotedString-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="QuotedString-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="QuotedString-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="QuotedString-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="QuotedString-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="QuotedString-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="QuotedString-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="QuotedString-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="QuotedString-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="QuotedString-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="QuotedString-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="QuotedString-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="QuotedString-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="QuotedString-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="QuotedString-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="QuotedString-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="QuotedString-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="QuotedString-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="QuotedString-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="QuotedString-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="QuotedString-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="QuotedString-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="QuotedString-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="QuotedString-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#QuotedString-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="QuotedString-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="QuotedString-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="QuotedString-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="QuotedString-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#QuotedString-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#QuotedString-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="QuotedString-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="QuotedString-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="QuotedString-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#QuotedString-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#QuotedString-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="QuotedString-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="QuotedString-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="QuotedString-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="RecursiveGrammarException">class <strong>RecursiveGrammarException</strong></a>(<a href="exceptions.html#Exception">exceptions.Exception</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>exception&nbsp;thrown&nbsp;by&nbsp;C{validate()}&nbsp;if&nbsp;the&nbsp;grammar&nbsp;could&nbsp;be&nbsp;improperly&nbsp;recursive<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#RecursiveGrammarException">RecursiveGrammarException</a></dd>
<dd><a href="exceptions.html#Exception">exceptions.Exception</a></dd>
<dd><a href="exceptions.html#BaseException">exceptions.BaseException</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="RecursiveGrammarException-__init__"><strong>__init__</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="RecursiveGrammarException-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<hr>
Data descriptors defined here:<br>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="exceptions.html#Exception">exceptions.Exception</a>:<br>
<dl><dt><strong>__new__</strong> = &lt;built-in method __new__ of type object&gt;<dd><tt>T.<a href="#RecursiveGrammarException-__new__">__new__</a>(S,&nbsp;...)&nbsp;-&gt;&nbsp;a&nbsp;new&nbsp;<a href="__builtin__.html#object">object</a>&nbsp;with&nbsp;type&nbsp;S,&nbsp;a&nbsp;subtype&nbsp;of&nbsp;T</tt></dl>

<hr>
Methods inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><a name="RecursiveGrammarException-__delattr__"><strong>__delattr__</strong></a>(...)</dt><dd><tt>x.<a href="#RecursiveGrammarException-__delattr__">__delattr__</a>('name')&nbsp;&lt;==&gt;&nbsp;del&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="RecursiveGrammarException-__getattribute__"><strong>__getattribute__</strong></a>(...)</dt><dd><tt>x.<a href="#RecursiveGrammarException-__getattribute__">__getattribute__</a>('name')&nbsp;&lt;==&gt;&nbsp;x.name</tt></dd></dl>

<dl><dt><a name="RecursiveGrammarException-__getitem__"><strong>__getitem__</strong></a>(...)</dt><dd><tt>x.<a href="#RecursiveGrammarException-__getitem__">__getitem__</a>(y)&nbsp;&lt;==&gt;&nbsp;x[y]</tt></dd></dl>

<dl><dt><a name="RecursiveGrammarException-__getslice__"><strong>__getslice__</strong></a>(...)</dt><dd><tt>x.<a href="#RecursiveGrammarException-__getslice__">__getslice__</a>(i,&nbsp;j)&nbsp;&lt;==&gt;&nbsp;x[i:j]<br>
&nbsp;<br>
Use&nbsp;of&nbsp;negative&nbsp;indices&nbsp;is&nbsp;not&nbsp;supported.</tt></dd></dl>

<dl><dt><a name="RecursiveGrammarException-__reduce__"><strong>__reduce__</strong></a>(...)</dt></dl>

<dl><dt><a name="RecursiveGrammarException-__repr__"><strong>__repr__</strong></a>(...)</dt><dd><tt>x.<a href="#RecursiveGrammarException-__repr__">__repr__</a>()&nbsp;&lt;==&gt;&nbsp;repr(x)</tt></dd></dl>

<dl><dt><a name="RecursiveGrammarException-__setattr__"><strong>__setattr__</strong></a>(...)</dt><dd><tt>x.<a href="#RecursiveGrammarException-__setattr__">__setattr__</a>('name',&nbsp;value)&nbsp;&lt;==&gt;&nbsp;x.name&nbsp;=&nbsp;value</tt></dd></dl>

<dl><dt><a name="RecursiveGrammarException-__setstate__"><strong>__setstate__</strong></a>(...)</dt></dl>

<dl><dt><a name="RecursiveGrammarException-__unicode__"><strong>__unicode__</strong></a>(...)</dt></dl>

<hr>
Data descriptors inherited from <a href="exceptions.html#BaseException">exceptions.BaseException</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
</dl>
<dl><dt><strong>args</strong></dt>
</dl>
<dl><dt><strong>message</strong></dt>
</dl>
</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Regex">class <strong>Regex</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;for&nbsp;matching&nbsp;strings&nbsp;that&nbsp;match&nbsp;a&nbsp;given&nbsp;regular&nbsp;expression.<br>
Defined&nbsp;with&nbsp;string&nbsp;specifying&nbsp;the&nbsp;regular&nbsp;expression&nbsp;in&nbsp;a&nbsp;form&nbsp;recognized&nbsp;by&nbsp;the&nbsp;inbuilt&nbsp;Python&nbsp;re&nbsp;module.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Regex">Regex</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Regex-__init__"><strong>__init__</strong></a>(self, pattern, flags<font color="#909090">=0</font>)</dt><dd><tt>The&nbsp;parameters&nbsp;C{pattern}&nbsp;and&nbsp;C{flags}&nbsp;are&nbsp;passed&nbsp;to&nbsp;the&nbsp;C{re.compile()}&nbsp;function&nbsp;as-is.&nbsp;See&nbsp;the&nbsp;Python&nbsp;C{re}&nbsp;module&nbsp;for&nbsp;an&nbsp;explanation&nbsp;of&nbsp;the&nbsp;acceptable&nbsp;patterns&nbsp;and&nbsp;flags.</tt></dd></dl>

<dl><dt><a name="Regex-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Regex-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<dl><dt><strong>compiledREtype</strong> = &lt;type '_sre.SRE_Pattern'&gt;<dd><tt>Compiled&nbsp;regular&nbsp;expression&nbsp;objects</tt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Regex-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Regex-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Regex-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Regex-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Regex-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Regex-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Regex-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Regex-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Regex-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Regex-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Regex-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Regex-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Regex-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Regex-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Regex-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Regex-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Regex-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Regex-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="Regex-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="Regex-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Regex-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Regex-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Regex-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Regex-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Regex-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Regex-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Regex-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Regex-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Regex-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Regex-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Regex-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Regex-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Regex-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Regex-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Regex-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Regex-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Regex-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Regex-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Regex-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Regex-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Regex-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Regex-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Regex-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Regex-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Regex-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Regex-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Regex-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Regex-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Regex-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="SkipTo">class <strong>SkipTo</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;for&nbsp;skipping&nbsp;over&nbsp;all&nbsp;undefined&nbsp;text&nbsp;until&nbsp;the&nbsp;matched&nbsp;expression&nbsp;is&nbsp;found.<br>
If&nbsp;C{include}&nbsp;is&nbsp;set&nbsp;to&nbsp;true,&nbsp;the&nbsp;matched&nbsp;expression&nbsp;is&nbsp;also&nbsp;parsed&nbsp;(the&nbsp;skipped&nbsp;text<br>
and&nbsp;matched&nbsp;expression&nbsp;are&nbsp;returned&nbsp;as&nbsp;a&nbsp;2-element&nbsp;list).&nbsp;&nbsp;The&nbsp;C{ignore}<br>
argument&nbsp;is&nbsp;used&nbsp;to&nbsp;define&nbsp;grammars&nbsp;(typically&nbsp;quoted&nbsp;strings&nbsp;and&nbsp;comments)&nbsp;that<br>
might&nbsp;contain&nbsp;false&nbsp;matches.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#SkipTo">SkipTo</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="SkipTo-__init__"><strong>__init__</strong></a>(self, other, include<font color="#909090">=False</font>, ignore<font color="#909090">=None</font>, failOn<font color="#909090">=None</font>)</dt></dl>

<dl><dt><a name="SkipTo-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="SkipTo-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="SkipTo-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="SkipTo-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="SkipTo-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="SkipTo-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="SkipTo-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="SkipTo-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#SkipTo-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#SkipTo-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="SkipTo-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="SkipTo-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="SkipTo-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="SkipTo-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="SkipTo-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="SkipTo-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="SkipTo-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="SkipTo-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="SkipTo-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="SkipTo-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="SkipTo-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="SkipTo-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="SkipTo-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="SkipTo-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="SkipTo-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="SkipTo-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="SkipTo-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="SkipTo-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="SkipTo-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="SkipTo-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="SkipTo-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="SkipTo-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="SkipTo-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="SkipTo-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="SkipTo-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="SkipTo-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="SkipTo-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="SkipTo-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#SkipTo-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="SkipTo-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="SkipTo-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="SkipTo-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#SkipTo-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#SkipTo-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="SkipTo-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="SkipTo-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#SkipTo-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#SkipTo-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="SkipTo-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="SkipTo-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="SkipTo-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="StringEnd">class <strong>StringEnd</strong></a>(<a href="pyparsing.html#_PositionToken">_PositionToken</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Matches&nbsp;if&nbsp;current&nbsp;position&nbsp;is&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;the&nbsp;parse&nbsp;string<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#StringEnd">StringEnd</a></dd>
<dd><a href="pyparsing.html#_PositionToken">_PositionToken</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="StringEnd-__init__"><strong>__init__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringEnd-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="StringEnd-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#StringEnd-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#StringEnd-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="StringEnd-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringEnd-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringEnd-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="StringEnd-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringEnd-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringEnd-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringEnd-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringEnd-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringEnd-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringEnd-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="StringEnd-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="StringEnd-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="StringEnd-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="StringEnd-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="StringEnd-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="StringEnd-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="StringEnd-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="StringEnd-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="StringEnd-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="StringEnd-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="StringEnd-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="StringEnd-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="StringEnd-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="StringEnd-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="StringEnd-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="StringEnd-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="StringEnd-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="StringEnd-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="StringEnd-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="StringEnd-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="StringEnd-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="StringEnd-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#StringEnd-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="StringEnd-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="StringEnd-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="StringEnd-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="StringEnd-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#StringEnd-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#StringEnd-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="StringEnd-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="StringEnd-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="StringEnd-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#StringEnd-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#StringEnd-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="StringEnd-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="StringEnd-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="StringEnd-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="StringStart">class <strong>StringStart</strong></a>(<a href="pyparsing.html#_PositionToken">_PositionToken</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Matches&nbsp;if&nbsp;current&nbsp;position&nbsp;is&nbsp;at&nbsp;the&nbsp;beginning&nbsp;of&nbsp;the&nbsp;parse&nbsp;string<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#StringStart">StringStart</a></dd>
<dd><a href="pyparsing.html#_PositionToken">_PositionToken</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="StringStart-__init__"><strong>__init__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringStart-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="StringStart-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#StringStart-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#StringStart-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="StringStart-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringStart-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringStart-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="StringStart-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringStart-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringStart-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringStart-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringStart-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="StringStart-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="StringStart-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="StringStart-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="StringStart-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="StringStart-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="StringStart-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="StringStart-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="StringStart-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="StringStart-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="StringStart-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="StringStart-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="StringStart-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="StringStart-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="StringStart-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="StringStart-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="StringStart-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="StringStart-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="StringStart-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="StringStart-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="StringStart-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="StringStart-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="StringStart-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="StringStart-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="StringStart-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#StringStart-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="StringStart-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="StringStart-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="StringStart-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="StringStart-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#StringStart-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#StringStart-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="StringStart-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="StringStart-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="StringStart-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#StringStart-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#StringStart-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="StringStart-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="StringStart-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="StringStart-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Suppress">class <strong>Suppress</strong></a>(<a href="pyparsing.html#TokenConverter">TokenConverter</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Converter&nbsp;for&nbsp;ignoring&nbsp;the&nbsp;results&nbsp;of&nbsp;a&nbsp;parsed&nbsp;expression.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Suppress">Suppress</a></dd>
<dd><a href="pyparsing.html#TokenConverter">TokenConverter</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Suppress-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Suppress-suppress"><strong>suppress</strong></a>(self)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#TokenConverter">TokenConverter</a>:<br>
<dl><dt><a name="Suppress-__init__"><strong>__init__</strong></a>(self, expr, savelist<font color="#909090">=False</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="Suppress-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Suppress-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Suppress-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Suppress-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="Suppress-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Suppress-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Suppress-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Suppress-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Suppress-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Suppress-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Suppress-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Suppress-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Suppress-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Suppress-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Suppress-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Suppress-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Suppress-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Suppress-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Suppress-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Suppress-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Suppress-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Suppress-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Suppress-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Suppress-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Suppress-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Suppress-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Suppress-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Suppress-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Suppress-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Suppress-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Suppress-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Suppress-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Suppress-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Suppress-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Suppress-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Suppress-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Suppress-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Suppress-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Suppress-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Suppress-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Suppress-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Suppress-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Suppress-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Suppress-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Suppress-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Suppress-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Suppress-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Suppress-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Suppress-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Token">class <strong>Token</strong></a>(<a href="pyparsing.html#ParserElement">ParserElement</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;subclass,&nbsp;for&nbsp;defining&nbsp;atomic&nbsp;matching&nbsp;patterns.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Token-__init__"><strong>__init__</strong></a>(self)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Token-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Token-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Token-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Token-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Token-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Token-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Token-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Token-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Token-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Token-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Token-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Token-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Token-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Token-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Token-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Token-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Token-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Token-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Token-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Token-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="Token-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="Token-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Token-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Token-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Token-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Token-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Token-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Token-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Token-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Token-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Token-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Token-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Token-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Token-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Token-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Token-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Token-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Token-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Token-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Token-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Token-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Token-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Token-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Token-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Token-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Token-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Token-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Token-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Token-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Token-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Token-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Token-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="TokenConverter">class <strong>TokenConverter</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Abstract&nbsp;subclass&nbsp;of&nbsp;C{<a href="#ParseExpression">ParseExpression</a>},&nbsp;for&nbsp;converting&nbsp;parsed&nbsp;results.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#TokenConverter">TokenConverter</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="TokenConverter-__init__"><strong>__init__</strong></a>(self, expr, savelist<font color="#909090">=False</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="TokenConverter-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="TokenConverter-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="TokenConverter-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="TokenConverter-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="TokenConverter-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="TokenConverter-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="TokenConverter-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="TokenConverter-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#TokenConverter-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#TokenConverter-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="TokenConverter-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="TokenConverter-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="TokenConverter-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="TokenConverter-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="TokenConverter-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="TokenConverter-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="TokenConverter-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="TokenConverter-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="TokenConverter-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="TokenConverter-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="TokenConverter-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="TokenConverter-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="TokenConverter-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="TokenConverter-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="TokenConverter-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="TokenConverter-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="TokenConverter-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="TokenConverter-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="TokenConverter-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="TokenConverter-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#TokenConverter-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="TokenConverter-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="TokenConverter-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="TokenConverter-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#TokenConverter-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#TokenConverter-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="TokenConverter-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="TokenConverter-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#TokenConverter-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#TokenConverter-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="TokenConverter-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="TokenConverter-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="TokenConverter-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Upcase">class <strong>Upcase</strong></a>(<a href="pyparsing.html#TokenConverter">TokenConverter</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Converter&nbsp;to&nbsp;upper&nbsp;case&nbsp;all&nbsp;matching&nbsp;tokens.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Upcase">Upcase</a></dd>
<dd><a href="pyparsing.html#TokenConverter">TokenConverter</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Upcase-__init__"><strong>__init__</strong></a>(self, *args)</dt></dl>

<dl><dt><a name="Upcase-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="Upcase-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Upcase-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Upcase-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Upcase-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="Upcase-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="Upcase-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Upcase-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Upcase-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Upcase-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Upcase-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Upcase-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Upcase-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Upcase-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Upcase-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Upcase-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Upcase-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Upcase-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Upcase-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Upcase-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Upcase-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Upcase-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Upcase-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Upcase-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Upcase-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Upcase-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Upcase-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Upcase-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Upcase-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Upcase-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Upcase-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Upcase-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Upcase-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Upcase-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Upcase-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Upcase-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Upcase-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Upcase-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Upcase-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Upcase-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Upcase-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Upcase-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Upcase-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Upcase-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Upcase-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Upcase-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Upcase-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Upcase-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Upcase-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Upcase-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Upcase-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="White">class <strong>White</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Special&nbsp;matching&nbsp;class&nbsp;for&nbsp;matching&nbsp;whitespace.&nbsp;&nbsp;Normally,&nbsp;whitespace&nbsp;is&nbsp;ignored<br>
by&nbsp;pyparsing&nbsp;grammars.&nbsp;&nbsp;This&nbsp;class&nbsp;is&nbsp;included&nbsp;when&nbsp;some&nbsp;whitespace&nbsp;structures<br>
are&nbsp;significant.&nbsp;&nbsp;Define&nbsp;with&nbsp;a&nbsp;string&nbsp;containing&nbsp;the&nbsp;whitespace&nbsp;characters&nbsp;to&nbsp;be<br>
matched;&nbsp;default&nbsp;is&nbsp;C{"&nbsp;\t\r\n"}.&nbsp;&nbsp;Also&nbsp;takes&nbsp;optional&nbsp;C{min},&nbsp;C{max},&nbsp;and&nbsp;C{exact}&nbsp;arguments,<br>
as&nbsp;defined&nbsp;for&nbsp;the&nbsp;C{L{<a href="#Word">Word</a>}}&nbsp;class.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#White">White</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="White-__init__"><strong>__init__</strong></a>(self, ws<font color="#909090">=' <font color="#c040c0">\t\r\n</font>'</font>, min<font color="#909090">=1</font>, max<font color="#909090">=0</font>, exact<font color="#909090">=0</font>)</dt></dl>

<dl><dt><a name="White-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>whiteStrs</strong> = {'<font color="#c040c0">\t</font>': '&lt;TAB&gt;', '<font color="#c040c0">\n</font>': '&lt;LF&gt;', '<font color="#c040c0">\x0c</font>': '&lt;FF&gt;', '<font color="#c040c0">\r</font>': '&lt;CR&gt;', ' ': '&lt;SPC&gt;'}</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="White-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="White-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="White-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#White-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#White-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="White-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="White-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="White-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="White-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="White-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="White-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="White-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="White-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="White-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="White-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="White-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="White-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="White-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="White-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="White-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="White-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="White-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="White-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="White-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="White-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="White-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="White-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="White-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="White-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="White-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="White-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="White-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="White-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="White-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="White-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="White-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="White-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="White-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="White-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="White-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="White-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="White-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="White-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="White-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#White-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="White-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="White-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="White-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="White-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#White-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#White-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="White-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="White-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="White-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#White-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#White-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="White-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="White-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="White-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="Word">class <strong>Word</strong></a>(<a href="pyparsing.html#Token">Token</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Token">Token</a>&nbsp;for&nbsp;matching&nbsp;words&nbsp;composed&nbsp;of&nbsp;allowed&nbsp;character&nbsp;sets.<br>
Defined&nbsp;with&nbsp;string&nbsp;containing&nbsp;all&nbsp;allowed&nbsp;initial&nbsp;characters,<br>
an&nbsp;optional&nbsp;string&nbsp;containing&nbsp;allowed&nbsp;body&nbsp;characters&nbsp;(if&nbsp;omitted,<br>
defaults&nbsp;to&nbsp;the&nbsp;initial&nbsp;character&nbsp;set),&nbsp;and&nbsp;an&nbsp;optional&nbsp;minimum,<br>
maximum,&nbsp;and/or&nbsp;exact&nbsp;length.&nbsp;&nbsp;The&nbsp;default&nbsp;value&nbsp;for&nbsp;C{min}&nbsp;is&nbsp;1&nbsp;(a<br>
minimum&nbsp;value&nbsp;&lt;&nbsp;1&nbsp;is&nbsp;not&nbsp;valid);&nbsp;the&nbsp;default&nbsp;values&nbsp;for&nbsp;C{max}&nbsp;and&nbsp;C{exact}<br>
are&nbsp;0,&nbsp;meaning&nbsp;no&nbsp;maximum&nbsp;or&nbsp;exact&nbsp;length&nbsp;restriction.&nbsp;An&nbsp;optional<br>
C{exclude}&nbsp;parameter&nbsp;can&nbsp;list&nbsp;characters&nbsp;that&nbsp;might&nbsp;be&nbsp;found&nbsp;in&nbsp;<br>
the&nbsp;input&nbsp;C{bodyChars}&nbsp;string;&nbsp;useful&nbsp;to&nbsp;define&nbsp;a&nbsp;word&nbsp;of&nbsp;all&nbsp;printables<br>
except&nbsp;for&nbsp;one&nbsp;or&nbsp;two&nbsp;characters,&nbsp;for&nbsp;instance.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#Word">Word</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="Word-__init__"><strong>__init__</strong></a>(self, initChars, bodyChars<font color="#909090">=None</font>, min<font color="#909090">=1</font>, max<font color="#909090">=0</font>, exact<font color="#909090">=0</font>, asKeyword<font color="#909090">=False</font>, excludeChars<font color="#909090">=None</font>)</dt></dl>

<dl><dt><a name="Word-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="Word-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Data and other attributes defined here:<br>
<dl><dt><strong>__slotnames__</strong> = []</dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Word-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#Word-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#Word-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="Word-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Word-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="Word-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="Word-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Word-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="Word-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Word-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Word-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="Word-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="Word-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="Word-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="Word-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="Word-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="Word-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="Word-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="Word-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="Word-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="Word-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="Word-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="Word-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="Word-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="Word-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Word-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="Word-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="Word-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="Word-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="Word-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="Word-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="Word-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="Word-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="Word-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Word-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#Word-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="Word-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="Word-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="Word-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="Word-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#Word-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#Word-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="Word-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="Word-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="Word-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#Word-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#Word-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="Word-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="Word-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="Word-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="WordEnd">class <strong>WordEnd</strong></a>(<a href="pyparsing.html#_PositionToken">_PositionToken</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Matches&nbsp;if&nbsp;the&nbsp;current&nbsp;position&nbsp;is&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;a&nbsp;<a href="#Word">Word</a>,&nbsp;and<br>
is&nbsp;not&nbsp;followed&nbsp;by&nbsp;any&nbsp;character&nbsp;in&nbsp;a&nbsp;given&nbsp;set&nbsp;of&nbsp;C{wordChars}<br>
(default=C{printables}).&nbsp;To&nbsp;emulate&nbsp;the&nbsp;C{}&nbsp;behavior&nbsp;of&nbsp;regular&nbsp;expressions,<br>
use&nbsp;C{<a href="#WordEnd">WordEnd</a>(alphanums)}.&nbsp;C{<a href="#WordEnd">WordEnd</a>}&nbsp;will&nbsp;also&nbsp;match&nbsp;at&nbsp;the&nbsp;end&nbsp;of<br>
the&nbsp;string&nbsp;being&nbsp;parsed,&nbsp;or&nbsp;at&nbsp;the&nbsp;end&nbsp;of&nbsp;a&nbsp;line.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#WordEnd">WordEnd</a></dd>
<dd><a href="pyparsing.html#_PositionToken">_PositionToken</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="WordEnd-__init__"><strong>__init__</strong></a>(self, wordChars<font color="#909090">='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;<font color="#c040c0">\'</font>()*+,-./:;&lt;=&gt;?@[<font color="#c040c0">\\</font>]^_`{|}~'</font>)</dt></dl>

<dl><dt><a name="WordEnd-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="WordEnd-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#WordEnd-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#WordEnd-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="WordEnd-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordEnd-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="WordEnd-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="WordEnd-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordEnd-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="WordEnd-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordEnd-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordEnd-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordEnd-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="WordEnd-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="WordEnd-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="WordEnd-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="WordEnd-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="WordEnd-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="WordEnd-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="WordEnd-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="WordEnd-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="WordEnd-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="WordEnd-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="WordEnd-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="WordEnd-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="WordEnd-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="WordEnd-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="WordEnd-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="WordEnd-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="WordEnd-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="WordEnd-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="WordEnd-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="WordEnd-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="WordEnd-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="WordEnd-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="WordEnd-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#WordEnd-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="WordEnd-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="WordEnd-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="WordEnd-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="WordEnd-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#WordEnd-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#WordEnd-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="WordEnd-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="WordEnd-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="WordEnd-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#WordEnd-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#WordEnd-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="WordEnd-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="WordEnd-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="WordEnd-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="WordStart">class <strong>WordStart</strong></a>(<a href="pyparsing.html#_PositionToken">_PositionToken</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt>Matches&nbsp;if&nbsp;the&nbsp;current&nbsp;position&nbsp;is&nbsp;at&nbsp;the&nbsp;beginning&nbsp;of&nbsp;a&nbsp;<a href="#Word">Word</a>,&nbsp;and<br>
is&nbsp;not&nbsp;preceded&nbsp;by&nbsp;any&nbsp;character&nbsp;in&nbsp;a&nbsp;given&nbsp;set&nbsp;of&nbsp;C{wordChars}<br>
(default=C{printables}).&nbsp;To&nbsp;emulate&nbsp;the&nbsp;C{}&nbsp;behavior&nbsp;of&nbsp;regular&nbsp;expressions,<br>
use&nbsp;C{<a href="#WordStart">WordStart</a>(alphanums)}.&nbsp;C{<a href="#WordStart">WordStart</a>}&nbsp;will&nbsp;also&nbsp;match&nbsp;at&nbsp;the&nbsp;beginning&nbsp;of<br>
the&nbsp;string&nbsp;being&nbsp;parsed,&nbsp;or&nbsp;at&nbsp;the&nbsp;beginning&nbsp;of&nbsp;a&nbsp;line.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#WordStart">WordStart</a></dd>
<dd><a href="pyparsing.html#_PositionToken">_PositionToken</a></dd>
<dd><a href="pyparsing.html#Token">Token</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="WordStart-__init__"><strong>__init__</strong></a>(self, wordChars<font color="#909090">='0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;<font color="#c040c0">\'</font>()*+,-./:;&lt;=&gt;?@[<font color="#c040c0">\\</font>]^_`{|}~'</font>)</dt></dl>

<dl><dt><a name="WordStart-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="WordStart-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#WordStart-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#WordStart-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="WordStart-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordStart-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="WordStart-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="WordStart-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordStart-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="WordStart-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordStart-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordStart-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="WordStart-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="WordStart-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="WordStart-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="WordStart-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="WordStart-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="WordStart-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="WordStart-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="WordStart-ignore"><strong>ignore</strong></a>(self, other)</dt><dd><tt>Define&nbsp;expression&nbsp;to&nbsp;be&nbsp;ignored&nbsp;(e.g.,&nbsp;comments)&nbsp;while&nbsp;doing&nbsp;pattern<br>
matching;&nbsp;may&nbsp;be&nbsp;called&nbsp;repeatedly,&nbsp;to&nbsp;define&nbsp;multiple&nbsp;comment&nbsp;or&nbsp;other<br>
ignorable&nbsp;patterns.</tt></dd></dl>

<dl><dt><a name="WordStart-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt><dd><tt>Disables&nbsp;the&nbsp;skipping&nbsp;of&nbsp;whitespace&nbsp;before&nbsp;matching&nbsp;the&nbsp;characters&nbsp;in&nbsp;the<br>
C{<a href="#ParserElement">ParserElement</a>}'s&nbsp;defined&nbsp;pattern.&nbsp;&nbsp;This&nbsp;is&nbsp;normally&nbsp;only&nbsp;used&nbsp;internally&nbsp;by<br>
the&nbsp;pyparsing&nbsp;module,&nbsp;but&nbsp;may&nbsp;be&nbsp;needed&nbsp;in&nbsp;some&nbsp;whitespace-sensitive&nbsp;grammars.</tt></dd></dl>

<dl><dt><a name="WordStart-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="WordStart-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="WordStart-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="WordStart-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="WordStart-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="WordStart-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="WordStart-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="WordStart-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="WordStart-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="WordStart-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="WordStart-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="WordStart-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="WordStart-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="WordStart-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="WordStart-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;referencing&nbsp;matching&nbsp;tokens&nbsp;as&nbsp;a&nbsp;nested&nbsp;attribute<br>
of&nbsp;the&nbsp;returned&nbsp;parse&nbsp;results.<br>
NOTE:&nbsp;this&nbsp;returns&nbsp;a&nbsp;*copy*&nbsp;of&nbsp;the&nbsp;original&nbsp;C{<a href="#ParserElement">ParserElement</a>}&nbsp;<a href="__builtin__.html#object">object</a>;<br>
this&nbsp;is&nbsp;so&nbsp;that&nbsp;the&nbsp;client&nbsp;can&nbsp;define&nbsp;a&nbsp;basic&nbsp;element,&nbsp;such&nbsp;as&nbsp;an<br>
integer,&nbsp;and&nbsp;reference&nbsp;it&nbsp;in&nbsp;multiple&nbsp;places&nbsp;with&nbsp;different&nbsp;names.<br>
&nbsp;<br>
You&nbsp;can&nbsp;also&nbsp;set&nbsp;results&nbsp;names&nbsp;using&nbsp;the&nbsp;abbreviated&nbsp;syntax,<br>
C{expr("name")}&nbsp;in&nbsp;place&nbsp;of&nbsp;C{expr.<a href="#WordStart-setResultsName">setResultsName</a>("name")}&nbsp;-&nbsp;<br>
see&nbsp;L{I{__call__}&lt;__call__&gt;}.</tt></dd></dl>

<dl><dt><a name="WordStart-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="WordStart-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="WordStart-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="WordStart-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#WordStart-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#WordStart-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="WordStart-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="WordStart-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt><dd><tt>Check&nbsp;defined&nbsp;expressions&nbsp;for&nbsp;valid&nbsp;structure,&nbsp;check&nbsp;for&nbsp;infinite&nbsp;recursive&nbsp;definitions.</tt></dd></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="WordStart-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#WordStart-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#WordStart-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="WordStart-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="WordStart-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="WordStart-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table> <p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#ffc8d8">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#000000" face="helvetica, arial"><a name="ZeroOrMore">class <strong>ZeroOrMore</strong></a>(<a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>)</font></td></tr>
    
<tr bgcolor="#ffc8d8"><td rowspan=2><tt>&nbsp;&nbsp;&nbsp;</tt></td>
<td colspan=2><tt><a href="#Optional">Optional</a>&nbsp;repetition&nbsp;of&nbsp;zero&nbsp;or&nbsp;more&nbsp;of&nbsp;the&nbsp;given&nbsp;expression.<br>&nbsp;</tt></td></tr>
<tr><td>&nbsp;</td>
<td width="100%"><dl><dt>Method resolution order:</dt>
<dd><a href="pyparsing.html#ZeroOrMore">ZeroOrMore</a></dd>
<dd><a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a></dd>
<dd><a href="pyparsing.html#ParserElement">ParserElement</a></dd>
<dd><a href="__builtin__.html#object">__builtin__.object</a></dd>
</dl>
<hr>
Methods defined here:<br>
<dl><dt><a name="ZeroOrMore-__init__"><strong>__init__</strong></a>(self, expr)</dt></dl>

<dl><dt><a name="ZeroOrMore-__str__"><strong>__str__</strong></a>(self)</dt></dl>

<dl><dt><a name="ZeroOrMore-parseImpl"><strong>parseImpl</strong></a>(self, instring, loc, doActions<font color="#909090">=True</font>)</dt></dl>

<dl><dt><a name="ZeroOrMore-setResultsName"><strong>setResultsName</strong></a>(self, name, listAllMatches<font color="#909090">=False</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParseElementEnhance">ParseElementEnhance</a>:<br>
<dl><dt><a name="ZeroOrMore-checkRecursion"><strong>checkRecursion</strong></a>(self, parseElementList)</dt></dl>

<dl><dt><a name="ZeroOrMore-ignore"><strong>ignore</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ZeroOrMore-leaveWhitespace"><strong>leaveWhitespace</strong></a>(self)</dt></dl>

<dl><dt><a name="ZeroOrMore-streamline"><strong>streamline</strong></a>(self)</dt></dl>

<dl><dt><a name="ZeroOrMore-validate"><strong>validate</strong></a>(self, validateTrace<font color="#909090">=[]</font>)</dt></dl>

<hr>
Methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="ZeroOrMore-__add__"><strong>__add__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__and__"><strong>__and__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Each">Each</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__call__"><strong>__call__</strong></a>(self, name<font color="#909090">=None</font>)</dt><dd><tt>Shortcut&nbsp;for&nbsp;C{L{setResultsName}},&nbsp;with&nbsp;C{listAllMatches=default}::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas).<a href="#ZeroOrMore-setResultsName">setResultsName</a>("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-").<a href="#ZeroOrMore-setResultsName">setResultsName</a>("socsecno")<br>
could&nbsp;be&nbsp;written&nbsp;as::<br>
&nbsp;&nbsp;userdata&nbsp;=&nbsp;<a href="#Word">Word</a>(alphas)("name")&nbsp;+&nbsp;<a href="#Word">Word</a>(nums+"-")("socsecno")<br>
&nbsp;&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;given&nbsp;with&nbsp;a&nbsp;trailing&nbsp;C{'*'}&nbsp;character,&nbsp;then&nbsp;C{listAllMatches}&nbsp;will&nbsp;be<br>
passed&nbsp;as&nbsp;C{True}.<br>
&nbsp;<br>
If&nbsp;C{name}&nbsp;is&nbsp;omitted,&nbsp;same&nbsp;as&nbsp;calling&nbsp;C{L{copy}}.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__eq__"><strong>__eq__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ZeroOrMore-__hash__"><strong>__hash__</strong></a>(self)</dt></dl>

<dl><dt><a name="ZeroOrMore-__invert__"><strong>__invert__</strong></a>(self)</dt><dd><tt>Implementation&nbsp;of&nbsp;~&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#NotAny">NotAny</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__mul__"><strong>__mul__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;*&nbsp;operator,&nbsp;allows&nbsp;use&nbsp;of&nbsp;C{expr&nbsp;*&nbsp;3}&nbsp;in&nbsp;place&nbsp;of<br>
C{expr&nbsp;+&nbsp;expr&nbsp;+&nbsp;expr}.&nbsp;&nbsp;Expressions&nbsp;may&nbsp;also&nbsp;me&nbsp;multiplied&nbsp;by&nbsp;a&nbsp;2-integer<br>
tuple,&nbsp;similar&nbsp;to&nbsp;C{{min,max}}&nbsp;multipliers&nbsp;in&nbsp;regular&nbsp;expressions.&nbsp;&nbsp;Tuples<br>
may&nbsp;also&nbsp;include&nbsp;C{None}&nbsp;as&nbsp;in:<br>
&nbsp;-&nbsp;C{expr*(n,None)}&nbsp;or&nbsp;C{expr*(n,)}&nbsp;is&nbsp;equivalent<br>
&nbsp;&nbsp;&nbsp;to&nbsp;C{expr*n&nbsp;+&nbsp;L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"at&nbsp;least&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,n)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{expr*(0,n)}<br>
&nbsp;&nbsp;&nbsp;(read&nbsp;as&nbsp;"0&nbsp;to&nbsp;n&nbsp;instances&nbsp;of&nbsp;C{expr}")<br>
&nbsp;-&nbsp;C{expr*(None,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}(expr)}<br>
&nbsp;-&nbsp;C{expr*(1,None)}&nbsp;is&nbsp;equivalent&nbsp;to&nbsp;C{L{<a href="#OneOrMore">OneOrMore</a>}(expr)}<br>
&nbsp;<br>
Note&nbsp;that&nbsp;C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;raise&nbsp;an&nbsp;exception&nbsp;if<br>
more&nbsp;than&nbsp;n&nbsp;exprs&nbsp;exist&nbsp;in&nbsp;the&nbsp;input&nbsp;stream;&nbsp;that&nbsp;is,<br>
C{expr*(None,n)}&nbsp;does&nbsp;not&nbsp;enforce&nbsp;a&nbsp;maximum&nbsp;number&nbsp;of&nbsp;expr<br>
occurrences.&nbsp;&nbsp;If&nbsp;this&nbsp;behavior&nbsp;is&nbsp;desired,&nbsp;then&nbsp;write<br>
C{expr*(None,n)&nbsp;+&nbsp;~expr}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__ne__"><strong>__ne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ZeroOrMore-__or__"><strong>__or__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__radd__"><strong>__radd__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;+&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__rand__"><strong>__rand__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;&amp;&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__repr__"><strong>__repr__</strong></a>(self)</dt></dl>

<dl><dt><a name="ZeroOrMore-__req__"><strong>__req__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ZeroOrMore-__rmul__"><strong>__rmul__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ZeroOrMore-__rne__"><strong>__rne__</strong></a>(self, other)</dt></dl>

<dl><dt><a name="ZeroOrMore-__ror__"><strong>__ror__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;|&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__rsub__"><strong>__rsub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__rxor__"><strong>__rxor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;when&nbsp;left&nbsp;operand&nbsp;is&nbsp;not&nbsp;a&nbsp;C{L{<a href="#ParserElement">ParserElement</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__sub__"><strong>__sub__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;-&nbsp;operator,&nbsp;returns&nbsp;C{L{<a href="#And">And</a>}}&nbsp;with&nbsp;error&nbsp;stop</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-__xor__"><strong>__xor__</strong></a>(self, other)</dt><dd><tt>Implementation&nbsp;of&nbsp;^&nbsp;operator&nbsp;-&nbsp;returns&nbsp;C{L{<a href="#Or">Or</a>}}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-addCondition"><strong>addCondition</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;a&nbsp;boolean&nbsp;predicate&nbsp;function&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;<br>
L{I{setParseAction}&lt;setParseAction&gt;}.&nbsp;<a href="#Optional">Optional</a>&nbsp;keyword&nbsp;argument&nbsp;C{message}&nbsp;can<br>
be&nbsp;used&nbsp;to&nbsp;define&nbsp;a&nbsp;custom&nbsp;message&nbsp;to&nbsp;be&nbsp;used&nbsp;in&nbsp;the&nbsp;raised&nbsp;exception.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-addParseAction"><strong>addParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Add&nbsp;parse&nbsp;action&nbsp;to&nbsp;expression's&nbsp;list&nbsp;of&nbsp;parse&nbsp;actions.&nbsp;See&nbsp;L{I{setParseAction}&lt;setParseAction&gt;}.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-copy"><strong>copy</strong></a>(self)</dt><dd><tt>Make&nbsp;a&nbsp;copy&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>}.&nbsp;&nbsp;Useful&nbsp;for&nbsp;defining&nbsp;different&nbsp;parse&nbsp;actions<br>
for&nbsp;the&nbsp;same&nbsp;parsing&nbsp;pattern,&nbsp;using&nbsp;copies&nbsp;of&nbsp;the&nbsp;original&nbsp;parse&nbsp;element.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-parseFile"><strong>parseFile</strong></a>(self, file_or_filename, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;the&nbsp;given&nbsp;file&nbsp;or&nbsp;filename.<br>
If&nbsp;a&nbsp;filename&nbsp;is&nbsp;specified&nbsp;(instead&nbsp;of&nbsp;a&nbsp;file&nbsp;<a href="__builtin__.html#object">object</a>),<br>
the&nbsp;entire&nbsp;file&nbsp;is&nbsp;opened,&nbsp;read,&nbsp;and&nbsp;closed&nbsp;before&nbsp;parsing.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-parseString"><strong>parseString</strong></a>(self, instring, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;with&nbsp;the&nbsp;given&nbsp;string.<br>
This&nbsp;is&nbsp;the&nbsp;main&nbsp;interface&nbsp;to&nbsp;the&nbsp;client&nbsp;code,&nbsp;once&nbsp;the&nbsp;complete<br>
expression&nbsp;has&nbsp;been&nbsp;built.<br>
&nbsp;<br>
If&nbsp;you&nbsp;want&nbsp;the&nbsp;grammar&nbsp;to&nbsp;require&nbsp;that&nbsp;the&nbsp;entire&nbsp;input&nbsp;string&nbsp;be<br>
successfully&nbsp;parsed,&nbsp;then&nbsp;set&nbsp;C{parseAll}&nbsp;to&nbsp;True&nbsp;(equivalent&nbsp;to&nbsp;ending<br>
the&nbsp;grammar&nbsp;with&nbsp;C{L{<a href="#StringEnd">StringEnd</a>()}}).<br>
&nbsp;<br>
Note:&nbsp;C{parseString}&nbsp;implicitly&nbsp;calls&nbsp;C{expandtabs()}&nbsp;on&nbsp;the&nbsp;input&nbsp;string,<br>
in&nbsp;order&nbsp;to&nbsp;report&nbsp;proper&nbsp;column&nbsp;numbers&nbsp;in&nbsp;parse&nbsp;actions.<br>
If&nbsp;the&nbsp;input&nbsp;string&nbsp;contains&nbsp;tabs&nbsp;and<br>
the&nbsp;grammar&nbsp;uses&nbsp;parse&nbsp;actions&nbsp;that&nbsp;use&nbsp;the&nbsp;C{loc}&nbsp;argument&nbsp;to&nbsp;index&nbsp;into&nbsp;the<br>
string&nbsp;being&nbsp;parsed,&nbsp;you&nbsp;can&nbsp;ensure&nbsp;you&nbsp;have&nbsp;a&nbsp;consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;input<br>
string&nbsp;by:<br>
&nbsp;-&nbsp;calling&nbsp;C{parseWithTabs}&nbsp;on&nbsp;your&nbsp;grammar&nbsp;before&nbsp;calling&nbsp;C{parseString}<br>
&nbsp;&nbsp;&nbsp;(see&nbsp;L{I{parseWithTabs}&lt;parseWithTabs&gt;})<br>
&nbsp;-&nbsp;define&nbsp;your&nbsp;parse&nbsp;action&nbsp;using&nbsp;the&nbsp;full&nbsp;C{(s,loc,toks)}&nbsp;signature,&nbsp;and<br>
&nbsp;&nbsp;&nbsp;reference&nbsp;the&nbsp;input&nbsp;string&nbsp;using&nbsp;the&nbsp;parse&nbsp;action's&nbsp;C{s}&nbsp;argument<br>
&nbsp;-&nbsp;explictly&nbsp;expand&nbsp;the&nbsp;tabs&nbsp;in&nbsp;your&nbsp;input&nbsp;string&nbsp;before&nbsp;calling<br>
&nbsp;&nbsp;&nbsp;C{parseString}</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-parseWithTabs"><strong>parseWithTabs</strong></a>(self)</dt><dd><tt>Overrides&nbsp;default&nbsp;behavior&nbsp;to&nbsp;expand&nbsp;C{&lt;TAB&gt;}s&nbsp;to&nbsp;spaces&nbsp;before&nbsp;parsing&nbsp;the&nbsp;input&nbsp;string.<br>
Must&nbsp;be&nbsp;called&nbsp;before&nbsp;C{parseString}&nbsp;when&nbsp;the&nbsp;input&nbsp;grammar&nbsp;contains&nbsp;elements&nbsp;that<br>
match&nbsp;C{&lt;TAB&gt;}&nbsp;characters.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-postParse"><strong>postParse</strong></a>(self, instring, loc, tokenlist)</dt></dl>

<dl><dt><a name="ZeroOrMore-preParse"><strong>preParse</strong></a>(self, instring, loc)</dt></dl>

<dl><dt><a name="ZeroOrMore-runTests"><strong>runTests</strong></a>(self, tests, parseAll<font color="#909090">=False</font>)</dt><dd><tt>Execute&nbsp;the&nbsp;parse&nbsp;expression&nbsp;on&nbsp;a&nbsp;series&nbsp;of&nbsp;test&nbsp;strings,&nbsp;showing&nbsp;each<br>
test,&nbsp;the&nbsp;parsed&nbsp;results&nbsp;or&nbsp;where&nbsp;the&nbsp;parse&nbsp;failed.&nbsp;Quick&nbsp;and&nbsp;easy&nbsp;way&nbsp;to<br>
run&nbsp;a&nbsp;parse&nbsp;expression&nbsp;against&nbsp;a&nbsp;list&nbsp;of&nbsp;sample&nbsp;strings.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;tests&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;test&nbsp;strings,&nbsp;or&nbsp;a&nbsp;multiline&nbsp;string&nbsp;of&nbsp;test&nbsp;strings<br>
&nbsp;-&nbsp;parseAll&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;flag&nbsp;to&nbsp;pass&nbsp;to&nbsp;C{L{parseString}}&nbsp;when&nbsp;running&nbsp;tests</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-scanString"><strong>scanString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>, overlap<font color="#909090">=False</font>)</dt><dd><tt>Scan&nbsp;the&nbsp;input&nbsp;string&nbsp;for&nbsp;expression&nbsp;matches.&nbsp;&nbsp;<a href="#Each">Each</a>&nbsp;match&nbsp;will&nbsp;return&nbsp;the<br>
matching&nbsp;tokens,&nbsp;start&nbsp;location,&nbsp;and&nbsp;end&nbsp;location.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;scanning&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.&nbsp;&nbsp;If<br>
C{overlap}&nbsp;is&nbsp;specified,&nbsp;then&nbsp;overlapping&nbsp;matches&nbsp;will&nbsp;be&nbsp;reported.<br>
&nbsp;<br>
Note&nbsp;that&nbsp;the&nbsp;start&nbsp;and&nbsp;end&nbsp;locations&nbsp;are&nbsp;reported&nbsp;relative&nbsp;to&nbsp;the&nbsp;string<br>
being&nbsp;parsed.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information&nbsp;on&nbsp;parsing<br>
strings&nbsp;with&nbsp;embedded&nbsp;tabs.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-searchString"><strong>searchString</strong></a>(self, instring, maxMatches<font color="#909090">=9223372036854775807</font>)</dt><dd><tt>Another&nbsp;extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;simplifying&nbsp;the&nbsp;access&nbsp;to&nbsp;the&nbsp;tokens&nbsp;found<br>
to&nbsp;match&nbsp;the&nbsp;given&nbsp;parse&nbsp;expression.&nbsp;&nbsp;May&nbsp;be&nbsp;called&nbsp;with&nbsp;optional<br>
C{maxMatches}&nbsp;argument,&nbsp;to&nbsp;clip&nbsp;searching&nbsp;after&nbsp;'n'&nbsp;matches&nbsp;are&nbsp;found.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-setBreak"><strong>setBreak</strong></a>(self, breakFlag<font color="#909090">=True</font>)</dt><dd><tt>Method&nbsp;to&nbsp;invoke&nbsp;the&nbsp;Python&nbsp;pdb&nbsp;debugger&nbsp;when&nbsp;this&nbsp;element&nbsp;is<br>
about&nbsp;to&nbsp;be&nbsp;parsed.&nbsp;Set&nbsp;C{breakFlag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to<br>
disable.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-setDebug"><strong>setDebug</strong></a>(self, flag<font color="#909090">=True</font>)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.<br>
Set&nbsp;C{flag}&nbsp;to&nbsp;True&nbsp;to&nbsp;enable,&nbsp;False&nbsp;to&nbsp;disable.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-setDebugActions"><strong>setDebugActions</strong></a>(self, startAction, successAction, exceptionAction)</dt><dd><tt>Enable&nbsp;display&nbsp;of&nbsp;debugging&nbsp;messages&nbsp;while&nbsp;doing&nbsp;pattern&nbsp;matching.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-setFailAction"><strong>setFailAction</strong></a>(self, fn)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;if&nbsp;parsing&nbsp;fails&nbsp;at&nbsp;this&nbsp;expression.<br>
Fail&nbsp;acton&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;function&nbsp;that&nbsp;takes&nbsp;the&nbsp;arguments<br>
C{fn(s,loc,expr,err)}&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;=&nbsp;string&nbsp;being&nbsp;parsed<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;location&nbsp;where&nbsp;expression&nbsp;match&nbsp;was&nbsp;attempted&nbsp;and&nbsp;failed<br>
&nbsp;-&nbsp;expr&nbsp;=&nbsp;the&nbsp;parse&nbsp;expression&nbsp;that&nbsp;failed<br>
&nbsp;-&nbsp;err&nbsp;=&nbsp;the&nbsp;exception&nbsp;thrown<br>
The&nbsp;function&nbsp;returns&nbsp;no&nbsp;value.&nbsp;&nbsp;It&nbsp;may&nbsp;throw&nbsp;C{L{<a href="#ParseFatalException">ParseFatalException</a>}}<br>
if&nbsp;it&nbsp;is&nbsp;desired&nbsp;to&nbsp;stop&nbsp;parsing&nbsp;immediately.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-setName"><strong>setName</strong></a>(self, name)</dt><dd><tt>Define&nbsp;name&nbsp;for&nbsp;this&nbsp;expression,&nbsp;for&nbsp;use&nbsp;in&nbsp;debugging.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-setParseAction"><strong>setParseAction</strong></a>(self, *fns, **kwargs)</dt><dd><tt>Define&nbsp;action&nbsp;to&nbsp;perform&nbsp;when&nbsp;successfully&nbsp;matching&nbsp;parse&nbsp;element&nbsp;definition.<br>
Parse&nbsp;action&nbsp;fn&nbsp;is&nbsp;a&nbsp;callable&nbsp;method&nbsp;with&nbsp;0-3&nbsp;arguments,&nbsp;called&nbsp;as&nbsp;C{fn(s,loc,toks)},<br>
C{fn(loc,toks)},&nbsp;C{fn(toks)},&nbsp;or&nbsp;just&nbsp;C{fn()},&nbsp;where:<br>
&nbsp;-&nbsp;s&nbsp;&nbsp;&nbsp;=&nbsp;the&nbsp;original&nbsp;string&nbsp;being&nbsp;parsed&nbsp;(see&nbsp;note&nbsp;below)<br>
&nbsp;-&nbsp;loc&nbsp;=&nbsp;the&nbsp;location&nbsp;of&nbsp;the&nbsp;matching&nbsp;substring<br>
&nbsp;-&nbsp;toks&nbsp;=&nbsp;a&nbsp;list&nbsp;of&nbsp;the&nbsp;matched&nbsp;tokens,&nbsp;packaged&nbsp;as&nbsp;a&nbsp;C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;<a href="__builtin__.html#object">object</a><br>
If&nbsp;the&nbsp;functions&nbsp;in&nbsp;fns&nbsp;modify&nbsp;the&nbsp;tokens,&nbsp;they&nbsp;can&nbsp;return&nbsp;them&nbsp;as&nbsp;the&nbsp;return<br>
value&nbsp;from&nbsp;fn,&nbsp;and&nbsp;the&nbsp;modified&nbsp;list&nbsp;of&nbsp;tokens&nbsp;will&nbsp;replace&nbsp;the&nbsp;original.<br>
Otherwise,&nbsp;fn&nbsp;does&nbsp;not&nbsp;need&nbsp;to&nbsp;return&nbsp;any&nbsp;value.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{parseString}&lt;parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-setWhitespaceChars"><strong>setWhitespaceChars</strong></a>(self, chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-suppress"><strong>suppress</strong></a>(self)</dt><dd><tt>Suppresses&nbsp;the&nbsp;output&nbsp;of&nbsp;this&nbsp;C{<a href="#ParserElement">ParserElement</a>};&nbsp;useful&nbsp;to&nbsp;keep&nbsp;punctuation&nbsp;from<br>
cluttering&nbsp;up&nbsp;returned&nbsp;output.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-transformString"><strong>transformString</strong></a>(self, instring)</dt><dd><tt>Extension&nbsp;to&nbsp;C{L{scanString}},&nbsp;to&nbsp;modify&nbsp;matching&nbsp;text&nbsp;with&nbsp;modified&nbsp;tokens&nbsp;that&nbsp;may<br>
be&nbsp;returned&nbsp;from&nbsp;a&nbsp;parse&nbsp;action.&nbsp;&nbsp;To&nbsp;use&nbsp;C{transformString},&nbsp;define&nbsp;a&nbsp;grammar&nbsp;and<br>
attach&nbsp;a&nbsp;parse&nbsp;action&nbsp;to&nbsp;it&nbsp;that&nbsp;modifies&nbsp;the&nbsp;returned&nbsp;token&nbsp;list.<br>
Invoking&nbsp;C{<a href="#ZeroOrMore-transformString">transformString</a>()}&nbsp;on&nbsp;a&nbsp;target&nbsp;string&nbsp;will&nbsp;then&nbsp;scan&nbsp;for&nbsp;matches,<br>
and&nbsp;replace&nbsp;the&nbsp;matched&nbsp;text&nbsp;patterns&nbsp;according&nbsp;to&nbsp;the&nbsp;logic&nbsp;in&nbsp;the&nbsp;parse<br>
action.&nbsp;&nbsp;C{<a href="#ZeroOrMore-transformString">transformString</a>()}&nbsp;returns&nbsp;the&nbsp;resulting&nbsp;transformed&nbsp;string.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-tryParse"><strong>tryParse</strong></a>(self, instring, loc)</dt></dl>

<hr>
Static methods inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><a name="ZeroOrMore-enablePackrat"><strong>enablePackrat</strong></a>()</dt><dd><tt>Enables&nbsp;"packrat"&nbsp;parsing,&nbsp;which&nbsp;adds&nbsp;memoizing&nbsp;to&nbsp;the&nbsp;parsing&nbsp;logic.<br>
Repeated&nbsp;parse&nbsp;attempts&nbsp;at&nbsp;the&nbsp;same&nbsp;string&nbsp;location&nbsp;(which&nbsp;happens<br>
often&nbsp;in&nbsp;many&nbsp;complex&nbsp;grammars)&nbsp;can&nbsp;immediately&nbsp;return&nbsp;a&nbsp;cached&nbsp;value,<br>
instead&nbsp;of&nbsp;re-executing&nbsp;parsing/validating&nbsp;code.&nbsp;&nbsp;Memoizing&nbsp;is&nbsp;done&nbsp;of<br>
both&nbsp;valid&nbsp;results&nbsp;and&nbsp;parsing&nbsp;exceptions.<br>
&nbsp;<br>
This&nbsp;speedup&nbsp;may&nbsp;break&nbsp;existing&nbsp;programs&nbsp;that&nbsp;use&nbsp;parse&nbsp;actions&nbsp;that<br>
have&nbsp;side-effects.&nbsp;&nbsp;For&nbsp;this&nbsp;reason,&nbsp;packrat&nbsp;parsing&nbsp;is&nbsp;disabled&nbsp;when<br>
you&nbsp;first&nbsp;import&nbsp;pyparsing.&nbsp;&nbsp;To&nbsp;activate&nbsp;the&nbsp;packrat&nbsp;feature,&nbsp;your<br>
program&nbsp;must&nbsp;call&nbsp;the&nbsp;class&nbsp;method&nbsp;C{<a href="#ParserElement">ParserElement</a>.<a href="#ZeroOrMore-enablePackrat">enablePackrat</a>()}.&nbsp;&nbsp;If<br>
your&nbsp;program&nbsp;uses&nbsp;C{psyco}&nbsp;to&nbsp;"compile&nbsp;as&nbsp;you&nbsp;go",&nbsp;you&nbsp;must&nbsp;call<br>
C{enablePackrat}&nbsp;before&nbsp;calling&nbsp;C{psyco.full()}.&nbsp;&nbsp;If&nbsp;you&nbsp;do&nbsp;not&nbsp;do&nbsp;this,<br>
Python&nbsp;will&nbsp;crash.&nbsp;&nbsp;For&nbsp;best&nbsp;results,&nbsp;call&nbsp;C{<a href="#ZeroOrMore-enablePackrat">enablePackrat</a>()}&nbsp;immediately<br>
after&nbsp;importing&nbsp;pyparsing.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-inlineLiteralsUsing"><strong>inlineLiteralsUsing</strong></a>(cls)</dt><dd><tt>Set&nbsp;class&nbsp;to&nbsp;be&nbsp;used&nbsp;for&nbsp;inclusion&nbsp;of&nbsp;string&nbsp;literals&nbsp;into&nbsp;a&nbsp;parser.</tt></dd></dl>

<dl><dt><a name="ZeroOrMore-resetCache"><strong>resetCache</strong></a>()</dt></dl>

<dl><dt><a name="ZeroOrMore-setDefaultWhitespaceChars"><strong>setDefaultWhitespaceChars</strong></a>(chars)</dt><dd><tt>Overrides&nbsp;the&nbsp;default&nbsp;whitespace&nbsp;chars</tt></dd></dl>

<hr>
Data descriptors inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>__dict__</strong></dt>
<dd><tt>dictionary&nbsp;for&nbsp;instance&nbsp;variables&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<dl><dt><strong>__weakref__</strong></dt>
<dd><tt>list&nbsp;of&nbsp;weak&nbsp;references&nbsp;to&nbsp;the&nbsp;object&nbsp;(if&nbsp;defined)</tt></dd>
</dl>
<hr>
Data and other attributes inherited from <a href="pyparsing.html#ParserElement">ParserElement</a>:<br>
<dl><dt><strong>DEFAULT_WHITE_CHARS</strong> = ' <font color="#c040c0">\n\t\r</font>'</dl>

<dl><dt><strong>literalStringClass</strong> = &lt;class 'pyparsing.Literal'&gt;<dd><tt><a href="#Token">Token</a>&nbsp;to&nbsp;exactly&nbsp;match&nbsp;a&nbsp;specified&nbsp;string.</tt></dl>

<dl><dt><strong>verbose_stacktrace</strong> = False</dl>

</td></tr></table></td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#eeaa77">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Functions</strong></big></font></td></tr>
    
<tr><td bgcolor="#eeaa77"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><dl><dt><a name="-col"><strong>col</strong></a>(loc, strg)</dt><dd><tt>Returns&nbsp;current&nbsp;column&nbsp;within&nbsp;a&nbsp;string,&nbsp;counting&nbsp;newlines&nbsp;as&nbsp;line&nbsp;separators.<br>
The&nbsp;first&nbsp;column&nbsp;is&nbsp;number&nbsp;1.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{<a href="#ParserElement">ParserElement</a>.parseString}&lt;<a href="#ParserElement">ParserElement</a>.parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>
 <dl><dt><a name="-countedArray"><strong>countedArray</strong></a>(expr, intExpr<font color="#909090">=None</font>)</dt><dd><tt>Helper&nbsp;to&nbsp;define&nbsp;a&nbsp;counted&nbsp;list&nbsp;of&nbsp;expressions.<br>
This&nbsp;helper&nbsp;defines&nbsp;a&nbsp;pattern&nbsp;of&nbsp;the&nbsp;form::<br>
&nbsp;&nbsp;&nbsp;&nbsp;integer&nbsp;expr&nbsp;expr&nbsp;expr...<br>
where&nbsp;the&nbsp;leading&nbsp;integer&nbsp;tells&nbsp;how&nbsp;many&nbsp;expr&nbsp;expressions&nbsp;follow.<br>
The&nbsp;matched&nbsp;tokens&nbsp;returns&nbsp;the&nbsp;array&nbsp;of&nbsp;expr&nbsp;tokens&nbsp;as&nbsp;a&nbsp;list&nbsp;-&nbsp;the&nbsp;leading&nbsp;count&nbsp;token&nbsp;is&nbsp;suppressed.</tt></dd></dl>
 <dl><dt><a name="-delimitedList"><strong>delimitedList</strong></a>(expr, delim<font color="#909090">=','</font>, combine<font color="#909090">=False</font>)</dt><dd><tt>Helper&nbsp;to&nbsp;define&nbsp;a&nbsp;delimited&nbsp;list&nbsp;of&nbsp;expressions&nbsp;-&nbsp;the&nbsp;delimiter&nbsp;defaults&nbsp;to&nbsp;','.<br>
By&nbsp;default,&nbsp;the&nbsp;list&nbsp;elements&nbsp;and&nbsp;delimiters&nbsp;can&nbsp;have&nbsp;intervening&nbsp;whitespace,&nbsp;and<br>
comments,&nbsp;but&nbsp;this&nbsp;can&nbsp;be&nbsp;overridden&nbsp;by&nbsp;passing&nbsp;C{combine=True}&nbsp;in&nbsp;the&nbsp;constructor.<br>
If&nbsp;C{combine}&nbsp;is&nbsp;set&nbsp;to&nbsp;C{True},&nbsp;the&nbsp;matching&nbsp;tokens&nbsp;are&nbsp;returned&nbsp;as&nbsp;a&nbsp;single&nbsp;token<br>
string,&nbsp;with&nbsp;the&nbsp;delimiters&nbsp;included;&nbsp;otherwise,&nbsp;the&nbsp;matching&nbsp;tokens&nbsp;are&nbsp;returned<br>
as&nbsp;a&nbsp;list&nbsp;of&nbsp;tokens,&nbsp;with&nbsp;the&nbsp;delimiters&nbsp;suppressed.</tt></dd></dl>
 <dl><dt><a name="-dictOf"><strong>dictOf</strong></a>(key, value)</dt><dd><tt>Helper&nbsp;to&nbsp;easily&nbsp;and&nbsp;clearly&nbsp;define&nbsp;a&nbsp;dictionary&nbsp;by&nbsp;specifying&nbsp;the&nbsp;respective&nbsp;patterns<br>
for&nbsp;the&nbsp;key&nbsp;and&nbsp;value.&nbsp;&nbsp;Takes&nbsp;care&nbsp;of&nbsp;defining&nbsp;the&nbsp;C{L{<a href="#Dict">Dict</a>}},&nbsp;C{L{<a href="#ZeroOrMore">ZeroOrMore</a>}},&nbsp;and&nbsp;C{L{<a href="#Group">Group</a>}}&nbsp;tokens<br>
in&nbsp;the&nbsp;proper&nbsp;order.&nbsp;&nbsp;The&nbsp;key&nbsp;pattern&nbsp;can&nbsp;include&nbsp;delimiting&nbsp;markers&nbsp;or&nbsp;punctuation,<br>
as&nbsp;long&nbsp;as&nbsp;they&nbsp;are&nbsp;suppressed,&nbsp;thereby&nbsp;leaving&nbsp;the&nbsp;significant&nbsp;key&nbsp;text.&nbsp;&nbsp;The&nbsp;value<br>
pattern&nbsp;can&nbsp;include&nbsp;named&nbsp;results,&nbsp;so&nbsp;that&nbsp;the&nbsp;C{<a href="#Dict">Dict</a>}&nbsp;results&nbsp;can&nbsp;include&nbsp;named&nbsp;token<br>
fields.</tt></dd></dl>
 <dl><dt><a name="-downcaseTokens"><strong>downcaseTokens</strong></a>(s, l, t)</dt><dd><tt>Helper&nbsp;parse&nbsp;action&nbsp;to&nbsp;convert&nbsp;tokens&nbsp;to&nbsp;lower&nbsp;case.</tt></dd></dl>
 <dl><dt><a name="-indentedBlock"><strong>indentedBlock</strong></a>(blockStatementExpr, indentStack, indent<font color="#909090">=True</font>)</dt><dd><tt>Helper&nbsp;method&nbsp;for&nbsp;defining&nbsp;space-delimited&nbsp;indentation&nbsp;blocks,&nbsp;such&nbsp;as<br>
those&nbsp;used&nbsp;to&nbsp;define&nbsp;block&nbsp;statements&nbsp;in&nbsp;Python&nbsp;source&nbsp;code.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;blockStatementExpr&nbsp;-&nbsp;expression&nbsp;defining&nbsp;syntax&nbsp;of&nbsp;statement&nbsp;that<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;repeated&nbsp;within&nbsp;the&nbsp;indented&nbsp;block<br>
&nbsp;-&nbsp;indentStack&nbsp;-&nbsp;list&nbsp;created&nbsp;by&nbsp;caller&nbsp;to&nbsp;manage&nbsp;indentation&nbsp;stack<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(multiple&nbsp;statementWithIndentedBlock&nbsp;expressions&nbsp;within&nbsp;a&nbsp;single&nbsp;grammar<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;should&nbsp;share&nbsp;a&nbsp;common&nbsp;indentStack)<br>
&nbsp;-&nbsp;indent&nbsp;-&nbsp;boolean&nbsp;indicating&nbsp;whether&nbsp;block&nbsp;must&nbsp;be&nbsp;indented&nbsp;beyond&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;current&nbsp;level;&nbsp;set&nbsp;to&nbsp;False&nbsp;for&nbsp;block&nbsp;of&nbsp;left-most&nbsp;statements<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(default=True)<br>
&nbsp;<br>
A&nbsp;valid&nbsp;block&nbsp;must&nbsp;contain&nbsp;at&nbsp;least&nbsp;one&nbsp;C{blockStatement}.</tt></dd></dl>
 <dl><dt><a name="-infixNotation"><strong>infixNotation</strong></a>(baseExpr, opList, lpar<font color="#909090">=Suppress:("(")</font>, rpar<font color="#909090">=Suppress:(")")</font>)</dt><dd><tt>Helper&nbsp;method&nbsp;for&nbsp;constructing&nbsp;grammars&nbsp;of&nbsp;expressions&nbsp;made&nbsp;up&nbsp;of<br>
operators&nbsp;working&nbsp;in&nbsp;a&nbsp;precedence&nbsp;hierarchy.&nbsp;&nbsp;Operators&nbsp;may&nbsp;be&nbsp;unary&nbsp;or<br>
binary,&nbsp;left-&nbsp;or&nbsp;right-associative.&nbsp;&nbsp;Parse&nbsp;actions&nbsp;can&nbsp;also&nbsp;be&nbsp;attached<br>
to&nbsp;operator&nbsp;expressions.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;baseExpr&nbsp;-&nbsp;expression&nbsp;representing&nbsp;the&nbsp;most&nbsp;basic&nbsp;element&nbsp;for&nbsp;the&nbsp;nested<br>
&nbsp;-&nbsp;opList&nbsp;-&nbsp;list&nbsp;of&nbsp;tuples,&nbsp;one&nbsp;for&nbsp;each&nbsp;operator&nbsp;precedence&nbsp;level&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;expression&nbsp;grammar;&nbsp;each&nbsp;tuple&nbsp;is&nbsp;of&nbsp;the&nbsp;form<br>
&nbsp;&nbsp;&nbsp;(opExpr,&nbsp;numTerms,&nbsp;rightLeftAssoc,&nbsp;parseAction),&nbsp;where:<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;opExpr&nbsp;is&nbsp;the&nbsp;pyparsing&nbsp;expression&nbsp;for&nbsp;the&nbsp;operator;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;may&nbsp;also&nbsp;be&nbsp;a&nbsp;string,&nbsp;which&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;<a href="#Literal">Literal</a>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;numTerms&nbsp;is&nbsp;3,&nbsp;opExpr&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;two&nbsp;expressions,&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two&nbsp;operators&nbsp;separating&nbsp;the&nbsp;3&nbsp;terms<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;numTerms&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;terms&nbsp;for&nbsp;this&nbsp;operator&nbsp;(must<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be&nbsp;1,&nbsp;2,&nbsp;or&nbsp;3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;rightLeftAssoc&nbsp;is&nbsp;the&nbsp;indicator&nbsp;whether&nbsp;the&nbsp;operator&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;or&nbsp;left&nbsp;associative,&nbsp;using&nbsp;the&nbsp;pyparsing-defined<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constants&nbsp;C{opAssoc.RIGHT}&nbsp;and&nbsp;C{opAssoc.LEFT}.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;parseAction&nbsp;is&nbsp;the&nbsp;parse&nbsp;action&nbsp;to&nbsp;be&nbsp;associated&nbsp;with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressions&nbsp;matching&nbsp;this&nbsp;operator&nbsp;expression&nbsp;(the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parse&nbsp;action&nbsp;tuple&nbsp;member&nbsp;may&nbsp;be&nbsp;omitted)<br>
&nbsp;-&nbsp;lpar&nbsp;-&nbsp;expression&nbsp;for&nbsp;matching&nbsp;left-parentheses&nbsp;(default=<a href="#Suppress">Suppress</a>('('))<br>
&nbsp;-&nbsp;rpar&nbsp;-&nbsp;expression&nbsp;for&nbsp;matching&nbsp;right-parentheses&nbsp;(default=<a href="#Suppress">Suppress</a>(')'))</tt></dd></dl>
 <dl><dt><a name="-keepOriginalText"><strong>keepOriginalText</strong></a>(s, startLoc, t)</dt><dd><tt>DEPRECATED&nbsp;-&nbsp;use&nbsp;new&nbsp;helper&nbsp;method&nbsp;C{L{originalTextFor}}.<br>
Helper&nbsp;parse&nbsp;action&nbsp;to&nbsp;preserve&nbsp;original&nbsp;parsed&nbsp;text,<br>
overriding&nbsp;any&nbsp;nested&nbsp;parse&nbsp;actions.</tt></dd></dl>
 <dl><dt><a name="-line"><strong>line</strong></a>(loc, strg)</dt><dd><tt>Returns&nbsp;the&nbsp;line&nbsp;of&nbsp;text&nbsp;containing&nbsp;loc&nbsp;within&nbsp;a&nbsp;string,&nbsp;counting&nbsp;newlines&nbsp;as&nbsp;line&nbsp;separators.</tt></dd></dl>
 <dl><dt><a name="-lineno"><strong>lineno</strong></a>(loc, strg)</dt><dd><tt>Returns&nbsp;current&nbsp;line&nbsp;number&nbsp;within&nbsp;a&nbsp;string,&nbsp;counting&nbsp;newlines&nbsp;as&nbsp;line&nbsp;separators.<br>
The&nbsp;first&nbsp;line&nbsp;is&nbsp;number&nbsp;1.<br>
&nbsp;<br>
Note:&nbsp;the&nbsp;default&nbsp;parsing&nbsp;behavior&nbsp;is&nbsp;to&nbsp;expand&nbsp;tabs&nbsp;in&nbsp;the&nbsp;input&nbsp;string<br>
before&nbsp;starting&nbsp;the&nbsp;parsing&nbsp;process.&nbsp;&nbsp;See&nbsp;L{I{<a href="#ParserElement">ParserElement</a>.parseString}&lt;<a href="#ParserElement">ParserElement</a>.parseString&gt;}&nbsp;for&nbsp;more&nbsp;information<br>
on&nbsp;parsing&nbsp;strings&nbsp;containing&nbsp;C{&lt;TAB&gt;}s,&nbsp;and&nbsp;suggested&nbsp;methods&nbsp;to&nbsp;maintain&nbsp;a<br>
consistent&nbsp;view&nbsp;of&nbsp;the&nbsp;parsed&nbsp;string,&nbsp;the&nbsp;parse&nbsp;location,&nbsp;and&nbsp;line&nbsp;and&nbsp;column<br>
positions&nbsp;within&nbsp;the&nbsp;parsed&nbsp;string.</tt></dd></dl>
 <dl><dt><a name="-locatedExpr"><strong>locatedExpr</strong></a>(expr)</dt><dd><tt>Helper&nbsp;to&nbsp;decorate&nbsp;a&nbsp;returned&nbsp;token&nbsp;with&nbsp;its&nbsp;starting&nbsp;and&nbsp;ending&nbsp;locations&nbsp;in&nbsp;the&nbsp;input&nbsp;string.<br>
This&nbsp;helper&nbsp;adds&nbsp;the&nbsp;following&nbsp;results&nbsp;names:<br>
&nbsp;-&nbsp;locn_start&nbsp;=&nbsp;location&nbsp;where&nbsp;matched&nbsp;expression&nbsp;begins<br>
&nbsp;-&nbsp;locn_end&nbsp;=&nbsp;location&nbsp;where&nbsp;matched&nbsp;expression&nbsp;ends<br>
&nbsp;-&nbsp;value&nbsp;=&nbsp;the&nbsp;actual&nbsp;parsed&nbsp;results<br>
&nbsp;<br>
Be&nbsp;careful&nbsp;if&nbsp;the&nbsp;input&nbsp;text&nbsp;contains&nbsp;C{&lt;TAB&gt;}&nbsp;characters,&nbsp;you&nbsp;may&nbsp;want&nbsp;to&nbsp;call<br>
C{L{<a href="#ParserElement">ParserElement</a>.parseWithTabs}}</tt></dd></dl>
 <dl><dt><a name="-makeHTMLTags"><strong>makeHTMLTags</strong></a>(tagStr)</dt><dd><tt>Helper&nbsp;to&nbsp;construct&nbsp;opening&nbsp;and&nbsp;closing&nbsp;tag&nbsp;expressions&nbsp;for&nbsp;HTML,&nbsp;given&nbsp;a&nbsp;tag&nbsp;name</tt></dd></dl>
 <dl><dt><a name="-makeXMLTags"><strong>makeXMLTags</strong></a>(tagStr)</dt><dd><tt>Helper&nbsp;to&nbsp;construct&nbsp;opening&nbsp;and&nbsp;closing&nbsp;tag&nbsp;expressions&nbsp;for&nbsp;XML,&nbsp;given&nbsp;a&nbsp;tag&nbsp;name</tt></dd></dl>
 <dl><dt><a name="-matchOnlyAtCol"><strong>matchOnlyAtCol</strong></a>(n)</dt><dd><tt>Helper&nbsp;method&nbsp;for&nbsp;defining&nbsp;parse&nbsp;actions&nbsp;that&nbsp;require&nbsp;matching&nbsp;at&nbsp;a&nbsp;specific<br>
column&nbsp;in&nbsp;the&nbsp;input&nbsp;text.</tt></dd></dl>
 <dl><dt><a name="-matchPreviousExpr"><strong>matchPreviousExpr</strong></a>(expr)</dt><dd><tt>Helper&nbsp;to&nbsp;define&nbsp;an&nbsp;expression&nbsp;that&nbsp;is&nbsp;indirectly&nbsp;defined&nbsp;from<br>
the&nbsp;tokens&nbsp;matched&nbsp;in&nbsp;a&nbsp;previous&nbsp;expression,&nbsp;that&nbsp;is,&nbsp;it&nbsp;looks<br>
for&nbsp;a&nbsp;'repeat'&nbsp;of&nbsp;a&nbsp;previous&nbsp;expression.&nbsp;&nbsp;For&nbsp;example::<br>
&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;=&nbsp;<a href="#Word">Word</a>(nums)<br>
&nbsp;&nbsp;&nbsp;&nbsp;second&nbsp;=&nbsp;<a href="#-matchPreviousExpr">matchPreviousExpr</a>(first)<br>
&nbsp;&nbsp;&nbsp;&nbsp;matchExpr&nbsp;=&nbsp;first&nbsp;+&nbsp;":"&nbsp;+&nbsp;second<br>
will&nbsp;match&nbsp;C{"1:1"},&nbsp;but&nbsp;not&nbsp;C{"1:2"}.&nbsp;&nbsp;Because&nbsp;this&nbsp;matches&nbsp;by<br>
expressions,&nbsp;will&nbsp;*not*&nbsp;match&nbsp;the&nbsp;leading&nbsp;C{"1:1"}&nbsp;in&nbsp;C{"1:10"};<br>
the&nbsp;expressions&nbsp;are&nbsp;evaluated&nbsp;first,&nbsp;and&nbsp;then&nbsp;compared,&nbsp;so<br>
C{"1"}&nbsp;is&nbsp;compared&nbsp;with&nbsp;C{"10"}.<br>
Do&nbsp;*not*&nbsp;use&nbsp;with&nbsp;packrat&nbsp;parsing&nbsp;enabled.</tt></dd></dl>
 <dl><dt><a name="-matchPreviousLiteral"><strong>matchPreviousLiteral</strong></a>(expr)</dt><dd><tt>Helper&nbsp;to&nbsp;define&nbsp;an&nbsp;expression&nbsp;that&nbsp;is&nbsp;indirectly&nbsp;defined&nbsp;from<br>
the&nbsp;tokens&nbsp;matched&nbsp;in&nbsp;a&nbsp;previous&nbsp;expression,&nbsp;that&nbsp;is,&nbsp;it&nbsp;looks<br>
for&nbsp;a&nbsp;'repeat'&nbsp;of&nbsp;a&nbsp;previous&nbsp;expression.&nbsp;&nbsp;For&nbsp;example::<br>
&nbsp;&nbsp;&nbsp;&nbsp;first&nbsp;=&nbsp;<a href="#Word">Word</a>(nums)<br>
&nbsp;&nbsp;&nbsp;&nbsp;second&nbsp;=&nbsp;<a href="#-matchPreviousLiteral">matchPreviousLiteral</a>(first)<br>
&nbsp;&nbsp;&nbsp;&nbsp;matchExpr&nbsp;=&nbsp;first&nbsp;+&nbsp;":"&nbsp;+&nbsp;second<br>
will&nbsp;match&nbsp;C{"1:1"},&nbsp;but&nbsp;not&nbsp;C{"1:2"}.&nbsp;&nbsp;Because&nbsp;this&nbsp;matches&nbsp;a<br>
previous&nbsp;literal,&nbsp;will&nbsp;also&nbsp;match&nbsp;the&nbsp;leading&nbsp;C{"1:1"}&nbsp;in&nbsp;C{"1:10"}.<br>
If&nbsp;this&nbsp;is&nbsp;not&nbsp;desired,&nbsp;use&nbsp;C{matchPreviousExpr}.<br>
Do&nbsp;*not*&nbsp;use&nbsp;with&nbsp;packrat&nbsp;parsing&nbsp;enabled.</tt></dd></dl>
 <dl><dt><a name="-nestedExpr"><strong>nestedExpr</strong></a>(opener<font color="#909090">='('</font>, closer<font color="#909090">=')'</font>, content<font color="#909090">=None</font>, ignoreExpr<font color="#909090">=quotedString using single or double quotes</font>)</dt><dd><tt>Helper&nbsp;method&nbsp;for&nbsp;defining&nbsp;nested&nbsp;lists&nbsp;enclosed&nbsp;in&nbsp;opening&nbsp;and&nbsp;closing<br>
delimiters&nbsp;("("&nbsp;and&nbsp;")"&nbsp;are&nbsp;the&nbsp;default).<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;opener&nbsp;-&nbsp;opening&nbsp;character&nbsp;for&nbsp;a&nbsp;nested&nbsp;list&nbsp;(default="(");&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;pyparsing&nbsp;expression<br>
&nbsp;-&nbsp;closer&nbsp;-&nbsp;closing&nbsp;character&nbsp;for&nbsp;a&nbsp;nested&nbsp;list&nbsp;(default=")");&nbsp;can&nbsp;also&nbsp;be&nbsp;a&nbsp;pyparsing&nbsp;expression<br>
&nbsp;-&nbsp;content&nbsp;-&nbsp;expression&nbsp;for&nbsp;items&nbsp;within&nbsp;the&nbsp;nested&nbsp;lists&nbsp;(default=None)<br>
&nbsp;-&nbsp;ignoreExpr&nbsp;-&nbsp;expression&nbsp;for&nbsp;ignoring&nbsp;opening&nbsp;and&nbsp;closing&nbsp;delimiters&nbsp;(default=quotedString)<br>
&nbsp;<br>
If&nbsp;an&nbsp;expression&nbsp;is&nbsp;not&nbsp;provided&nbsp;for&nbsp;the&nbsp;content&nbsp;argument,&nbsp;the&nbsp;nested<br>
expression&nbsp;will&nbsp;capture&nbsp;all&nbsp;whitespace-delimited&nbsp;content&nbsp;between&nbsp;delimiters<br>
as&nbsp;a&nbsp;list&nbsp;of&nbsp;separate&nbsp;values.<br>
&nbsp;<br>
Use&nbsp;the&nbsp;C{ignoreExpr}&nbsp;argument&nbsp;to&nbsp;define&nbsp;expressions&nbsp;that&nbsp;may&nbsp;contain<br>
opening&nbsp;or&nbsp;closing&nbsp;characters&nbsp;that&nbsp;should&nbsp;not&nbsp;be&nbsp;treated&nbsp;as&nbsp;opening<br>
or&nbsp;closing&nbsp;characters&nbsp;for&nbsp;nesting,&nbsp;such&nbsp;as&nbsp;quotedString&nbsp;or&nbsp;a&nbsp;comment<br>
expression.&nbsp;&nbsp;Specify&nbsp;multiple&nbsp;expressions&nbsp;using&nbsp;an&nbsp;C{L{<a href="#Or">Or</a>}}&nbsp;or&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}.<br>
The&nbsp;default&nbsp;is&nbsp;L{quotedString},&nbsp;but&nbsp;if&nbsp;no&nbsp;expressions&nbsp;are&nbsp;to&nbsp;be&nbsp;ignored,<br>
then&nbsp;pass&nbsp;C{None}&nbsp;for&nbsp;this&nbsp;argument.</tt></dd></dl>
 <dl><dt><a name="-nullDebugAction"><strong>nullDebugAction</strong></a>(*args)</dt><dd><tt>'Do-nothing'&nbsp;debug&nbsp;action,&nbsp;to&nbsp;suppress&nbsp;debugging&nbsp;output&nbsp;during&nbsp;parsing.</tt></dd></dl>
 <dl><dt><a name="-oneOf"><strong>oneOf</strong></a>(strs, caseless<font color="#909090">=False</font>, useRegex<font color="#909090">=True</font>)</dt><dd><tt>Helper&nbsp;to&nbsp;quickly&nbsp;define&nbsp;a&nbsp;set&nbsp;of&nbsp;alternative&nbsp;Literals,&nbsp;and&nbsp;makes&nbsp;sure&nbsp;to&nbsp;do<br>
longest-first&nbsp;testing&nbsp;when&nbsp;there&nbsp;is&nbsp;a&nbsp;conflict,&nbsp;regardless&nbsp;of&nbsp;the&nbsp;input&nbsp;order,<br>
but&nbsp;returns&nbsp;a&nbsp;C{L{<a href="#MatchFirst">MatchFirst</a>}}&nbsp;for&nbsp;best&nbsp;performance.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;strs&nbsp;-&nbsp;a&nbsp;string&nbsp;of&nbsp;space-delimited&nbsp;literals,&nbsp;or&nbsp;a&nbsp;list&nbsp;of&nbsp;string&nbsp;literals<br>
&nbsp;-&nbsp;caseless&nbsp;-&nbsp;(default=False)&nbsp;-&nbsp;treat&nbsp;all&nbsp;literals&nbsp;as&nbsp;caseless<br>
&nbsp;-&nbsp;useRegex&nbsp;-&nbsp;(default=True)&nbsp;-&nbsp;as&nbsp;an&nbsp;optimization,&nbsp;will&nbsp;generate&nbsp;a&nbsp;<a href="#Regex">Regex</a><br>
&nbsp;&nbsp;&nbsp;<a href="__builtin__.html#object">object</a>;&nbsp;otherwise,&nbsp;will&nbsp;generate&nbsp;a&nbsp;C{<a href="#MatchFirst">MatchFirst</a>}&nbsp;<a href="__builtin__.html#object">object</a>&nbsp;(if&nbsp;C{caseless=True},&nbsp;or<br>
&nbsp;&nbsp;&nbsp;if&nbsp;creating&nbsp;a&nbsp;C{<a href="#Regex">Regex</a>}&nbsp;raises&nbsp;an&nbsp;exception)</tt></dd></dl>
 <dl><dt><a name="-operatorPrecedence"><strong>operatorPrecedence</strong></a> = infixNotation(baseExpr, opList, lpar<font color="#909090">=Suppress:("(")</font>, rpar<font color="#909090">=Suppress:(")")</font>)</dt><dd><tt>Helper&nbsp;method&nbsp;for&nbsp;constructing&nbsp;grammars&nbsp;of&nbsp;expressions&nbsp;made&nbsp;up&nbsp;of<br>
operators&nbsp;working&nbsp;in&nbsp;a&nbsp;precedence&nbsp;hierarchy.&nbsp;&nbsp;Operators&nbsp;may&nbsp;be&nbsp;unary&nbsp;or<br>
binary,&nbsp;left-&nbsp;or&nbsp;right-associative.&nbsp;&nbsp;Parse&nbsp;actions&nbsp;can&nbsp;also&nbsp;be&nbsp;attached<br>
to&nbsp;operator&nbsp;expressions.<br>
&nbsp;<br>
Parameters:<br>
&nbsp;-&nbsp;baseExpr&nbsp;-&nbsp;expression&nbsp;representing&nbsp;the&nbsp;most&nbsp;basic&nbsp;element&nbsp;for&nbsp;the&nbsp;nested<br>
&nbsp;-&nbsp;opList&nbsp;-&nbsp;list&nbsp;of&nbsp;tuples,&nbsp;one&nbsp;for&nbsp;each&nbsp;operator&nbsp;precedence&nbsp;level&nbsp;in&nbsp;the<br>
&nbsp;&nbsp;&nbsp;expression&nbsp;grammar;&nbsp;each&nbsp;tuple&nbsp;is&nbsp;of&nbsp;the&nbsp;form<br>
&nbsp;&nbsp;&nbsp;(opExpr,&nbsp;numTerms,&nbsp;rightLeftAssoc,&nbsp;parseAction),&nbsp;where:<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;opExpr&nbsp;is&nbsp;the&nbsp;pyparsing&nbsp;expression&nbsp;for&nbsp;the&nbsp;operator;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;may&nbsp;also&nbsp;be&nbsp;a&nbsp;string,&nbsp;which&nbsp;will&nbsp;be&nbsp;converted&nbsp;to&nbsp;a&nbsp;<a href="#Literal">Literal</a>;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;numTerms&nbsp;is&nbsp;3,&nbsp;opExpr&nbsp;is&nbsp;a&nbsp;tuple&nbsp;of&nbsp;two&nbsp;expressions,&nbsp;for&nbsp;the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;two&nbsp;operators&nbsp;separating&nbsp;the&nbsp;3&nbsp;terms<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;numTerms&nbsp;is&nbsp;the&nbsp;number&nbsp;of&nbsp;terms&nbsp;for&nbsp;this&nbsp;operator&nbsp;(must<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be&nbsp;1,&nbsp;2,&nbsp;or&nbsp;3)<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;rightLeftAssoc&nbsp;is&nbsp;the&nbsp;indicator&nbsp;whether&nbsp;the&nbsp;operator&nbsp;is<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right&nbsp;or&nbsp;left&nbsp;associative,&nbsp;using&nbsp;the&nbsp;pyparsing-defined<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;constants&nbsp;C{opAssoc.RIGHT}&nbsp;and&nbsp;C{opAssoc.LEFT}.<br>
&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;parseAction&nbsp;is&nbsp;the&nbsp;parse&nbsp;action&nbsp;to&nbsp;be&nbsp;associated&nbsp;with<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressions&nbsp;matching&nbsp;this&nbsp;operator&nbsp;expression&nbsp;(the<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parse&nbsp;action&nbsp;tuple&nbsp;member&nbsp;may&nbsp;be&nbsp;omitted)<br>
&nbsp;-&nbsp;lpar&nbsp;-&nbsp;expression&nbsp;for&nbsp;matching&nbsp;left-parentheses&nbsp;(default=<a href="#Suppress">Suppress</a>('('))<br>
&nbsp;-&nbsp;rpar&nbsp;-&nbsp;expression&nbsp;for&nbsp;matching&nbsp;right-parentheses&nbsp;(default=<a href="#Suppress">Suppress</a>(')'))</tt></dd></dl>
 <dl><dt><a name="-originalTextFor"><strong>originalTextFor</strong></a>(expr, asString<font color="#909090">=True</font>)</dt><dd><tt>Helper&nbsp;to&nbsp;return&nbsp;the&nbsp;original,&nbsp;untokenized&nbsp;text&nbsp;for&nbsp;a&nbsp;given&nbsp;expression.&nbsp;&nbsp;Useful&nbsp;to<br>
restore&nbsp;the&nbsp;parsed&nbsp;fields&nbsp;of&nbsp;an&nbsp;HTML&nbsp;start&nbsp;tag&nbsp;into&nbsp;the&nbsp;raw&nbsp;tag&nbsp;text&nbsp;itself,&nbsp;or&nbsp;to<br>
revert&nbsp;separate&nbsp;tokens&nbsp;with&nbsp;intervening&nbsp;whitespace&nbsp;back&nbsp;to&nbsp;the&nbsp;original&nbsp;matching<br>
input&nbsp;text.&nbsp;Simpler&nbsp;to&nbsp;use&nbsp;than&nbsp;the&nbsp;parse&nbsp;action&nbsp;C{L{keepOriginalText}},&nbsp;and&nbsp;does&nbsp;not<br>
require&nbsp;the&nbsp;inspect&nbsp;module&nbsp;to&nbsp;chase&nbsp;up&nbsp;the&nbsp;call&nbsp;stack.&nbsp;&nbsp;By&nbsp;default,&nbsp;returns&nbsp;a&nbsp;<br>
string&nbsp;containing&nbsp;the&nbsp;original&nbsp;parsed&nbsp;text.&nbsp;&nbsp;<br>
&nbsp;<br>
If&nbsp;the&nbsp;optional&nbsp;C{asString}&nbsp;argument&nbsp;is&nbsp;passed&nbsp;as&nbsp;C{False},&nbsp;then&nbsp;the&nbsp;return&nbsp;value&nbsp;is&nbsp;a&nbsp;<br>
C{L{<a href="#ParseResults">ParseResults</a>}}&nbsp;containing&nbsp;any&nbsp;results&nbsp;names&nbsp;that&nbsp;were&nbsp;originally&nbsp;matched,&nbsp;and&nbsp;a&nbsp;<br>
single&nbsp;token&nbsp;containing&nbsp;the&nbsp;original&nbsp;matched&nbsp;text&nbsp;from&nbsp;the&nbsp;input&nbsp;string.&nbsp;&nbsp;So&nbsp;if&nbsp;<br>
the&nbsp;expression&nbsp;passed&nbsp;to&nbsp;C{L{originalTextFor}}&nbsp;contains&nbsp;expressions&nbsp;with&nbsp;defined<br>
results&nbsp;names,&nbsp;you&nbsp;must&nbsp;set&nbsp;C{asString}&nbsp;to&nbsp;C{False}&nbsp;if&nbsp;you&nbsp;want&nbsp;to&nbsp;preserve&nbsp;those<br>
results&nbsp;name&nbsp;values.</tt></dd></dl>
 <dl><dt><a name="-removeQuotes"><strong>removeQuotes</strong></a>(s, l, t)</dt><dd><tt>Helper&nbsp;parse&nbsp;action&nbsp;for&nbsp;removing&nbsp;quotation&nbsp;marks&nbsp;from&nbsp;parsed&nbsp;quoted&nbsp;strings.<br>
To&nbsp;use,&nbsp;add&nbsp;this&nbsp;parse&nbsp;action&nbsp;to&nbsp;quoted&nbsp;string&nbsp;using::<br>
&nbsp;&nbsp;quotedString.setParseAction(&nbsp;removeQuotes&nbsp;)</tt></dd></dl>
 <dl><dt><strong>replaceHTMLEntity</strong> <em>lambda</em> t</dt></dl>
 <dl><dt><a name="-replaceWith"><strong>replaceWith</strong></a>(replStr)</dt><dd><tt>Helper&nbsp;method&nbsp;for&nbsp;common&nbsp;parse&nbsp;actions&nbsp;that&nbsp;simply&nbsp;return&nbsp;a&nbsp;literal&nbsp;value.&nbsp;&nbsp;Especially<br>
useful&nbsp;when&nbsp;used&nbsp;with&nbsp;C{L{transformString&lt;<a href="#ParserElement">ParserElement</a>.transformString&gt;}()}.</tt></dd></dl>
 <dl><dt><a name="-srange"><strong>srange</strong></a>(s)</dt><dd><tt>Helper&nbsp;to&nbsp;easily&nbsp;define&nbsp;string&nbsp;ranges&nbsp;for&nbsp;use&nbsp;in&nbsp;<a href="#Word">Word</a>&nbsp;construction.&nbsp;&nbsp;Borrows<br>
syntax&nbsp;from&nbsp;regexp&nbsp;'[]'&nbsp;string&nbsp;range&nbsp;definitions::<br>
&nbsp;&nbsp;&nbsp;<a href="#-srange">srange</a>("[0-9]")&nbsp;&nbsp;&nbsp;-&gt;&nbsp;"0123456789"<br>
&nbsp;&nbsp;&nbsp;<a href="#-srange">srange</a>("[a-z]")&nbsp;&nbsp;&nbsp;-&gt;&nbsp;"abcdefghijklmnopqrstuvwxyz"<br>
&nbsp;&nbsp;&nbsp;<a href="#-srange">srange</a>("[a-z$_]")&nbsp;-&gt;&nbsp;"abcdefghijklmnopqrstuvwxyz$_"<br>
The&nbsp;input&nbsp;string&nbsp;must&nbsp;be&nbsp;enclosed&nbsp;in&nbsp;[]'s,&nbsp;and&nbsp;the&nbsp;returned&nbsp;string&nbsp;is&nbsp;the&nbsp;expanded<br>
character&nbsp;set&nbsp;joined&nbsp;into&nbsp;a&nbsp;single&nbsp;string.<br>
The&nbsp;values&nbsp;enclosed&nbsp;in&nbsp;the&nbsp;[]'s&nbsp;may&nbsp;be::<br>
&nbsp;&nbsp;&nbsp;a&nbsp;single&nbsp;character<br>
&nbsp;&nbsp;&nbsp;an&nbsp;escaped&nbsp;character&nbsp;with&nbsp;a&nbsp;leading&nbsp;backslash&nbsp;(such&nbsp;as&nbsp;\-&nbsp;or&nbsp;\])<br>
&nbsp;&nbsp;&nbsp;an&nbsp;escaped&nbsp;hex&nbsp;character&nbsp;with&nbsp;a&nbsp;leading&nbsp;'\x'&nbsp;(\x21,&nbsp;which&nbsp;is&nbsp;a&nbsp;'!'&nbsp;character)&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(\0x##&nbsp;is&nbsp;also&nbsp;supported&nbsp;for&nbsp;backwards&nbsp;compatibility)&nbsp;<br>
&nbsp;&nbsp;&nbsp;an&nbsp;escaped&nbsp;octal&nbsp;character&nbsp;with&nbsp;a&nbsp;leading&nbsp;'\0'&nbsp;(\041,&nbsp;which&nbsp;is&nbsp;a&nbsp;'!'&nbsp;character)<br>
&nbsp;&nbsp;&nbsp;a&nbsp;range&nbsp;of&nbsp;any&nbsp;of&nbsp;the&nbsp;above,&nbsp;separated&nbsp;by&nbsp;a&nbsp;dash&nbsp;('a-z',&nbsp;etc.)<br>
&nbsp;&nbsp;&nbsp;any&nbsp;combination&nbsp;of&nbsp;the&nbsp;above&nbsp;('aeiouy',&nbsp;'a-zA-Z0-9_$',&nbsp;etc.)</tt></dd></dl>
 <dl><dt><a name="-traceParseAction"><strong>traceParseAction</strong></a>(f)</dt><dd><tt>Decorator&nbsp;for&nbsp;debugging&nbsp;parse&nbsp;actions.</tt></dd></dl>
 <dl><dt><a name="-ungroup"><strong>ungroup</strong></a>(expr)</dt><dd><tt>Helper&nbsp;to&nbsp;undo&nbsp;pyparsing's&nbsp;default&nbsp;grouping&nbsp;of&nbsp;<a href="#And">And</a>&nbsp;expressions,&nbsp;even<br>
if&nbsp;all&nbsp;but&nbsp;one&nbsp;are&nbsp;non-empty.</tt></dd></dl>
 <dl><dt><a name="-upcaseTokens"><strong>upcaseTokens</strong></a>(s, l, t)</dt><dd><tt>Helper&nbsp;parse&nbsp;action&nbsp;to&nbsp;convert&nbsp;tokens&nbsp;to&nbsp;upper&nbsp;case.</tt></dd></dl>
 <dl><dt><a name="-withAttribute"><strong>withAttribute</strong></a>(*args, **attrDict)</dt><dd><tt>Helper&nbsp;to&nbsp;create&nbsp;a&nbsp;validating&nbsp;parse&nbsp;action&nbsp;to&nbsp;be&nbsp;used&nbsp;with&nbsp;start&nbsp;tags&nbsp;created<br>
with&nbsp;C{L{makeXMLTags}}&nbsp;or&nbsp;C{L{makeHTMLTags}}.&nbsp;Use&nbsp;C{withAttribute}&nbsp;to&nbsp;qualify&nbsp;a&nbsp;starting&nbsp;tag<br>
with&nbsp;a&nbsp;required&nbsp;attribute&nbsp;value,&nbsp;to&nbsp;avoid&nbsp;false&nbsp;matches&nbsp;on&nbsp;common&nbsp;tags&nbsp;such&nbsp;as<br>
C{&lt;TD&gt;}&nbsp;or&nbsp;C{&lt;DIV&gt;}.<br>
&nbsp;<br>
Call&nbsp;C{withAttribute}&nbsp;with&nbsp;a&nbsp;series&nbsp;of&nbsp;attribute&nbsp;names&nbsp;and&nbsp;values.&nbsp;Specify&nbsp;the&nbsp;list<br>
of&nbsp;filter&nbsp;attributes&nbsp;names&nbsp;and&nbsp;values&nbsp;as:<br>
&nbsp;-&nbsp;keyword&nbsp;arguments,&nbsp;as&nbsp;in&nbsp;C{(align="right")},&nbsp;or<br>
&nbsp;-&nbsp;as&nbsp;an&nbsp;explicit&nbsp;dict&nbsp;with&nbsp;C{**}&nbsp;operator,&nbsp;when&nbsp;an&nbsp;attribute&nbsp;name&nbsp;is&nbsp;also&nbsp;a&nbsp;Python<br>
&nbsp;&nbsp;&nbsp;reserved&nbsp;word,&nbsp;as&nbsp;in&nbsp;C{**{"class":"Customer",&nbsp;"align":"right"}}<br>
&nbsp;-&nbsp;a&nbsp;list&nbsp;of&nbsp;name-value&nbsp;tuples,&nbsp;as&nbsp;in&nbsp;(&nbsp;("ns1:class",&nbsp;"Customer"),&nbsp;("ns2:align","right")&nbsp;)<br>
For&nbsp;attribute&nbsp;names&nbsp;with&nbsp;a&nbsp;namespace&nbsp;prefix,&nbsp;you&nbsp;must&nbsp;use&nbsp;the&nbsp;second&nbsp;form.&nbsp;&nbsp;Attribute<br>
names&nbsp;are&nbsp;matched&nbsp;insensitive&nbsp;to&nbsp;upper/lower&nbsp;case.<br>
&nbsp;<br>
If&nbsp;just&nbsp;testing&nbsp;for&nbsp;C{class}&nbsp;(with&nbsp;or&nbsp;without&nbsp;a&nbsp;namespace),&nbsp;use&nbsp;C{L{withClass}}.<br>
&nbsp;<br>
To&nbsp;verify&nbsp;that&nbsp;the&nbsp;attribute&nbsp;exists,&nbsp;but&nbsp;without&nbsp;specifying&nbsp;a&nbsp;value,&nbsp;pass<br>
C{withAttribute.ANY_VALUE}&nbsp;as&nbsp;the&nbsp;value.</tt></dd></dl>
 <dl><dt><a name="-withClass"><strong>withClass</strong></a>(classname, namespace<font color="#909090">=''</font>)</dt><dd><tt>Simplified&nbsp;version&nbsp;of&nbsp;C{L{withAttribute}}&nbsp;when&nbsp;matching&nbsp;on&nbsp;a&nbsp;div&nbsp;class&nbsp;-&nbsp;made<br>
difficult&nbsp;because&nbsp;C{class}&nbsp;is&nbsp;a&nbsp;reserved&nbsp;word&nbsp;in&nbsp;Python.</tt></dd></dl>
</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#55aa55">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Data</strong></big></font></td></tr>
    
<tr><td bgcolor="#55aa55"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%"><strong>__all__</strong> = ['And', 'CaselessKeyword', 'CaselessLiteral', 'CharsNotIn', 'Combine', 'Dict', 'Each', 'Empty', 'FollowedBy', 'Forward', 'GoToColumn', 'Group', 'Keyword', 'LineEnd', 'LineStart', 'Literal', 'MatchFirst', 'NoMatch', 'NotAny', 'OneOrMore', ...]<br>
<strong>__author__</strong> = 'Paul McGuire &lt;ptmcg@users.sourceforge.net&gt;'<br>
<strong>__versionTime__</strong> = '9 Nov 2015 19:03'<br>
<strong>__version__</strong> = '2.0.6'<br>
<strong>alphanums</strong> = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'<br>
<strong>alphas</strong> = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'<br>
<strong>alphas8bit</strong> = u'<font color="#c040c0">\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc7\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd0\xd1\xd2\xd3\xd4\xd5\xd6\xd8\xd9\xda\xdb\xdc\xdd\xde\xdf\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf8\xf9\xfa\xfb\xfc\xfd\xfe\xff</font>'<br>
<strong>anyCloseTag</strong> = &lt;/W:(abcd...,abcd...)&gt;<br>
<strong>anyOpenTag</strong> = &lt;W:(abcd...,abcd...)&gt;<br>
<strong>cStyleComment</strong> = C style comment<br>
<strong>commaSeparatedList</strong> = commaSeparatedList<br>
<strong>commonHTMLEntity</strong> = Combine:({"&amp;" Re:('gt|lt|amp|nbsp|quot') ";"})<br>
<strong>cppStyleComment</strong> = C++ style comment<br>
<strong>dblQuotedString</strong> = string enclosed in double quotes<br>
<strong>dblSlashComment</strong> = // comment<br>
<strong>empty</strong> = empty<br>
<strong>hexnums</strong> = '0123456789ABCDEFabcdef'<br>
<strong>htmlComment</strong> = Re:('&lt;!--[\\s\\S]*?--&gt;')<br>
<strong>javaStyleComment</strong> = C++ style comment<br>
<strong>lineEnd</strong> = lineEnd<br>
<strong>lineStart</strong> = lineStart<br>
<strong>nums</strong> = '0123456789'<br>
<strong>opAssoc</strong> = &lt;pyparsing._Constants object&gt;<br>
<strong>printables</strong> = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!"#$%&amp;<font color="#c040c0">\'</font>()*+,-./:;&lt;=&gt;?@[<font color="#c040c0">\\</font>]^_`{|}~'<br>
<strong>punc8bit</strong> = u'<font color="#c040c0">\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf\xb0\xb1\xb2\xb3\xb4\xb5\xb6\xb7\xb8\xb9\xba\xbb\xbc\xbd\xbe\xbf\xd7\xf7</font>'<br>
<strong>pythonStyleComment</strong> = Python style comment<br>
<strong>quotedString</strong> = quotedString using single or double quotes<br>
<strong>restOfLine</strong> = Re:('.*')<br>
<strong>sglQuotedString</strong> = string enclosed in single quotes<br>
<strong>stringEnd</strong> = stringEnd<br>
<strong>stringStart</strong> = stringStart<br>
<strong>unicodeString</strong> = Combine:({"u" quotedString using single or double quotes})</td></tr></table><p>
<table width="100%" cellspacing=0 cellpadding=2 border=0 summary="section">
<tr bgcolor="#7799ee">
<td colspan=3 valign=bottom>&nbsp;<br>
<font color="#ffffff" face="helvetica, arial"><big><strong>Author</strong></big></font></td></tr>
    
<tr><td bgcolor="#7799ee"><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt></td><td>&nbsp;</td>
<td width="100%">Paul&nbsp;McGuire&nbsp;&lt;ptmcg@users.sourceforge.net&gt;</td></tr></table>
</body></html>