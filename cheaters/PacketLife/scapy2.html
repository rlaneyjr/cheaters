<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Scapy</title>
  <style type="text/css">code{white-space: pre;}</style>
</head>
<body>
<div id="header">
<img src="PacketLife/png/scapy.png" style="width:100%;max-width:100%">
</div>
<h1 id="scapy">Scapy</h1>
<p>Please also have a look at the <a href="http://www.secdev.org/projects/scapy/doc/usage.html#interactive-tutorial">interactive tutorial</a> in the official documentation, that may be more up to date.</p>
<h2 id="quick-demo-an-interactive-session">Quick demo : an interactive session</h2>
<p>If you are new to python and you really don't understand a word because of that, or if you want to learn this language, take an hour to read the very good tutorial from Guido Van Rossum here: <a href="http://docs.python.org/tutorial/" class="uri">http://docs.python.org/tutorial/</a>. After that, you'll know python :) (really!). For a more in-depth tutorial <a href="http://diveintopython.org/toc/index.html">Dive Into Python</a> is a very good start too.</p>
<p>Scapy uses the python interpreter as a command board. That means that you can use directly python language (assign variables, use loops, define functions, etc.)</p>
<p>The idea is simple. Scapy mainly does two things : sending packets and receiving answers. You define a set of packets, it sends them, receives answers, matches requests with answers and returns a list of packet couples (request, answer) and a list of unmatched packets. This has the big advantage over tools like nmap or hping that an answer is not reduced to (open/closed/filtered), but is the whole packet.</p>
<p>On top of this can be build more high level functions, for example one that does traceroutes and give as a result only the start TTL of the request and the source IP of the answer. One that pings a whole network and gives the list of machines answering. One that does a portscan and returns a LaTeX report.</p>
<p>First, we play a bit and create 4 IP packets at once. Let's see how it works. We first instantiate the IP class. Then, we instantiate it again and we provide a destination that is worth 4 IP addresses (/30 gives the netmask). Using a Python idiom, we develop this implicit packet in a set of explicit packets.</p>
<pre><code># ./scapy.py
Welcome to Scapy (0.9.17.108beta)
&gt;&gt;&gt; IP()
&lt;IP |&gt;
&gt;&gt;&gt; target=&quot;www.target.com&quot;
&gt;&gt;&gt; target=&quot;www.target.com/30&quot;
&gt;&gt;&gt; ip=IP(dst=target)
&gt;&gt;&gt; ip
&lt;IP dst=&lt;Net www.target.com/30&gt; |&gt;
&gt;&gt;&gt; [p for p in ip]
[&lt;IP dst=207.171.175.28 |&gt;, &lt;IP dst=207.171.175.29 |&gt;, 
 &lt;IP dst=207.171.175.30 |&gt;, &lt;IP dst=207.171.175.31 |&gt;]</code></pre>
<p>The configuration is hold into a variable named <code>conf</code>, which is saved in the session.</p>
<pre><code>&gt;&gt;&gt; conf
Version    = 0.9.17.108beta
BTsocket   = &lt;class __main__.BluetoothSocket at 0xb7d73f2c&gt;
IPCountry_base = &#39;GeoIPCountry4Scapy.gz&#39;
L2listen   = &lt;class __main__.L2ListenSocket at 0xb7d73e3c&gt;
L2socket   = &lt;class __main__.L2Socket at 0xb7d73e0c&gt;
L3socket   = &lt;class __main__.L3PacketSocket at 0xb7d73ddc&gt;
checkIPID  = 1
checkIPaddr = 1
checkIPsrc = 1
color_theme = &lt;class __main__.HTMLTheme at 0xb7d263ec&gt;
countryLoc_base = &#39;countryLoc.csv&#39;
debug_dissector = 0
debug_match = 0
except_filter = &#39;&#39;
gnuplot_world = &#39;world.dat&#39;
histfile   = &#39;/home/pbi/.scapy_history&#39;
iface      = &#39;eth1&#39;
nmap_base  = &#39;/usr/share/nmap/nmap-os-fingerprints&#39;
p0f_base   = &#39;/etc/p0f.fp&#39;
padding    = 1
promisc    = 1
prompt     = &#39;&gt;&gt;&gt; &#39;
queso_base = &#39;/etc/queso.conf&#39;
route      = 
Network         Netmask         Gateway         Iface           Output IP
127.0.0.0       255.0.0.0       0.0.0.0         lo              127.0.0.1      
192.168.5.0     255.255.255.0   0.0.0.0         eth1            192.168.5.21   
0.0.0.0         0.0.0.0         192.168.5.1     eth1            192.168.5.21   
session    = &#39;mysession&#39;
session_tracking = {}
sniff_promisc = 1
stealth    = &#39;not implemented&#39;
verb       = 2
warning_threshold = 5
wepkey     = &#39;&#39;
&gt;&gt;&gt; conf.verb=1
&gt;&gt;&gt; conf.color_theme=RastaTheme()</code></pre>
<p>Now, let's manipulate some packets. Here you can see layers that are supported for the moment. It's really easy to add one.</p>
<pre><code>&gt;&gt;&gt; ls()
ARP        : ARP
BOOTP      : BOOTP
CookedLinux : cooked linux
DHCP       : DHCP options
DNS        : DNS
DNSQR      : DNS Question Record
DNSRR      : DNS Resource Record
Dot11      : 802.11
Dot11ATIM  : 802.11 ATIM
Dot11AssoReq : 802.11 Association Request
Dot11AssoResp : 802.11 Association Response
Dot11Auth  : 802.11 Authentication
Dot11Beacon : 802.11 Beacon
Dot11Deauth : 802.11 Deauthentication
Dot11Disas : 802.11 Disassociation
Dot11Elt   : 802.11 Information Element
Dot11ProbeReq : 802.11 Probe Request
Dot11ProbeResp : 802.11 Probe Response
Dot11ReassoReq : 802.11 Reassociation Request
Dot11ReassoResp : 802.11 Reassociation Response
Dot11WEP   : 802.11 WEP packet
Dot1Q      : 802.1Q
Dot3       : 802.3
EAP        : EAP
EAPOL      : EAPOL
Ether      : Ethernet
GPRS       : GPRSdummy
HSRP       : HSRP
ICMP       : ICMP
ICMPerror  : ICMP in ICMP
IP         : IP
IPerror    : IP in ICMP
ISAKMP     : ISAKMP
ISAKMP_class : abstract packet
ISAKMP_payload : ISAKMP payload
ISAKMP_payload_Hash : ISAKMP Hash
ISAKMP_payload_ID : ISAKMP Identification
ISAKMP_payload_KE : ISAKMP Key Exchange
ISAKMP_payload_Nonce : ISAKMP Nonce
ISAKMP_payload_Proposal : IKE proposal
ISAKMP_payload_SA : ISAKMP SA
ISAKMP_payload_Transform : IKE Transform
ISAKMP_payload_VendorID : ISAKMP Vendor ID
IrLAPCommand : IrDA Link Access Protocol Command
IrLAPHead  : IrDA Link Access Protocol Header
IrLMP      : IrDA Link Management Protocol
L2CAP      : L2CAP
L2CAP_CmdRej : L2CAP Command Rej
L2CAP_ConfReq : L2CAP Conf Req
L2CAP_ConfResp : L2CAP Conf Resp
L2CAP_ConnReq : L2CAP Conn Req
L2CAP_ConnResp : L2CAP Conn Resp
L2CAP_DisconnReq : L2CAP Disconn Req
L2CAP_DisconnResp : L2CAP Disconn Resp
L2CAP_InfoReq : L2CAP Info Req
L2CAP_InfoResp : L2CAP Info Resp
LLC        : LLC
MGCP       : MGCP
NBNSNodeStatusResponse : NBNS Node Status Response
NBNSNodeStatusResponseEnd : NBNS Node Status Response
NBNSNodeStatusResponseService : NBNS Node Status Response Service
NBNSQueryRequest : NBNS query request
NBNSQueryResponse : NBNS query response
NBNSQueryResponseNegative : NBNS query response (negative)
NBNSRequest : NBNS request
NBNSWackResponse : NBNS Wait for Acknowledgement Response
NBTDatagram : NBT Datagram Packet
NBTSession : NBT Session Packet
NTP        : NTP
NetBIOS_DS : NetBIOS datagram service
PPP        : PPP Link Layer
PPPoE      : PPP over Ethernet
PPPoED     : PPP over Ethernet Discovery
Packet     : abstract packet
Padding    : Padding
PrismHeader : Prism header
RIP        : RIP header
RIPEntry   : RIP entry
Radius     : Radius
Raw        : Raw
SMBMailSlot : SMB Mail Slot Protocol
SMBNegociate_Protocol_Request_Header : SMBNegociate Protocol Request Header
SMBNegociate_Protocol_Request_Tail : SMB Negociate Protocol Request Tail
SMBNegociate_Protocol_Response_Advanced_Security : SMBNegociate Protocol Response Advanced Security
SMBNegociate_Protocol_Response_No_Security : SMBNegociate Protocol Response No Security
SMBNegociate_Protocol_Response_No_Security_No_Key : abstract packet
SMBNetlogon_Protocol_Response_Header : SMBNetlogon Protocol Response Header
SMBNetlogon_Protocol_Response_Tail_LM20 : SMB Netlogon Protocol Response Tail LM20
SMBNetlogon_Protocol_Response_Tail_SAM : SMB Netlogon Protocol Response Tail SAM
SMBSession_Setup_AndX_Request : Session Setup AndX Request
SMBSession_Setup_AndX_Response : Session Setup AndX Response
SNAP       : SNAP
STP        : Spanning Tree Protocol
SebekHead  : Sebek header
SebekV1    : Sebek v1
SebekV2    : Sebek v2
SebekV2Sock : Sebek v2 socket
Skinny     : Skinny
TCP        : TCP
TCPerror   : TCP in ICMP
UDP        : UDP
UDPerror   : UDP in ICMP

&gt;&gt;&gt; IP()
&lt;IP |&gt;
&gt;&gt;&gt; a=IP(dst=&quot;172.16.1.40&quot;)
&gt;&gt;&gt; a
&lt;IP dst=172.16.1.40 |&gt;
&gt;&gt;&gt; a.dst
&#39;172.16.1.40&#39;
&gt;&gt;&gt; a.ttl
64</code></pre>
<p>A layer has default values for every field, so that you don't have to fill them all. If you give a value to the field, it will overload the default value. If you delete the field, the default value will be back. Moreover, fields with default values are not displayed.</p>
<pre><code>&gt;&gt;&gt; a.ttl=32
&gt;&gt;&gt; a
&lt;IP ttl=32 dst=172.16.1.40 |&gt;
&gt;&gt;&gt; del(a.ttl)
&gt;&gt;&gt; a
&lt;IP dst=172.16.1.40 |&gt;
&gt;&gt;&gt; a.ttl
64</code></pre>
<p>Fields can be made human readable. For example IP and TCP flags : (note the rfc3514 compliance for IP).</p>
<pre><code>&gt;&gt;&gt; t=TCP()
&gt;&gt;&gt; t.flags=&quot;SA&quot;
&gt;&gt;&gt; t.flags 
18
&gt;&gt;&gt; t
&lt;TCP flags=SA |&gt;
&gt;&gt;&gt; t.flags=23
&gt;&gt;&gt; t
&lt;TCP flags=FSRA |&gt;
&gt;&gt;&gt; i=IP(flags=&quot;DF+MF&quot;)
&gt;&gt;&gt; i.flags
3
&gt;&gt;&gt; i
&lt;IP flags=MF+DF |&gt;
&gt;&gt;&gt; i.flags=6
&gt;&gt;&gt; i
&lt;IP flags=DF+evil |&gt;</code></pre>
<p>Some default values are not constant values. For example, the source IP of a packet will default to the IP of the interface that should be used to send a packet to the given destination, according to the local routing tables.</p>
<pre><code>&gt;&gt;&gt; a.dst
&#39;172.16.1.40&#39;
&gt;&gt;&gt; a.src
&#39;172.16.1.24&#39;
&gt;&gt;&gt; del(a.dst)
&gt;&gt;&gt; a.dst
&#39;127.0.0.1&#39;
&gt;&gt;&gt; a.src
&#39;127.0.0.1&#39;
&gt;&gt;&gt; a.dst=&quot;192.168.11.10&quot;
&gt;&gt;&gt; a.src
&#39;192.168.11.1&#39;
&gt;&gt;&gt; a.dst=target
&gt;&gt;&gt; a.src
&#39;172.16.1.24&#39;
&gt;&gt;&gt; a.src=&quot;1.2.3.4&quot;
&gt;&gt;&gt; a
&lt;IP src=1.2.3.4 dst=&lt;Net www.target.com&gt; |&gt;</code></pre>
<p>Here, you can guess that my routing table looks like :</p>
<pre><code>$ route -n 
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
172.16.0.0      0.0.0.0         255.255.0.0     U     0      0        0 eth0
192.168.11.0    0.0.0.0         255.255.255.0   U     0      0        0 eth1
0.0.0.0         172.16.1.1      0.0.0.0         UG    0      0        0 eth0</code></pre>
<p>We will see later that scapy has its own routing table.</p>
<p>The <code>/</code> operator has been used as a composition operator between two layers. When doing so, the lower layer can have one or more of its defaults fields overloaded according to the upper layer. (You still can give the value you want). A string can be used as a raw layer.</p>
<pre><code>&gt;&gt;&gt; IP()
&lt;IP |&gt;
&gt;&gt;&gt; IP()/TCP()
&lt;IP frag=0 proto=TCP |&lt;TCP |&gt;&gt;
&gt;&gt;&gt; Ether()/IP()/TCP()
&lt;Ether type=0x800 |&lt;IP frag=0 proto=TCP |&lt;TCP |&gt;&gt;&gt;
&gt;&gt;&gt; IP()/TCP()/&quot;GET / HTTP/1.0\r\n\r\n&quot;
&lt;IP frag=0 proto=TCP |&lt;TCP |&lt;Raw load=&#39;GET / HTTP/1.0\r\n\r\n&#39; |&gt;&gt;&gt;
&gt;&gt;&gt; Ether()/IP()/IP()/UDP()
&lt;Ether type=0x800 |&lt;IP frag=0 proto=IP |&lt;IP frag=0 proto=UDP |&lt;UDP |&gt;&gt;&gt;&gt;
&gt;&gt;&gt; IP(proto=55)/TCP()
&lt;IP frag=0 proto=55 |&lt;TCP |&gt;&gt;</code></pre>
<p>Each packet can be build or dissected (note: in python <code>_</code> (underscode) is the latest result) :</p>
<pre><code>&gt;&gt;&gt; str(IP())
&#39;E\x00\x00\x14\x00\x01\x00\x00@\x00|\xe7\x7f\x00\x00\x01\x7f\x00\x00\x01&#39;
&gt;&gt;&gt; IP(_)
&lt;IP version=4L ihl=5L tos=0x0 len=20 id=1 flags= frag=0L ttl=64 proto=IP
 chksum=0x7ce7 src=127.0.0.1 dst=127.0.0.1 |&gt;
&gt;&gt;&gt;  a=Ether()/IP(dst=&quot;www.slashdot.org&quot;)/TCP()/&quot;GET /index.html HTTP/1.0 \n\n&quot;
&gt;&gt;&gt;  hexdump(a)   
00 02 15 37 A2 44 00 AE F3 52 AA D1 08 00 45 00  ...7.D...R....E.
00 43 00 01 00 00 40 06 78 3C C0 A8 05 15 42 23  .C....@.x&lt;....B#
FA 97 00 14 00 50 00 00 00 00 00 00 00 00 50 02  .....P........P.
20 00 BB 39 00 00 47 45 54 20 2F 69 6E 64 65 78   ..9..GET /index
2E 68 74 6D 6C 20 48 54 54 50 2F 31 2E 30 20 0A  .html HTTP/1.0 .
0A                                               .
&gt;&gt;&gt; b=str(a)
&gt;&gt;&gt; b
&#39;\x00\x02\x157\xa2D\x00\xae\xf3R\xaa\xd1\x08\x00E\x00\x00C\x00\x01\x00\x00@\x06x&lt;\xc0
 \xa8\x05\x15B#\xfa\x97\x00\x14\x00P\x00\x00\x00\x00\x00\x00\x00\x00P\x02 \x00
 \xbb9\x00\x00GET /index.html HTTP/1.0 \n\n&#39;
&gt;&gt;&gt; c=Ether(b)
&gt;&gt;&gt; c
&lt;Ether dst=00:02:15:37:a2:44 src=00:ae:f3:52:aa:d1 type=0x800 |&lt;IP version=4L
 ihl=5L tos=0x0 len=67 id=1 flags= frag=0L ttl=64 proto=TCP chksum=0x783c
 src=192.168.5.21 dst=66.35.250.151  |&lt;TCP sport=20 dport=80 seq=0L
 ack=0L dataofs=5L reserved=0L flags=S window=8192 chksum=0xbb39 urgptr=0
 options=[] |&lt;Raw load=&#39;GET /index.html HTTP/1.0 \n\n&#39; |&gt;&gt;&gt;&gt;</code></pre>
<p>We see that a dissected packet has all its fields filled. That's because I consider that each field has its value imposed by the original string. If this is too verbose, the method <code>hide_defaults()</code> will delete every field that has the same value as the default.</p>
<pre><code>&gt;&gt;&gt; c.hide_defaults()
&gt;&gt;&gt; c
&lt;Ether dst=00:0f:66:56:fa:d2 src=00:ae:f3:52:aa:d1 type=0x800 |&lt;IP ihl=5L len=67
 frag=0 proto=TCP chksum=0x783c src=192.168.5.21 dst=66.35.250.151 |&lt;TCP dataofs=5L
 chksum=0xbb39 options=[] |&lt;Raw load=&#39;GET /index.html HTTP/1.0 \n\n&#39; |&gt;&gt;&gt;&gt;</code></pre>
<p>You can read packets from a pcap file and write them to a pcap file. You can make a graphical postscript/pdf dump of a packet or a list of packets (see ugly png image. postcript/pdf are far better quality...).</p>
<pre><code>&gt;&gt;&gt; a=rdpcap(&quot;/spare/captures/isakmp.cap&quot;)
&gt;&gt;&gt; a
&lt;isakmp.cap: UDP:721 TCP:0 ICMP:0 Other:0&gt;
&gt;&gt;&gt; a[423].pdfdump(layer_shift=1)
&gt;&gt;&gt; a[423].psdump(&quot;/tmp/isakmp_pkt.eps&quot;,layer_shift=1)</code></pre>
<div class="figure">
<img src="PacketLife/images/isakmp_dump.png" />

</div>
<p>For the moment, we have only generated one packet. Let see how to specify sets of packets as easily. Each field of the whole packet (ever layers) can be a set. This implicidely define a set of packets, generated using a kind of cartesian product between all the fields.</p>
<pre><code>&gt;&gt;&gt; a=IP(dst=&quot;www.slashdot.org/30&quot;)
&gt;&gt;&gt; a
&lt;IP dst= |&gt;
&gt;&gt;&gt; [p for p in a]
[&lt;IP dst=66.35.250.148 |&gt;, &lt;IP dst=66.35.250.149 |&gt;,
 &lt;IP dst=66.35.250.150 |&gt;, &lt;IP dst=66.35.250.151 |&gt;]
&gt;&gt;&gt; b=IP(ttl=[1,2,(5,9)])
&gt;&gt;&gt; b
&lt;IP ttl=[1, 2, (5, 9)] |&gt;
&gt;&gt;&gt; [p for p in b]
[&lt;IP ttl=1 |&gt;, &lt;IP ttl=2 |&gt;, &lt;IP ttl=5 |&gt;, &lt;IP ttl=6 |&gt;, 
 &lt;IP ttl=7 |&gt;, &lt;IP ttl=8 |&gt;, &lt;IP ttl=9 |&gt;]
&gt;&gt;&gt; c=TCP(dport=[80,443])
&gt;&gt;&gt; [p for p in a/c]
[&lt;IP frag=0 proto=TCP dst=66.35.250.148 |&lt;TCP dport=80 |&gt;&gt;,
 &lt;IP frag=0 proto=TCP dst=66.35.250.148 |&lt;TCP dport=443 |&gt;&gt;,
 &lt;IP frag=0 proto=TCP dst=66.35.250.149 |&lt;TCP dport=80 |&gt;&gt;,
 &lt;IP frag=0 proto=TCP dst=66.35.250.149 |&lt;TCP dport=443 |&gt;&gt;,
 &lt;IP frag=0 proto=TCP dst=66.35.250.150 |&lt;TCP dport=80 |&gt;&gt;,
 &lt;IP frag=0 proto=TCP dst=66.35.250.150 |&lt;TCP dport=443 |&gt;&gt;,
 &lt;IP frag=0 proto=TCP dst=66.35.250.151 |&lt;TCP dport=80 |&gt;&gt;,
 &lt;IP frag=0 proto=TCP dst=66.35.250.151 |&lt;TCP dport=443 |&gt;&gt;]</code></pre>
<p>Some operations (like building the string from a packet) can't work on a set of packets. In these cases, if you forgot to unroll your set of packets, only the first element of the list you forgot to generate will be used to assemble the packet.</p>
<p>Now that we know how to manipulate packets. Let's see how to send them. The <code>send()</code> function will send packets at layer 3. That is to say it will handle routing and layer 2 for you. The sendp() function will work at layer 2. It's up to you to choose the right interface and the right link layer protocol.</p>
<pre><code>&gt;&gt;&gt; send(IP(dst=&quot;1.2.3.4&quot;)/ICMP())
.
Sent 1 packets.
&gt;&gt;&gt; sendp(Ether()/IP(dst=&quot;1.2.3.4&quot;,ttl=(1,4)), iface=&quot;eth1&quot;)
....
Sent 4 packets.
&gt;&gt;&gt; sendp(&quot;I&#39;m travelling on Ethernet&quot;, iface=&quot;eth1&quot;, loop=1, inter=0.2)
................^C
Sent 16 packets.
&gt;&gt;&gt; sendp(rdpcap(&quot;/tmp/pcapfile&quot;)) # tcpreplay
...........
Sent 11 packets.</code></pre>
<p>The function <code>fuzz()</code> is able to change any default value that is not to be calculated (like checksums) by an object whose value is random and whose type is adapted to the field. This enables to quicky built fuzzing templates and send them in loop. In the following example, the IP layer is normal, and the UDP and NTP layers are fuzzed. The UDP checksum will be correct, the UDP destination port will be overloaded by NTP to be 123 and the NTP version will be forced to be 4. All the other ports will be randomized.</p>
<pre><code>&gt;&gt;&gt; send(IP(dst=&quot;target&quot;)/fuzz(UDP()/NTP(version=4)),loop=1)
................^C
Sent 16 packets.</code></pre>
<p>Now, let's try to do some fun things. The <code>sr()</code> function is for sending packets and receiving answers. The function returns a couple of packet and answers, and the unanswered packets. The function <code>sr1()</code> is a variant that only return one packet that answered the packet (or the packet set) sent. The packets must be layer 3 packets (IP, ARP, etc.). The function <code>srp()</code> do the same for layer 2 packets (Ethernet, 802.3, etc.).</p>
<pre><code>&gt;&gt;&gt; p=sr1(IP(dst=&quot;www.slashdot.org&quot;)/ICMP()/&quot;XXXXXXXXXXX&quot;)
Begin emission:
...Finished to send 1 packets.
.*
Received 5 packets, got 1 answers, remaining 0 packets
&gt;&gt;&gt; p
&lt;IP version=4L ihl=5L tos=0x0 len=39 id=15489 flags= frag=0L ttl=42 proto=ICMP
 chksum=0x51dd src=66.35.250.151 dst=192.168.5.21  |&lt;ICMP type=echo-reply
 code=0 chksum=0xee45 id=0x0 seq=0x0 |&lt;Raw load=&#39;XXXXXXXXXXX&#39;
 |&lt;Padding load=&#39;\x00\x00\x00\x00&#39; |&gt;&gt;&gt;&gt;
&gt;&gt;&gt; p.show()
---[ IP ]---
version   = 4L
ihl       = 5L
tos       = 0x0
len       = 39
id        = 15489
flags     = 
frag      = 0L
ttl       = 42
proto     = ICMP
chksum    = 0x51dd
src       = 66.35.250.151
dst       = 192.168.5.21
options   = &#39;&#39;
---[ ICMP ]---
   type      = echo-reply
   code      = 0
   chksum    = 0xee45
   id        = 0x0
   seq       = 0x0
---[ Raw ]---
      load      = &#39;XXXXXXXXXXX&#39;
---[ Padding ]---
         load      = &#39;\x00\x00\x00\x00&#39;</code></pre>
<p>A DNS query (rd = recursion desired). Note the non-null padding coming from my Linksys having the Etherleak flaw.</p>
<pre><code>&gt;&gt;&gt; sr1(IP(dst=&quot;192.168.5.1&quot;)/UDP()/DNS(rd=1,qd=DNSQR(qname=&quot;www.slashdot.org&quot;)))
Begin emission:
Finished to send 1 packets.
..*
Received 3 packets, got 1 answers, remaining 0 packets
&lt;IP version=4L ihl=5L tos=0x0 len=78 id=0 flags=DF frag=0L ttl=64 proto=UDP chksum=0xaf38
 src=192.168.5.1 dst=192.168.5.21 options=&#39;&#39; |&lt;UDP sport=53 dport=53 len=58 chksum=0xd55d
 |&lt;DNS id=0 qr=1L opcode=QUERY aa=0L tc=0L rd=1L ra=1L z=0L rcode=ok qdcount=1 ancount=1
 nscount=0 arcount=0 qd=&lt;DNSQR qname=&#39;www.slashdot.org.&#39; qtype=A qclass=IN |&gt; 
 an=&lt;DNSRR rrname=&#39;www.slashdot.org.&#39; type=A rclass=IN ttl=3560L rdata=&#39;66.35.250.151&#39; |&gt;
 ns=0 ar=0 |&lt;Padding load=&#39;\xc6\x94\xc7\xeb&#39; |&gt;&gt;&gt;&gt;</code></pre>
<p>The &quot;send'n'receive&quot; functions family is the heart of scapy. They return a couple of two lists. The first element is a list of couples (packet sent, answer), and the second element is the list of unanswered packets. These two elements are lists, but they are wrapped by an object to present them better, and to provide them with some methods that do most frequently needed actions.</p>
<pre><code>&gt;&gt;&gt; sr(IP(dst=&quot;192.168.8.1&quot;)/TCP(dport=[21,22,23]))
Received 6 packets, got 3 answers, remaining 0 packets
(&lt;Results: UDP:0 TCP:3 ICMP:0 Other:0&gt;, &lt;Unanswered: UDP:0 TCP:0 ICMP:0 Other:0&gt;)
&gt;&gt;&gt; ans,unans=_
&gt;&gt;&gt; ans.summary()
IP / TCP 192.168.8.14:20 &gt; 192.168.8.1:21 S ==&gt; Ether / IP / TCP 192.168.8.1:21 &gt; 192.168.8.14:20 RA / Padding
IP / TCP 192.168.8.14:20 &gt; 192.168.8.1:22 S ==&gt; Ether / IP / TCP 192.168.8.1:22 &gt; 192.168.8.14:20 RA / Padding
IP / TCP 192.168.8.14:20 &gt; 192.168.8.1:23 S ==&gt; Ether / IP / TCP 192.168.8.1:23 &gt; 192.168.8.14:20 RA / Padding</code></pre>
<p>If there is a limited rate of answers, you can specify a time interval to wait between two packets with the <code>inter</code> parameter. If some packets are lost or if specifying an interval is not enough, you can resend all the unanswered packets, either by calling the function again, directly with the unanswered list, or by specifying a <code>retry</code> parameter. If retry is 3, scapy will try to resend unanswered packets 3 times. If retry is -3, scapy will resend unanswered packets until no more answer is given for the same set of unanswered packets 3 times in a row. The <code>timeout</code> parameter specify the time to wait after the last packet has been sent.</p>
<pre><code>&gt;&gt;&gt; sr(IP(dst=&quot;172.20.29.5/30&quot;)/TCP(dport=[21,22,23]),inter=0.5,retry=-2,timeout=1)
Begin emission:
Finished to send 12 packets.
Begin emission:
Finished to send 9 packets.
Begin emission:
Finished to send 9 packets.

Received 100 packets, got 3 answers, remaining 9 packets
(&lt;Results: UDP:0 TCP:3 ICMP:0 Other:0&gt;, &lt;Unanswered: UDP:0 TCP:9 ICMP:0 Other:0&gt;)</code></pre>
<p>A TCP traceroute.</p>
<pre><code>&gt;&gt;&gt; ans,unans=sr(IP(dst=target, ttl=(4,25),id=RandShort())/TCP(flags=0x2))
*****.******.*.***..*.**Finished to send 22 packets.
***......
Received 33 packets, got 21 answers, remaining 1 packets
&gt;&gt;&gt; for snd,rcv in ans:
...     print snd.ttl, rcv.src, isinstance(rcv.payload, TCP)
... 
5 194.51.159.65 0
6 194.51.159.49 0
4 194.250.107.181 0
7 193.251.126.34 0
8 193.251.126.154 0
9 193.251.241.89 0
10 193.251.241.110 0
11 193.251.241.173 0
13 208.172.251.165 0
12 193.251.241.173 0
14 208.172.251.165 0
15 206.24.226.99 0
16 206.24.238.34 0
17 173.109.66.90 0
18 173.109.88.218 0
19 173.29.39.101 1
20 173.29.39.101 1
21 173.29.39.101 1
22 173.29.39.101 1
23 173.29.39.101 1
24 173.29.39.101 1</code></pre>
<p>Note that the TCP traceroute and some other high-level functions are already coded :</p>
<pre><code>&gt;&gt;&gt; lsc()
sr               : Send and receive packets at layer 3
sr1              : Send packets at layer 3 and return only the first answer
srp              : Send and receive packets at layer 2
srp1             : Send and receive packets at layer 2 and return only the first answer
srloop           : Send a packet at layer 3 in loop and print the answer each time
srploop          : Send a packet at layer 2 in loop and print the answer each time
sniff            : Sniff packets
p0f              : Passive OS fingerprinting: which OS emitted this TCP SYN ?
arpcachepoison   : Poison target&#39;s cache with (your MAC,victim&#39;s IP) couple
send             : Send packets at layer 3
sendp            : Send packets at layer 2
traceroute       : Instant TCP traceroute
arping           : Send ARP who-has requests to determine which hosts are up
ls               : List  available layers, or infos on a given layer
lsc              : List user commands
queso            : Queso OS fingerprinting
nmap_fp          : nmap fingerprinting
report_ports     : portscan a target and output a LaTeX table
dyndns_add       : Send a DNS add message to a nameserver for &quot;name&quot; to have a new &quot;rdata&quot;
dyndns_del       : Send a DNS delete message to a nameserver for &quot;name&quot;</code></pre>
<p>The process of sending packets and receiving is quite complicated. As I wanted to use the PF_PACKET interface to go through netfilter, I also needed to implement an ARP stack and ARP cache, and a LL stack. Well it seems to work, on ethernet and PPP interfaces, but I don't guarantee anything. Anyway, the fact I used a kind of super-socket for that mean that you can switch your IO layer very easily, and use PF_INET/SOCK_RAW, or use PF_PACKET at level 2 (giving the LL header (ethernet,...) and giving yourself mac addresses, ...). I've just added a super socket which use libdnet and libpcap, so that it should be portable :</p>
<pre><code>&gt;&gt;&gt; conf.L3socket=L3dnetSocket
&gt;&gt;&gt; conf.L3listen=L3pcapListenSocket</code></pre>
<p>We can easily capture some packets or even clone tcpdump or tethereal. If no interface is given, sniffing will happen on every interfaces.</p>
<pre><code>&gt;&gt;&gt;  sniff(filter=&quot;icmp and host 66.35.250.151&quot;, count=2)
&lt;Sniffed: UDP:0 TCP:0 ICMP:2 Other:0&gt;
&gt;&gt;&gt;  a=_
&gt;&gt;&gt;  a.nsummary()
0000 Ether / IP / ICMP 192.168.5.21 echo-request 0 / Raw
0001 Ether / IP / ICMP 192.168.5.21 echo-request 0 / Raw
&gt;&gt;&gt;  a[1]
&lt;Ether dst=00:ae:f3:52:aa:d1 src=00:02:15:37:a2:44 type=0x800 |&lt;IP version=4L
 ihl=5L tos=0x0 len=84 id=0 flags=DF frag=0L ttl=64 proto=ICMP chksum=0x3831
 src=192.168.5.21 dst=66.35.250.151 options=&#39;&#39; |&lt;ICMP type=echo-request code=0
 chksum=0x6571 id=0x8745 seq=0x0 |&lt;Raw load=&#39;B\xf7g\xda\x00\x07um\x08\t\n\x0b
 \x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d
 \x1e\x1f !\x22#$%&amp;\&#39;()*+,-./01234567&#39; |&gt;&gt;&gt;&gt;
&gt;&gt;&gt; sniff(iface=&quot;wifi0&quot;, prn=lambda x: x.summary())
802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133
802.11 Management 4 ff:ff:ff:ff:ff:ff / 802.11 Probe Request / Info SSID / Info Rates
802.11 Management 5 00:0a:41:ee:a5:50 / 802.11 Probe Response / Info SSID / Info Rates / Info DSset / Info 133
802.11 Management 4 ff:ff:ff:ff:ff:ff / 802.11 Probe Request / Info SSID / Info Rates
802.11 Management 4 ff:ff:ff:ff:ff:ff / 802.11 Probe Request / Info SSID / Info Rates
802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133
802.11 Management 11 00:07:50:d6:44:3f / 802.11 Authentication
802.11 Management 11 00:0a:41:ee:a5:50 / 802.11 Authentication
802.11 Management 0 00:07:50:d6:44:3f / 802.11 Association Request / Info SSID / Info Rates / Info 133 / Info 149
802.11 Management 1 00:0a:41:ee:a5:50 / 802.11 Association Response / Info Rates / Info 133 / Info 149
802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133
802.11 Management 8 ff:ff:ff:ff:ff:ff / 802.11 Beacon / Info SSID / Info Rates / Info DSset / Info TIM / Info 133
802.11 / LLC / SNAP / ARP who has 172.20.70.172 says 172.20.70.171 / Padding
802.11 / LLC / SNAP / ARP is at 00:0a:b7:4b:9c:dd says 172.20.70.172 / Padding
802.11 / LLC / SNAP / IP / ICMP echo-request 0 / Raw
802.11 / LLC / SNAP / IP / ICMP echo-reply 0 / Raw
&gt;&gt;&gt; sniff(iface=&quot;eth1&quot;, prn=lambda x: x.show())
---[ Ethernet ]---
dst       = 00:ae:f3:52:aa:d1
src       = 00:02:15:37:a2:44
type      = 0x800
---[ IP ]---
   version   = 4L
   ihl       = 5L
   tos       = 0x0
   len       = 84
   id        = 0
   flags     = DF
   frag      = 0L
   ttl       = 64
   proto     = ICMP
   chksum    = 0x3831
   src       = 192.168.5.21
   dst       = 66.35.250.151
   options   = &#39;&#39;
---[ ICMP ]---
      type      = echo-request
      code      = 0
      chksum    = 0x89d9
      id        = 0xc245
      seq       = 0x0
---[ Raw ]---
         load      = &#39;B\xf7i\xa9\x00\x04\x149\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\x22#$%&amp;\&#39;()*+,-./01234567&#39;
---[ Ethernet ]---
dst       = 00:02:15:37:a2:44
src       = 00:ae:f3:52:aa:d1
type      = 0x800
---[ IP ]---
   version   = 4L
   ihl       = 5L
   tos       = 0x0
   len       = 84
   id        = 2070
   flags     = 
   frag      = 0L
   ttl       = 42
   proto     = ICMP
   chksum    = 0x861b
   src       = 66.35.250.151
   dst       = 192.168.5.21
   options   = &#39;&#39;
---[ ICMP ]---
      type      = echo-reply
      code      = 0
      chksum    = 0x91d9
      id        = 0xc245
      seq       = 0x0
---[ Raw ]---
         load      = &#39;B\xf7i\xa9\x00\x04\x149\x08\t\n\x0b\x0c\r\x0e\x0f\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f !\x22#$%&amp;\&#39;()*+,-./01234567&#39;
---[ Padding ]---
            load      = &#39;\n_\x00\x0b&#39;</code></pre>
<p>We can sniff and do passive OS fingerprinting.</p>
<pre><code>&gt;&gt;&gt; p
&lt;Ether dst=00:10:4b:b3:7d:4e src=00:40:33:96:7b:60 type=0x800 |&lt;IP version=4L
 ihl=5L tos=0x0 len=60 id=61681 flags=DF frag=0L ttl=64 proto=TCP chksum=0xb85e
 src=192.168.8.10 dst=192.168.8.1 options=&#39;&#39; |&lt;TCP sport=46511 dport=80
 seq=2023566040L ack=0L dataofs=10L reserved=0L flags=SEC window=5840
 chksum=0x570c urgptr=0 options=[(&#39;Timestamp&#39;, (342940201L, 0L)), (&#39;MSS&#39;, 1460),
 (&#39;NOP&#39;, ()), (&#39;SAckOK&#39;, &#39;&#39;), (&#39;WScale&#39;, 0)] |&gt;&gt;&gt;
&gt;&gt;&gt; p0f(p)
(1.0, [&#39;Linux 2.4.2 - 2.4.14 (1)&#39;])
&gt;&gt;&gt; a=sniff(prn=prnp0f)
(1.0, [&#39;Linux 2.4.2 - 2.4.14 (1)&#39;])
(1.0, [&#39;Linux 2.4.2 - 2.4.14 (1)&#39;])
(0.875, [&#39;Linux 2.4.2 - 2.4.14 (1)&#39;, &#39;Linux 2.4.10 (1)&#39;, &#39;Windows 98 (?)&#39;])
(1.0, [&#39;Windows 2000 (9)&#39;])</code></pre>
<p>The number before the OS guess is the accurracy of the guess.</p>
<p>Demo of both bpf filter and <code>sprintf()</code> method :</p>
<pre><code>&gt;&gt;&gt; a=sniff(filter=&quot;tcp and ( port 25 or port 110 )&quot;,
 prn=lambda x: x.sprintf(&quot;%IP.src%:%TCP.sport% -&gt; %IP.dst%:%TCP.dport%  %2s,TCP.flags% : %TCP.payload%&quot;))
192.168.8.10:47226 -&gt; 213.228.0.14:110   S : 
213.228.0.14:110 -&gt; 192.168.8.10:47226  SA : 
192.168.8.10:47226 -&gt; 213.228.0.14:110   A : 
213.228.0.14:110 -&gt; 192.168.8.10:47226  PA : +OK &lt;13103.1048117923@pop2-1.free.fr&gt;

192.168.8.10:47226 -&gt; 213.228.0.14:110   A : 
192.168.8.10:47226 -&gt; 213.228.0.14:110  PA : USER toto

213.228.0.14:110 -&gt; 192.168.8.10:47226   A : 
213.228.0.14:110 -&gt; 192.168.8.10:47226  PA : +OK 

192.168.8.10:47226 -&gt; 213.228.0.14:110   A : 
192.168.8.10:47226 -&gt; 213.228.0.14:110  PA : PASS tata

213.228.0.14:110 -&gt; 192.168.8.10:47226  PA : -ERR authorization failed

192.168.8.10:47226 -&gt; 213.228.0.14:110   A : 
213.228.0.14:110 -&gt; 192.168.8.10:47226  FA : 
192.168.8.10:47226 -&gt; 213.228.0.14:110  FA : 
213.228.0.14:110 -&gt; 192.168.8.10:47226   A : </code></pre>
<p>Here is an example of a (h)ping-like functionnality : you always send the same set of packets to see if something change :</p>
<pre><code>&gt;&gt;&gt; srloop(IP(dst=&quot;www.target.com/30&quot;)/TCP())
RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding
fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S
RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding
fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S
RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding
fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S
RECV 1: Ether / IP / TCP 192.168.11.99:80 &gt; 192.168.8.14:20 SA / Padding
fail 3: IP / TCP 192.168.8.14:20 &gt; 192.168.11.96:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.98:80 S
        IP / TCP 192.168.8.14:20 &gt; 192.168.11.97:80 S</code></pre>
<p>Now we have a demonstration of the <code>make_table()</code> presentation function. It takes a list as parameter, and a function who returns a 3-uple. The first element is the value on the <em>x</em> axis from an element of the list, the second is about the <em>y</em> value and the third is the value that we want to see at coordinates (<em>x</em>,<em>y</em>). The result is a table. This function has 2 variants, <code>make_lined_table()</code> and <code>make_tex_table()</code> to copy/paste into your LaTeX pentest report. Those functions are available as methods of a result object :</p>
<p>Here we can see a multi-parallel traceroute (scapy already has a multi TCP traceroute function. See later).</p>
<pre><code>&gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;www.test.fr/30&quot;, ttl=(1,6))/TCP())
Received 49 packets, got 24 answers, remaining 0 packets
&gt;&gt;&gt; ans.make_table( lambda (s,r): (s.dst, s.ttl, r.src) )
  216.15.189.192  216.15.189.193  216.15.189.194  216.15.189.195  
1 192.168.8.1     192.168.8.1     192.168.8.1     192.168.8.1     
2 81.57.239.254   81.57.239.254   81.57.239.254   81.57.239.254   
3 213.228.4.254   213.228.4.254   213.228.4.254   213.228.4.254   
4 213.228.3.3     213.228.3.3     213.228.3.3     213.228.3.3     
5 193.251.254.1   193.251.251.69  193.251.254.1   193.251.251.69  
6 193.251.241.174 193.251.241.178 193.251.241.174 193.251.241.178 </code></pre>
<p>Here is a more complex example to identify machines from their IPID field. We can see that 172.20.80.200:22 is answered by the same IP stack than 172.20.80.201 and that 172.20.80.197:25 is not answered by the sape IP stack than other ports on the same IP.</p>
<pre><code>&gt;&gt;&gt; ans,unans=sr(IP(dst=&quot;172.20.80.192/28&quot;)/TCP(dport=[20,21,22,25,53,80]))
Received 142 packets, got 25 answers, remaining 71 packets
&gt;&gt;&gt; ans.make_table(lambda (s,r): (s.dst, s.dport, r.sprintf(&quot;%IP.id%&quot;)))
   172.20.80.196 172.20.80.197 172.20.80.198 172.20.80.200 172.20.80.201 
20 0             4203          7021          -             11562             
21 0             4204          7022          -             11563             
22 0             4205          7023          11561         11564             
25 0             0             7024          -             11565             
53 0             4207          7025          -             11566             
80 0             4028          7026          -             11567             </code></pre>
<p>It can help identify network topologies very easily when playing with TTL, displaying received TTL, etc.</p>
<p>Now scapy has its own routing table, so that you can have your packets routed diffrently than the system.</p>
<pre><code>&gt;&gt;&gt; conf.route
Network         Netmask         Gateway         Iface
127.0.0.0       255.0.0.0       0.0.0.0         lo
192.168.8.0     255.255.255.0   0.0.0.0         eth0
0.0.0.0         0.0.0.0         192.168.8.1     eth0
&gt;&gt;&gt; conf.route.delt(net=&quot;0.0.0.0/0&quot;,gw=&quot;192.168.8.1&quot;)
&gt;&gt;&gt; conf.route.add(net=&quot;0.0.0.0/0&quot;,gw=&quot;192.168.8.254&quot;)
&gt;&gt;&gt; conf.route.add(host=&quot;192.168.1.1&quot;,gw=&quot;192.168.8.1&quot;)
&gt;&gt;&gt; conf.route
Network         Netmask         Gateway         Iface
127.0.0.0       255.0.0.0       0.0.0.0         lo
192.168.8.0     255.255.255.0   0.0.0.0         eth0
0.0.0.0         0.0.0.0         192.168.8.254   eth0
192.168.1.1     255.255.255.255 192.168.8.1     eth0
&gt;&gt;&gt; conf.route.resync()
&gt;&gt;&gt; conf.route
Network         Netmask         Gateway         Iface
127.0.0.0       255.0.0.0       0.0.0.0         lo
192.168.8.0     255.255.255.0   0.0.0.0         eth0
0.0.0.0         0.0.0.0         192.168.8.1     eth0</code></pre>
<p>We can easily plot some harvested values using Gnuplot. For example, we can observe the IP ID patterns to know how many distinct IP stacks are used behind a load balancer :</p>
<pre><code>&gt;&gt;&gt; a,b=sr(IP(dst=&quot;www.target.com&quot;)/TCP(sport=[RandShort()]*1000))
&gt;&gt;&gt; a.plot(lambda x:x[1].id)
&lt;Gnuplot._Gnuplot.Gnuplot instance at 0xb7d6a74c&gt;</code></pre>
<div class="figure">
<img src="PacketLife/images/ipid.png" />

</div>
<p>Scapy also has a powerful TCP traceroute function. Unlike other traceroute programs that wait for each node to reply before going to the next, scapy sends all the packets at the same time. This has the disadvantage that it can't know when to stop (thus the <code>maxttl</code> parameter) but the great advantage that it took less than 3 seconds to get this multi-target traceroute result :</p>
<pre><code>&gt;&gt;&gt; traceroute([&quot;www.yahoo.com&quot;,&quot;www.altavista.com&quot;,&quot;www.wisenut.com&quot;,&quot;www.copernic.com&quot;],maxttl=20)
Received 80 packets, got 80 answers, remaining 0 packets
   193.45.10.88:80    216.109.118.79:80  64.241.242.243:80  66.94.229.254:80   
1  192.168.8.1        192.168.8.1        192.168.8.1        192.168.8.1        
2  82.243.5.254       82.243.5.254       82.243.5.254       82.243.5.254     
3  213.228.4.254      213.228.4.254      213.228.4.254      213.228.4.254      
4  212.27.50.46       212.27.50.46       212.27.50.46       212.27.50.46       
5  212.27.50.37       212.27.50.41       212.27.50.37       212.27.50.41       
6  212.27.50.34       212.27.50.34       213.228.3.234      193.251.251.69     
7  213.248.71.141     217.118.239.149    208.184.231.214    193.251.241.178    
8  213.248.65.81      217.118.224.44     64.125.31.129      193.251.242.98     
9  213.248.70.14      213.206.129.85     64.125.31.186      193.251.243.89     
10 193.45.10.88    SA 213.206.128.160    64.125.29.122      193.251.254.126    
11 193.45.10.88    SA 206.24.169.41      64.125.28.70       216.115.97.178     
12 193.45.10.88    SA 206.24.226.99      64.125.28.209      66.218.64.146      
13 193.45.10.88    SA 206.24.227.106     64.125.29.45       66.218.82.230      
14 193.45.10.88    SA 216.109.74.30      64.125.31.214      66.94.229.254   SA 
15 193.45.10.88    SA 216.109.120.149    64.124.229.109     66.94.229.254   SA 
16 193.45.10.88    SA 216.109.118.79  SA 64.241.242.243  SA 66.94.229.254   SA 
17 193.45.10.88    SA 216.109.118.79  SA 64.241.242.243  SA 66.94.229.254   SA 
18 193.45.10.88    SA 216.109.118.79  SA 64.241.242.243  SA 66.94.229.254   SA 
19 193.45.10.88    SA 216.109.118.79  SA 64.241.242.243  SA 66.94.229.254   SA 
20 193.45.10.88    SA 216.109.118.79  SA 64.241.242.243  SA 66.94.229.254   SA 
(&lt;Traceroute: UDP:0 TCP:28 ICMP:52 Other:0&gt;, &lt;Unanswered: UDP:0 TCP:0 ICMP:0 Other:0&gt;)</code></pre>
<p>The last line is in fact a the result of the function : a traceroute result object and a packet list of unanswered packets. The traceroute result is a more specialised version (a subclass, in fact) of a classic result object. We can save it to consult the traceroute result again a bit later, or to deeply inspect one of the answers, for example to check padding.</p>
<pre><code>&gt;&gt;&gt; result,unans=_
&gt;&gt;&gt; result.show()
   193.45.10.88:80    216.109.118.79:80  64.241.242.243:80  66.94.229.254:80   
1  192.168.8.1        192.168.8.1        192.168.8.1        192.168.8.1        
2  82.251.4.254       82.251.4.254       82.251.4.254       82.251.4.254     
3  213.228.4.254      213.228.4.254      213.228.4.254      213.228.4.254      
[...]
&gt;&gt;&gt; result.filter(lambda x: Padding in x[1])</code></pre>
<p>Like any result object, traceroute objects can be added :</p>
<pre><code>&gt;&gt;&gt; r2,unans=traceroute([&quot;www.voila.com&quot;],maxttl=20)
Received 19 packets, got 19 answers, remaining 1 packets
   195.101.94.25:80   
1  192.168.8.1        
2  82.251.4.254     
3  213.228.4.254      
4  212.27.50.169      
5  212.27.50.162      
6  193.252.161.97     
7  193.252.103.86     
8  193.252.103.77     
9  193.252.101.1      
10 193.252.227.245    
12 195.101.94.25   SA 
13 195.101.94.25   SA 
14 195.101.94.25   SA 
15 195.101.94.25   SA 
16 195.101.94.25   SA 
17 195.101.94.25   SA 
18 195.101.94.25   SA 
19 195.101.94.25   SA 
20 195.101.94.25   SA 
&gt;&gt;&gt;
&gt;&gt;&gt; r3=result+r2
&gt;&gt;&gt; r3.show()
   195.101.94.25:80   212.23.37.13:80    216.109.118.72:80  64.241.242.243:80  66.94.229.254:80   
1  192.168.8.1        192.168.8.1        192.168.8.1        192.168.8.1        192.168.8.1        
2  82.251.4.254       82.251.4.254       82.251.4.254       82.251.4.254       82.251.4.254     
3  213.228.4.254      213.228.4.254      213.228.4.254      213.228.4.254      213.228.4.254      
4  212.27.50.169      212.27.50.169      212.27.50.46       -                  212.27.50.46       
5  212.27.50.162      212.27.50.162      212.27.50.37       212.27.50.41       212.27.50.37       
6  193.252.161.97     194.68.129.168     212.27.50.34       213.228.3.234      193.251.251.69     
7  193.252.103.86     212.23.42.33       217.118.239.185    208.184.231.214    193.251.241.178    
8  193.252.103.77     212.23.42.6        217.118.224.44     64.125.31.129      193.251.242.98     
9  193.252.101.1      212.23.37.13    SA 213.206.129.85     64.125.31.186      193.251.243.89     
10 193.252.227.245    212.23.37.13    SA 213.206.128.160    64.125.29.122      193.251.254.126    
11 -                  212.23.37.13    SA 206.24.169.41      64.125.28.70       216.115.97.178     
12 195.101.94.25   SA 212.23.37.13    SA 206.24.226.100     64.125.28.209      216.115.101.46     
13 195.101.94.25   SA 212.23.37.13    SA 206.24.238.166     64.125.29.45       66.218.82.234      
14 195.101.94.25   SA 212.23.37.13    SA 216.109.74.30      64.125.31.214      66.94.229.254   SA 
15 195.101.94.25   SA 212.23.37.13    SA 216.109.120.151    64.124.229.109     66.94.229.254   SA 
16 195.101.94.25   SA 212.23.37.13    SA 216.109.118.72  SA 64.241.242.243  SA 66.94.229.254   SA 
17 195.101.94.25   SA 212.23.37.13    SA 216.109.118.72  SA 64.241.242.243  SA 66.94.229.254   SA 
18 195.101.94.25   SA 212.23.37.13    SA 216.109.118.72  SA 64.241.242.243  SA 66.94.229.254   SA 
19 195.101.94.25   SA 212.23.37.13    SA 216.109.118.72  SA 64.241.242.243  SA 66.94.229.254   SA 
20 195.101.94.25   SA 212.23.37.13    SA 216.109.118.72  SA 64.241.242.243  SA 66.94.229.254   SA </code></pre>
<p>Traceroute result object also have a very neat feature : they can make a directed graph from all the routes they got, and cluster them by AS. You will need <a href="http://www.research.att.com/sw/tools/graphviz/">graphviz</a>. By default, <a href="http://www.imagemagick.org/">ImageMagick</a> is used to display the graph.</p>
<pre><code>&gt;&gt;&gt; res,unans = traceroute([&quot;www.microsoft.com&quot;,&quot;www.cisco.com&quot;,&quot;www.yahoo.com&quot;,&quot;www.wanadoo.fr&quot;,&quot;www.pacsec.com&quot;],dport=[80,443],maxttl=20,retry=-2)
Received 190 packets, got 190 answers, remaining 10 packets
   193.252.122.103:443 193.252.122.103:80 198.133.219.25:443 198.133.219.25:80  207.46...
1  192.168.8.1         192.168.8.1        192.168.8.1        192.168.8.1        192.16...
2  82.251.4.254        82.251.4.254       82.251.4.254       82.251.4.254       82.251...
3  213.228.4.254       213.228.4.254      213.228.4.254      213.228.4.254      213.22...
[...]
&gt;&gt;&gt; res.graph()                          # piped to ImageMagick&#39;s display program. Image below.
&gt;&gt;&gt; res.graph(type=&quot;ps&quot;,target=&quot;| lp&quot;)   # piped to postscript printer
&gt;&gt;&gt; res.graph(target=&quot;&gt; /tmp/graph.svg&quot;) # saved to file </code></pre>
<div class="figure">
<img src="PacketLife/images/graph_traceroute.gif" alt="Traceroute graph" />
<p class="caption">Traceroute graph</p>
</div>
<p>You also can have a 3D representation of the traceroute. With the right button, you can rotate the scene, with the middle button, you can zoom, with the left button, you can move the scene. If you click on a ball, it's IP will appear/disappear. If you Ctrl-click on a ball, ports 21, 22, 23, 25, 80 and 443 will be scanned and the result displayed.</p>
<pre><code>&gt;&gt;&gt; res.trace3D()</code></pre>
<p><img src="PacketLife/images/trace3d_1.png" alt="3D trace of a traceroute" /><br />
<img src="PacketLife/images/trace3d_2.png" alt="3D trace of a traceroute" /><br />
Provided that your wireless card and driver are correctly configured for frame injection</p>
<pre><code>$ ifconfig wlan0 up
$ iwpriv wlan0 hostapd 1
$ ifconfig wlan0ap up</code></pre>
<p>you can have a kind of FakeAP.</p>
<pre><code>&gt;&gt;&gt; sendp(Dot11(addr1=&quot;ff:ff:ff:ff:ff:ff&quot;,addr2=RandMAC(),addr3=RandMAC())/
          Dot11Beacon(cap=&quot;ESS&quot;)/
          Dot11Elt(ID=&quot;SSID&quot;,info=RandString(RandNum(1,50)))/
          Dot11Elt(ID=&quot;Rates&quot;,info=&#39;\x82\x84\x0b\x16&#39;)/
          Dot11Elt(ID=&quot;DSset&quot;,info=&quot;\x03&quot;)/
          Dot11Elt(ID=&quot;TIM&quot;,info=&quot;\x00\x01\x00\x00&quot;),iface=&quot;wlan0ap&quot;,loop=1)</code></pre>
<br />
<br />
<div>
    <pre><code>
            # Ethernet frame types
            #        This file describes some of the various Ethernet
            #        protocol types that are used on Ethernet networks.
            #
            # This list could be found on:
            #         http://www.iana.org/assignments/ethernet-numbers
            #
            # <name>    <hexnumber> <alias1>...<alias35> #Comment
            #
            IPv4         0800      ip ip4         # Internet IP (IPv4)
            X25        0805
            ARP        0806    ether-arp    #
            FR_ARP        0808            # Frame Relay ARP        [RFC1701]
            BPQ        08FF            # G8BPQ AX.25 Ethernet Packet
            DEC        6000            # DEC Assigned proto
            DNA_DL        6001            # DEC DNA Dump/Load
            DNA_RC        6002            # DEC DNA Remote Console
            DNA_RT        6003            # DEC DNA Routing
            LAT        6004            # DEC LAT
            DIAG        6005            # DEC Diagnostics
            CUST        6006            # DEC Customer use
            SCA        6007            # DEC Systems Comms Arch
            TEB        6558                 # Trans Ether Bridging   [RFC1701]
            RAW_FR      6559                       # Raw Frame Relay        [RFC1701]
            AARP        80F3            # Appletalk AARP
            ATALK        809B                      # Appletalk
            802_1Q        8100    8021q 1q 802.1q    dot1q # 802.1Q Virtual LAN tagged frame
            IPX        8137            # Novell IPX
            NetBEUI        8191            # NetBEUI
            IPv6        86DD    ip6         # IP version 6
            PPP        880B                    # PPP
            ATMMPOA        884C            # MultiProtocol over ATM
            PPP_DISC    8863            # PPPoE discovery messages
            PPP_SES        8864            # PPPoE session messages
            ATMFATE        8884            # Frame-based ATM Transport over Ethernet
            LOOP        9000    loopback     # loop proto
        </code></pre>
</div>
</body>
</html>
