<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1252"><meta name="viewport" content="width=device-width"><title>https://qntm.org/files/perl/perl.html</title><link rel="stylesheet" type="text/css" href="perl_in_2hours_and_30mins_files/viewsource.css"></head><body id="viewsource" class="highlight" style="-moz-tab-size: 4" contextmenu="actions"><pre id="line1"><span></span><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;</span><span>
<span id="line2"></span></span><span>&lt;<span class="start-tag">html</span> <span class="attribute-name">xmlns</span>="<a class="attribute-value">http://www.w3.org/1999/xhtml</a>"&gt;</span><span>
<span id="line3"></span>	</span><span>&lt;<span class="start-tag">head</span>&gt;</span><span>
<span id="line4"></span>		</span><span>&lt;<span class="start-tag">meta</span> <span class="attribute-name">http-equiv</span>="<a class="attribute-value">Content-Type</a>" <span class="attribute-name">content</span>="<a class="attribute-value">application/xhtml+xml; charset=utf-8</a>" <span>/</span>&gt;</span><span>
<span id="line5"></span>		</span><span>&lt;<span class="start-tag">link</span>
<span id="line6"></span>			<span class="attribute-name">rel</span>="<a class="attribute-value">shortcut icon</a>"
<span id="line7"></span>			<span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:https://qntm.org/page/favicon.ico">../../page/favicon.ico</a>"
<span id="line8"></span>		<span>/</span>&gt;</span><span>
<span id="line9"></span>		</span><span>&lt;<span class="start-tag">title</span>&gt;</span><span>Perl</span><span>&lt;/<span class="end-tag">title</span>&gt;</span><span>
<span id="line10"></span>
<span id="line11"></span>		</span><span>&lt;<span class="start-tag">style</span> <span class="attribute-name">type</span>="<a class="attribute-value">text/css</a>"&gt;</span><span>
<span id="line12"></span>			@font-face {
<span id="line13"></span>				font-family: 'Ubuntu Mono';
<span id="line14"></span>				font-style: normal;
<span id="line15"></span>				font-weight: 700;
<span id="line16"></span>				src: local('Ubuntu Mono Bold'), local('UbuntuMono-Bold'), url('https://themes.googleusercontent.com/static/fonts/ubuntumono/v3/ceqTZGKHipo8pJj4molytjqR_3kx9_hJXbbyU8S6IN0.woff') format('woff');
<span id="line17"></span>			}
<span id="line18"></span>			body {
<span id="line19"></span>				padding: 2em;
<span id="line20"></span>				font-family: Tahoma;
<span id="line21"></span>			}
<span id="line22"></span>			pre {
<span id="line23"></span>				margin-left: 2em;
<span id="line24"></span>			}
<span id="line25"></span>			pre, code {
<span id="line26"></span>				color: #348275;
<span id="line27"></span>				font-family: "Ubuntu Mono", monospace;
<span id="line28"></span>			}
<span id="line29"></span>		</span><span>&lt;/<span class="end-tag">style</span>&gt;</span><span>
<span id="line30"></span>	</span><span>&lt;/<span class="end-tag">head</span>&gt;</span><span>
<span id="line31"></span>
<span id="line32"></span>	</span><span class="comment">&lt;!-- https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700|Roboto+Slab:400,700 --&gt;</span><span>
<span id="line33"></span>	</span><span>&lt;<span class="start-tag">body</span>&gt;</span><span>
<span id="line34"></span></span><span>&lt;<span class="start-tag">h1</span>&gt;</span><span>Learn Perl in about 2 hours 30 minutes</span><span>&lt;/<span class="end-tag">h1</span>&gt;</span><span>
<span id="line35"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:https://qntm.org/perl">https://qntm.org/perl</a>"&gt;</span><span>By Sam Hughes</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line36"></span>
<span id="line37"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl is a dynamic, dynamically-typed, high-level, scripting (interpreted) language most comparable with PHP and Python. Perl's syntax owes a lot to ancient shell scripting tools, and it is famed for its overuse of confusing symbols, the majority of which are impossible to Google for. Perl's shell scripting heritage makes it great for writing </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>glue code</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>: scripts which link together other scripts and programs. Perl is ideally suited for processing text data and producing more text data. Perl is widespread, popular, highly portable and well-supported. Perl was designed with the philosophy "There's More Than One Way To Do It" (TMTOWTDI) (contrast with Python, where "there should be one - and preferably only one - obvious way to do it").</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line38"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl has horrors, but it also has some great redeeming features. In this respect it is like every other programming language ever created.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line39"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This document is intended to be informative, not evangelical. It is aimed at people who, like me:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line40"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line41"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>dislike the official Perl documentation at </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perl.org/">http://perl.org</a>"&gt;</span><span>http://perl.org/</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> for being intensely technical and giving far too much space to very unusual edge cases</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line42"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>learn new programming languages most quickly by "axiom and example"</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line43"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>wish Larry Wall would get to the point</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line44"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>already know how to program in general terms</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line45"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>don't care about Perl beyond what's necessary to get the job done.</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line46"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line47"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This document is intended to be as short as possible, but no shorter.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line48"></span>
<span id="line49"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Preliminary notes</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line50"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line51"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The following can be said of almost every declarative statement in this document: "that's not, strictly speaking, true; the situation is actually a lot more complicated". If you see a serious lie, point it out, but I reserve the right to preserve certain critical lies-to-children.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line52"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Throughout this document I'm using example </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>print</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statements to output data but not explicitly appending line breaks. This is done to prevent me from going crazy and to give greater attention to the actual string being printed in each case, which is invariably more important. In many examples, this results in alotofwordsallsmusheduptogetherononeline if the code is run in reality. Try to ignore this.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line53"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line54"></span>
<span id="line55"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Hello world</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line56"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A Perl </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>script</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> is a text file with the extension </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line57"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Here's the full text of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>helloworld.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line58"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line59"></span>use strict;
<span id="line60"></span>use warnings;
<span id="line61"></span>
<span id="line62"></span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/print.html">http://perldoc.perl.org/functions/print.html</a>"&gt;</span><span>print</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> "Hello world";
<span id="line63"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line64"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl scripts are interpreted by the Perl interpreter, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>perl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>perl.exe</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line65"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">bash</a>"&gt;</span><span>
<span id="line66"></span>perl helloworld.pl [arg0 [arg1 [arg2 ...]]]
<span id="line67"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line68"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A few immediate notes. Perl's syntax is highly permissive and it will allow you to do things which result in ambiguous-looking statements with unpredictable behaviour. There's no point in me explaining what these behaviours are, because you want to avoid them. The way to avoid them is to put </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use strict; use warnings;</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> at the very top of every Perl script or module that you create. Statements of the form </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use foo;</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> are </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>pragmas</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>. A pragma is a signal to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>perl.exe</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, which takes effect when initial syntactic validation is being performed, before the program starts running. These lines have no effect when the interpreter encounters them at run time.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line69"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The semicolon, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>;</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, is the statement terminator. The symbol </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>#</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> begins a comment. A comment lasts until the end of the line. Perl has no block comment syntax.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line70"></span>
<span id="line71"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Variables</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line72"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl variables come in three types: </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>scalars</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>arrays</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>hashes</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>. Each type has its own </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>sigil</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>: </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>%</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> respectively. Variables are declared using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>my</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, and remain in scope until the end of the enclosing block or file.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line73"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Scalar variables</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line74"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A scalar variable can contain:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line75"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line76"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>undef</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> (corresponds to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>None</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in Python, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>null</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in PHP)</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line77"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>a number (Perl does not distinguish between an integer and a float)</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line78"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>a string</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line79"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>a reference to any other variable.</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line80"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line81"></span>
<span id="line82"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line83"></span>my $undef = undef;
<span id="line84"></span>print $undef; # prints the empty string "" and raises a warning
<span id="line85"></span>
<span id="line86"></span># implicit undef:
<span id="line87"></span>my $undef2;
<span id="line88"></span>print $undef2; # prints "" and raises exactly the same warning
<span id="line89"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line90"></span>
<span id="line91"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line92"></span>my $num = 4040.5;
<span id="line93"></span>print $num; # "4040.5"
<span id="line94"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line95"></span>
<span id="line96"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line97"></span>my $string = "world";
<span id="line98"></span>print $string; # "world"
<span id="line99"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line100"></span>
<span id="line101"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>(References are coming up shortly.)</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line102"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>String concatenation using the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operator (same as PHP):</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line103"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line104"></span>print "Hello ".$string; # "Hello world"
<span id="line105"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line106"></span>
<span id="line107"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>"Booleans"</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line108"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>Perl has no boolean data type.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> A scalar in an </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>if</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statement evaluates to boolean "false" if and only if it is one of the following:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line109"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line110"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>undef</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line111"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>number </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>0</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line112"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>string </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>""</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line113"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>string </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>"0"</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line114"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line115"></span>
<span id="line116"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The Perl documentation </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>repeatedly</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> claims that functions return "true" or "false" values in certain situations. In practice, when a function is claimed to return "true" it usually returns </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>1</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, and when it is claimed to return false it usually returns the empty string, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>""</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line117"></span>
<span id="line118"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Weak typing</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line119"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>It is impossible to determine whether a scalar contains a "number" or a "string".</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> More precisely, it should never be necessary to do this. Whether a scalar behaves like a number or a string depends on the operator with which it is used. When used as a string, a scalar will behave like a string. When used as a number, a scalar will behave like a number (raising a warning if this isn't possible):</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line120"></span>
<span id="line121"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line122"></span>my $str1 = "4G";
<span id="line123"></span>my $str2 = "4H";
<span id="line124"></span>
<span id="line125"></span>print $str1 .  $str2; # "4G4H"
<span id="line126"></span>print $str1 +  $str2; # "8" with two warnings
<span id="line127"></span>print $str1 eq $str2; # "" (empty string, i.e. false)
<span id="line128"></span>print $str1 == $str2; # "1" with two warnings
<span id="line129"></span>
<span id="line130"></span># The classic error
<span id="line131"></span>print "yes" == "no"; # "1" with two warnings; both values evaluate to 0 when used as numbers
<span id="line132"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line133"></span>
<span id="line134"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The lesson is to always using the correct operator in the correct situation. There are separate operators for comparing scalars as numbers and comparing scalars as strings:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line135"></span>
<span id="line136"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line137"></span># Numerical operators:  <span class="entity"><span>&amp;</span>lt;</span>,  <span class="entity"><span>&amp;</span>gt;</span>, <span class="entity"><span>&amp;</span>lt;</span>=, <span class="entity"><span>&amp;</span>gt;</span>=, ==, !=, <span class="entity"><span>&amp;</span>lt;</span>=<span class="entity"><span>&amp;</span>gt;</span>, +, *
<span id="line138"></span># String operators:    </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlop.html#Equality-Operators">http://perldoc.perl.org/perlop.html#Equality-Operators</a>"&gt;</span><span>lt, gt, le, ge, eq, ne, cmp</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlop.html#Additive-Operators">http://perldoc.perl.org/perlop.html#Additive-Operators</a>"&gt;</span><span>.</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlop.html#Multiplicative-Operators">http://perldoc.perl.org/perlop.html#Multiplicative-Operators</a>"&gt;</span><span>x</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span>
<span id="line139"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line140"></span>
<span id="line141"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Array variables</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line142"></span>
<span id="line143"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>An array variable is a list of scalars indexed by integers beginning at 0. In Python this is known as a </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>list</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>, and in PHP this is known as an </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>array</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>. An array is declared using a parenthesised list of scalars:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line144"></span>
<span id="line145"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line146"></span>my @array = (
<span id="line147"></span>	"print",
<span id="line148"></span>	"these",
<span id="line149"></span>	"strings",
<span id="line150"></span>	"out",
<span id="line151"></span>	"for",
<span id="line152"></span>	"me", # trailing comma is okay
<span id="line153"></span>);
<span id="line154"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line155"></span>
<span id="line156"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You have to use a dollar sign to access a value from an array, because the value being </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>retrieved</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> is not an array but a scalar:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line157"></span>
<span id="line158"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line159"></span>print $array[0]; # "print"
<span id="line160"></span>print $array[1]; # "these"
<span id="line161"></span>print $array[2]; # "strings"
<span id="line162"></span>print $array[3]; # "out"
<span id="line163"></span>print $array[4]; # "for"
<span id="line164"></span>print $array[5]; # "me"
<span id="line165"></span>print $array[6]; # returns undef, prints "" and raises a warning
<span id="line166"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line167"></span>
<span id="line168"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can use negative indices to retrieve entries starting from the end and working backwards:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line169"></span>
<span id="line170"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line171"></span>print $array[-1]; # "me"
<span id="line172"></span>print $array[-2]; # "for"
<span id="line173"></span>print $array[-3]; # "out"
<span id="line174"></span>print $array[-4]; # "strings"
<span id="line175"></span>print $array[-5]; # "these"
<span id="line176"></span>print $array[-6]; # "print"
<span id="line177"></span>print $array[-7]; # returns undef, prints "" and raises a warning
<span id="line178"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line179"></span>
<span id="line180"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>There is no collision between a scalar </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$var</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and an array </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@var</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> containing a scalar entry </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$var[0]</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. There may, however, be reader confusion, so avoid this.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line181"></span>
<span id="line182"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>To get an array's length:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line183"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line184"></span>print "This array has ".(scalar @array)."elements"; # "This array has 6 elements"
<span id="line185"></span>print "The last populated index is ".$#array;       # "The last populated index is 5"
<span id="line186"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line187"></span>
<span id="line188"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The arguments with which the original Perl script was invoked are stored in the </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlvar.html">http://perldoc.perl.org/perlvar.html</a>"&gt;</span><span>built-in array variable</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@ARGV</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line189"></span>
<span id="line190"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Variables can be interpolated into strings:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line191"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line192"></span>print "Hello $string"; # "Hello world"
<span id="line193"></span>print "@array";        # "print these strings out for me"
<span id="line194"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line195"></span>
<span id="line196"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>Caution.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> One day you will put somebody's email address inside a string, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>"jeff@gmail.com"</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. This will cause Perl to look for an array variable called </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@gmail</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to interpolate into the string, and not find it, resulting in a runtime error. Interpolation can be prevented in two ways: by backslash-escaping the sigil, or by using single quotes instead of double quotes.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line197"></span>
<span id="line198"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line199"></span>print "Hello \$string"; # "Hello $string"
<span id="line200"></span>print 'Hello $string';  # "Hello $string"
<span id="line201"></span>print "\@array";        # "@array"
<span id="line202"></span>print '@array';         # "@array"
<span id="line203"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line204"></span>
<span id="line205"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Hash variables</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line206"></span>
<span id="line207"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A hash variable is a list of scalars indexed by strings. In Python this is known as a </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>dictionary</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>, and in PHP it is known as an </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>array</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line208"></span>
<span id="line209"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line210"></span>my %scientists = (
<span id="line211"></span>	"Newton"   =<span class="entity"><span>&amp;</span>gt;</span> "Isaac",
<span id="line212"></span>	"Einstein" =<span class="entity"><span>&amp;</span>gt;</span> "Albert",
<span id="line213"></span>	"Darwin"   =<span class="entity"><span>&amp;</span>gt;</span> "Charles",
<span id="line214"></span>);
<span id="line215"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line216"></span>
<span id="line217"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Notice how similar this declaration is to an array declaration. In fact, the double arrow symbol </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=<span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is called a "fat comma", because it is just a synonym for the comma separator. A hash is declared using a list with an even number of elements, where the even-numbered elements (0, 2, ...) are all taken as strings.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line218"></span>
<span id="line219"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Once again, you have to use a dollar sign to access a value from a hash, because the value being </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>retrieved</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> is not a hash but a scalar:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line220"></span>
<span id="line221"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line222"></span>print $scientists{"Newton"};   # "Isaac"
<span id="line223"></span>print $scientists{"Einstein"}; # "Albert"
<span id="line224"></span>print $scientists{"Darwin"};   # "Charles"
<span id="line225"></span>print $scientists{"Dyson"};    # returns undef, prints "" and raises a warning
<span id="line226"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line227"></span>
<span id="line228"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Note the braces used here. Again, there is no collision between a scalar </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$var</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and a hash </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>%var</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> containing a scalar entry </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$var{"foo"}</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line229"></span>
<span id="line230"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can convert a hash straight to an array with twice as many entries, alternating between key and value (and the reverse is equally easy):</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line231"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line232"></span>my @scientists = %scientists;
<span id="line233"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line234"></span>
<span id="line235"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>However, unlike an array, the keys of a hash have </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>no underlying order</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span>. They will be returned in whatever order is more efficient. So, notice the rearranged </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>order</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> but preserved </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>pairs</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> in the resulting array:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line236"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line237"></span>print "@scientists"; # something like "Einstein Albert Darwin Charles Newton Isaac"
<span id="line238"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line239"></span>
<span id="line240"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>To recap, you have to use </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>square brackets</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> to retrieve a value from an array, but you have to use </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>braces</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> to retrieve a value from a hash. The square brackets are effectively a numerical operator and the braces are effectively a string operator. The fact that the </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>index</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> supplied is a number or a string is of absolutely no significance:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line241"></span>
<span id="line242"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line243"></span>my $data = "orange";
<span id="line244"></span>my @data = ("purple");
<span id="line245"></span>my %data = ( "0" =<span class="entity"><span>&amp;</span>gt;</span> "blue");
<span id="line246"></span>
<span id="line247"></span>print $data;      # "orange"
<span id="line248"></span>print $data[0];   # "purple"
<span id="line249"></span>print $data["0"]; # "purple"
<span id="line250"></span>print $data{0};   # "blue"
<span id="line251"></span>print $data{"0"}; # "blue"
<span id="line252"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line253"></span>
<span id="line254"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Lists</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line255"></span>
<span id="line256"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>list</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> in Perl is a different thing again from either an array or a hash. You've just seen several lists:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line257"></span>
<span id="line258"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line259"></span>(
<span id="line260"></span>	"print",
<span id="line261"></span>	"these",
<span id="line262"></span>	"strings",
<span id="line263"></span>	"out",
<span id="line264"></span>	"for",
<span id="line265"></span>	"me",
<span id="line266"></span>)
<span id="line267"></span>
<span id="line268"></span>(
<span id="line269"></span>	"Newton"   =<span class="entity"><span>&amp;</span>gt;</span> "Isaac",
<span id="line270"></span>	"Einstein" =<span class="entity"><span>&amp;</span>gt;</span> "Albert",
<span id="line271"></span>	"Darwin"   =<span class="entity"><span>&amp;</span>gt;</span> "Charles",
<span id="line272"></span>)
<span id="line273"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line274"></span>
<span id="line275"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>A list is not a variable.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> A list is an ephemeral </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>value</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> which can be </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>assigned</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> to an array or a hash variable. This is why the syntax for declaring array and hash variables is identical. There are many situations where the terms "list" and "array" can be used interchangeably, but there are equally many where lists and arrays display subtly different and extremely confusing behaviour.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line276"></span>
<span id="line277"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Okay. Remember that </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=<span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is just </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>,</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in disguise and then look at this example:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line278"></span>
<span id="line279"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line280"></span>("one", 1, "three", 3, "five", 5)
<span id="line281"></span>("one" =<span class="entity"><span>&amp;</span>gt;</span> 1, "three" =<span class="entity"><span>&amp;</span>gt;</span> 3, "five" =<span class="entity"><span>&amp;</span>gt;</span> 5)
<span id="line282"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line283"></span>
<span id="line284"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The use of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=<span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> hints that one of these lists is an array declaration and the other is a hash declaration. But on their own, neither of them are declarations of anything. They are just lists. </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>Identical</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> lists. Also:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line285"></span>
<span id="line286"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line287"></span>()
<span id="line288"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line289"></span>
<span id="line290"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>There aren't even hints here. This list could be used to declare an empty array or an empty hash and the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>perl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> interpreter clearly has no way of telling either way. Once you understand this odd aspect of Perl, you will also understand why the following fact must be true: </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>List values cannot be nested.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> Try it:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line291"></span>
<span id="line292"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line293"></span>my @array = (
<span id="line294"></span>	"apples",
<span id="line295"></span>	"bananas",
<span id="line296"></span>	(
<span id="line297"></span>		"inner",
<span id="line298"></span>		"list",
<span id="line299"></span>		"several",
<span id="line300"></span>		"entries",
<span id="line301"></span>	),
<span id="line302"></span>	"cherries",
<span id="line303"></span>);
<span id="line304"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line305"></span>
<span id="line306"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl has no way of knowing whether </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>("inner", "list", "several", "entries")</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is supposed to be an inner array or an inner hash. Therefore, Perl assumes that it is neither and </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>flattens the list out into a single long list</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line307"></span>
<span id="line308"></span></span><span>&lt;<span class="start-tag">pre</span>&gt;</span><span>
<span id="line309"></span>print $array[0]; # "apples"
<span id="line310"></span>print $array[1]; # "bananas"
<span id="line311"></span>print $array[2]; # "inner"
<span id="line312"></span>print $array[3]; # "list"
<span id="line313"></span>print $array[4]; # "several"
<span id="line314"></span>print $array[5]; # "entries"
<span id="line315"></span>print $array[6]; # "cherries"
<span id="line316"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line317"></span>
<span id="line318"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The same is true whether the fat comma is used or not:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line319"></span>
<span id="line320"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line321"></span>my %hash = (
<span id="line322"></span>	"beer" =<span class="entity"><span>&amp;</span>gt;</span> "good",
<span id="line323"></span>	"bananas" =<span class="entity"><span>&amp;</span>gt;</span> (
<span id="line324"></span>		"green"  =<span class="entity"><span>&amp;</span>gt;</span> "wait",
<span id="line325"></span>		"yellow" =<span class="entity"><span>&amp;</span>gt;</span> "eat",
<span id="line326"></span>	),
<span id="line327"></span>);
<span id="line328"></span>
<span id="line329"></span># The above raises a warning because the hash was declared using a 7-element list
<span id="line330"></span>
<span id="line331"></span>print $hash{"beer"};    # "good"
<span id="line332"></span>print $hash{"bananas"}; # "green"
<span id="line333"></span>print $hash{"wait"};    # "yellow";
<span id="line334"></span>print $hash{"eat"};     # undef, so prints "" and raises a warning
<span id="line335"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line336"></span>
<span id="line337"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Of course, this does make it easy to concatenate multiple arrays together:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line338"></span>
<span id="line339"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line340"></span>my @bones   = ("humerus", ("jaw", "skull"), "tibia");
<span id="line341"></span>my @fingers = ("thumb", "index", "middle", "ring", "little");
<span id="line342"></span>my @parts   = (@bones, @fingers, ("foot", "toes"), "eyeball", "knuckle");
<span id="line343"></span>print @parts;
<span id="line344"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line345"></span>
<span id="line346"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>More on this shortly.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line347"></span>
<span id="line348"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Context</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line349"></span>
<span id="line350"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl's most distinctive feature is that its code is </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>context-sensitive</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>. </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>Every expression in Perl is evaluated either in scalar context or list context</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span>, depending on whether it is expected to produce a scalar or a list. Without knowing the context in which an expression is evaluated, it is impossible to determine what it will evaluate to.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line351"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A scalar assignment such as </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>my $scalar =</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> evaluates its expression in scalar context. Here, the expression is </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>"Mendeleev"</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line352"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line353"></span>my $scalar = "Mendeleev";
<span id="line354"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line355"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>An array or hash assignment such as </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>my @array =</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>my %hash =</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> evaluates its expression in list context. Here, the expression is </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>("Alpha", "Beta", "Gamma", "Pie")</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> (or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>("Alpha" =<span class="entity"><span>&amp;</span>gt;</span> "Beta", "Gamma" =<span class="entity"><span>&amp;</span>gt;</span> "Pie")</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, the two are equivalent):</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line356"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line357"></span>my @array = ("Alpha", "Beta", "Gamma", "Pie");
<span id="line358"></span>my %hash = ("Alpha" =<span class="entity"><span>&amp;</span>gt;</span> "Beta", "Gamma" =<span class="entity"><span>&amp;</span>gt;</span> "Pie");
<span id="line359"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line360"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A scalar expression evaluated in list context is silently converted into a single-element list:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line361"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line362"></span>my @array = "Mendeleev"; # same as 'my @array = ("Mendeleev");'
<span id="line363"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line364"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>An array expression evaluated in scalar context returns the length of the array:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line365"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line366"></span>my @array = ("Alpha", "Beta", "Gamma", "Pie");
<span id="line367"></span>my $scalar = @array;
<span id="line368"></span>print $scalar; # "4"
<span id="line369"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line370"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A list expression (a list is different from an array, remember?) evaluated in scalar context returns not the length of the list but </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>the final scalar in the list</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line371"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line372"></span>my $scalar = ("Alpha", "Beta", "Gamma", "Pie");
<span id="line373"></span>print $scalar; # "Pie"
<span id="line374"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line375"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/print.html">http://perldoc.perl.org/functions/print.html</a>"&gt;</span><span>print</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> built-in function evaluates all of its arguments in list context. In fact, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>print</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> accepts an unlimited list of arguments and prints each one after the other, which means it can be used to print arrays directly:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line376"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line377"></span>my @array = ("Alpha", "Beta", "Goo");
<span id="line378"></span>my $scalar = "-X-";
<span id="line379"></span>print @array;              # "AlphaBetaGoo";
<span id="line380"></span>print $scalar, @array, 98; # "-X-AlphaBetaGoo98";
<span id="line381"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line382"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>Caution.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> Many Perl expressions and </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlfunc.html">http://perldoc.perl.org/perlfunc.html</a>"&gt;</span><span>built-in functions</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> display radically different behaviour depending on the context in which they are evaluated. The most prominent example is the function </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/reverse.html">http://perldoc.perl.org/functions/reverse.html</a>"&gt;</span><span>reverse</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. In list context, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>reverse</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> treats its arguments as a list, and reverses the list. In scalar context, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>reverse</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> concatenates the whole list together and then reverses it as a single word.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line383"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line384"></span>print reverse "hello world"; # "hello world"
<span id="line385"></span>
<span id="line386"></span>my $string = reverse "hello world";
<span id="line387"></span>print $string; # "dlrow olleh"
<span id="line388"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line389"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can force any expression to be evaluated in scalar context using the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/scalar.html">http://perldoc.perl.org/functions/scalar.html</a>"&gt;</span><span>scalar</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> built-in function:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line390"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line391"></span>print scalar reverse "hello world"; # "dlrow olleh"
<span id="line392"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line393"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Remember how we used </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>scalar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> earlier, to get the length of an array?</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line394"></span>
<span id="line395"></span></span><span>&lt;<span class="start-tag">h2</span> <span class="attribute-name">id</span>="<a class="attribute-value">refs</a>"&gt;</span><span>References and nested data structures</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line396"></span>
<span id="line397"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In the same way that lists cannot contain lists as elements, </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>arrays and hashes cannot contain other arrays and hashes as elements.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> They can only contain scalars. Watch what happens when we try:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line398"></span>
<span id="line399"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line400"></span>my @outer = ("Sun", "Mercury", "Venus", undef, "Mars");
<span id="line401"></span>my @inner = ("Earth", "Moon");
<span id="line402"></span>
<span id="line403"></span>$outer[3] = @inner;
<span id="line404"></span>
<span id="line405"></span>print $outer[3]; # "2"
<span id="line406"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line407"></span>
<span id="line408"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$outer[3]</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is a scalar, so it demands a scalar value. When you try to assign an array value like </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@inner</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to it, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@inner</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is evaluated in scalar context. This is the same as assigning </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>scalar @inner</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, which is the length of array </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@inner</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, which is 2.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line409"></span>
<span id="line410"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>However, a scalar variable may contain a </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>reference</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> to any variable, including an array variable or a hash variable. This is how more complicated data structures are created in Perl.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line411"></span>
<span id="line412"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A reference is created using a backslash.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line413"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line414"></span>my $colour    = "Indigo";
<span id="line415"></span>my $scalarRef = \$colour;
<span id="line416"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line417"></span>
<span id="line418"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Any time you would use the name of a variable, you can instead just put some braces in, and, within the braces, put a </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>reference</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> to a variable instead.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line419"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line420"></span>print $colour;         # "Indigo"
<span id="line421"></span>print $scalarRef;      # e.g. "SCALAR(0x182c180)"
<span id="line422"></span>print ${ $scalarRef }; # "Indigo"
<span id="line423"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line424"></span>
<span id="line425"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>As long as the result is not ambiguous, you can omit the braces too:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line426"></span>
<span id="line427"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line428"></span>print $$scalarRef; # "Indigo"
<span id="line429"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line430"></span>
<span id="line431"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If your reference is a reference to an array or hash variable, you can get data out of it using braces or using the more popular arrow operator, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>-<span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line432"></span>
<span id="line433"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line434"></span>my @colours = ("Red", "Orange", "Yellow", "Green", "Blue");
<span id="line435"></span>my $arrayRef = \@colours;
<span id="line436"></span>
<span id="line437"></span>print $colours[0];       # direct array access
<span id="line438"></span>print ${ $arrayRef }[0]; # use the reference to get to the array
<span id="line439"></span>print $arrayRef-<span class="entity"><span>&amp;</span>gt;</span>[0];    # exactly the same thing
<span id="line440"></span>
<span id="line441"></span>my %atomicWeights = ("Hydrogen" =<span class="entity"><span>&amp;</span>gt;</span> 1.008, "Helium" =<span class="entity"><span>&amp;</span>gt;</span> 4.003, "Manganese" =<span class="entity"><span>&amp;</span>gt;</span> 54.94);
<span id="line442"></span>my $hashRef = \%atomicWeights;
<span id="line443"></span>
<span id="line444"></span>print $atomicWeights{"Helium"}; # direct hash access
<span id="line445"></span>print ${ $hashRef }{"Helium"};  # use a reference to get to the hash
<span id="line446"></span>print $hashRef-<span class="entity"><span>&amp;</span>gt;</span>{"Helium"};     # exactly the same thing - this is very common
<span id="line447"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line448"></span>
<span id="line449"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Declaring a data structure</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line450"></span>
<span id="line451"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Here are four examples, but in practice the last one is the most useful.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line452"></span>
<span id="line453"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line454"></span>my %owner1 = (
<span id="line455"></span>	"name" =<span class="entity"><span>&amp;</span>gt;</span> "Santa Claus",
<span id="line456"></span>	"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "1882-12-25",
<span id="line457"></span>);
<span id="line458"></span>
<span id="line459"></span>my $owner1Ref = \%owner1;
<span id="line460"></span>
<span id="line461"></span>my %owner2 = (
<span id="line462"></span>	"name" =<span class="entity"><span>&amp;</span>gt;</span> "Mickey Mouse",
<span id="line463"></span>	"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "1928-11-18",
<span id="line464"></span>);
<span id="line465"></span>
<span id="line466"></span>my $owner2Ref = \%owner2;
<span id="line467"></span>
<span id="line468"></span>my @owners = ( $owner1Ref, $owner2Ref );
<span id="line469"></span>
<span id="line470"></span>my $ownersRef = \@owners;
<span id="line471"></span>
<span id="line472"></span>my %account = (
<span id="line473"></span>	"number" =<span class="entity"><span>&amp;</span>gt;</span> "12345678",
<span id="line474"></span>	"opened" =<span class="entity"><span>&amp;</span>gt;</span> "2000-01-01",
<span id="line475"></span>	"owners" =<span class="entity"><span>&amp;</span>gt;</span> $ownersRef,
<span id="line476"></span>);
<span id="line477"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line478"></span>
<span id="line479"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>That's obviously unnecessarily laborious, because you can shorten it to:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line480"></span>
<span id="line481"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line482"></span>my %owner1 = (
<span id="line483"></span>	"name" =<span class="entity"><span>&amp;</span>gt;</span> "Santa Claus",
<span id="line484"></span>	"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "1882-12-25",
<span id="line485"></span>);
<span id="line486"></span>
<span id="line487"></span>my %owner2 = (
<span id="line488"></span>	"name" =<span class="entity"><span>&amp;</span>gt;</span> "Mickey Mouse",
<span id="line489"></span>	"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "1928-11-18",
<span id="line490"></span>);
<span id="line491"></span>
<span id="line492"></span>my @owners = ( \%owner1, \%owner2 );
<span id="line493"></span>
<span id="line494"></span>my %account = (
<span id="line495"></span>	"number" =<span class="entity"><span>&amp;</span>gt;</span> "12345678",
<span id="line496"></span>	"opened" =<span class="entity"><span>&amp;</span>gt;</span> "2000-01-01",
<span id="line497"></span>	"owners" =<span class="entity"><span>&amp;</span>gt;</span> \@owners,
<span id="line498"></span>);
<span id="line499"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line500"></span>
<span id="line501"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>It is also possible to declare </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>anonymous</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> arrays and hashes using different symbols. Use square brackets for an anonymous array and braces for an anonymous hash. The value returned in each case is a </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>reference</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> to the anonymous data structure in question. Watch carefully, this results in exactly the same </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>%account</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> as above:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line502"></span>
<span id="line503"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line504"></span># Braces denote an anonymous hash
<span id="line505"></span>my $owner1Ref = {
<span id="line506"></span>	"name" =<span class="entity"><span>&amp;</span>gt;</span> "Santa Claus",
<span id="line507"></span>	"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "1882-12-25",
<span id="line508"></span>};
<span id="line509"></span>
<span id="line510"></span>my $owner2Ref = {
<span id="line511"></span>	"name" =<span class="entity"><span>&amp;</span>gt;</span> "Mickey Mouse",
<span id="line512"></span>	"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "1928-11-18",
<span id="line513"></span>};
<span id="line514"></span>
<span id="line515"></span># Square brackets denote an anonymous array
<span id="line516"></span>my $ownersRef = [ $owner1Ref, $owner2Ref ];
<span id="line517"></span>
<span id="line518"></span>my %account = (
<span id="line519"></span>	"number" =<span class="entity"><span>&amp;</span>gt;</span> "12345678",
<span id="line520"></span>	"opened" =<span class="entity"><span>&amp;</span>gt;</span> "2000-01-01",
<span id="line521"></span>	"owners" =<span class="entity"><span>&amp;</span>gt;</span> $ownersRef,
<span id="line522"></span>);
<span id="line523"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line524"></span>
<span id="line525"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Or, for short (and this is the form you should </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>actually</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> use when declaring complex data structures in-line):</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line526"></span>
<span id="line527"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line528"></span>my %account = (
<span id="line529"></span>	"number" =<span class="entity"><span>&amp;</span>gt;</span> "31415926",
<span id="line530"></span>	"opened" =<span class="entity"><span>&amp;</span>gt;</span> "3000-01-01",
<span id="line531"></span>	"owners" =<span class="entity"><span>&amp;</span>gt;</span> [
<span id="line532"></span>		{
<span id="line533"></span>			"name" =<span class="entity"><span>&amp;</span>gt;</span> "Philip Fry",
<span id="line534"></span>			"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "1974-08-06",
<span id="line535"></span>		},
<span id="line536"></span>		{
<span id="line537"></span>			"name" =<span class="entity"><span>&amp;</span>gt;</span> "Hubert Farnsworth",
<span id="line538"></span>			"DOB"  =<span class="entity"><span>&amp;</span>gt;</span> "2841-04-09",
<span id="line539"></span>		},
<span id="line540"></span>	],
<span id="line541"></span>);
<span id="line542"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line543"></span>
<span id="line544"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Getting information out of a data structure</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line545"></span>
<span id="line546"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Now, let's assume that you still have </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>%account</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> kicking around but everything else (if there was anything else) has fallen out of scope. You can print the information out by reversing the same procedure in each case. Again, here are four examples, of which the last is the most useful:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line547"></span>
<span id="line548"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line549"></span>my $ownersRef = $account{"owners"};
<span id="line550"></span>my @owners    = @{ $ownersRef };
<span id="line551"></span>my $owner1Ref = $owners[0];
<span id="line552"></span>my %owner1    = %{ $owner1Ref };
<span id="line553"></span>my $owner2Ref = $owners[1];
<span id="line554"></span>my %owner2    = %{ $owner2Ref };
<span id="line555"></span>print "Account #", $account{"number"}, "\n";
<span id="line556"></span>print "Opened on ", $account{"opened"}, "\n";
<span id="line557"></span>print "Joint owners:\n";
<span id="line558"></span>print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
<span id="line559"></span>print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
<span id="line560"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line561"></span>
<span id="line562"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Or, for short:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line563"></span>
<span id="line564"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line565"></span>my @owners = @{ $account{"owners"} };
<span id="line566"></span>my %owner1 = %{ $owners[0] };
<span id="line567"></span>my %owner2 = %{ $owners[1] };
<span id="line568"></span>print "Account #", $account{"number"}, "\n";
<span id="line569"></span>print "Opened on ", $account{"opened"}, "\n";
<span id="line570"></span>print "Joint owners:\n";
<span id="line571"></span>print "\t", $owner1{"name"}, " (born ", $owner1{"DOB"}, ")\n";
<span id="line572"></span>print "\t", $owner2{"name"}, " (born ", $owner2{"DOB"}, ")\n";
<span id="line573"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line574"></span>
<span id="line575"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Or using references and the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>-<span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operator:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line576"></span>
<span id="line577"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line578"></span>my $ownersRef = $account{"owners"};
<span id="line579"></span>my $owner1Ref = $ownersRef-<span class="entity"><span>&amp;</span>gt;</span>[0];
<span id="line580"></span>my $owner2Ref = $ownersRef-<span class="entity"><span>&amp;</span>gt;</span>[1];
<span id="line581"></span>print "Account #", $account{"number"}, "\n";
<span id="line582"></span>print "Opened on ", $account{"opened"}, "\n";
<span id="line583"></span>print "Joint owners:\n";
<span id="line584"></span>print "\t", $owner1Ref-<span class="entity"><span>&amp;</span>gt;</span>{"name"}, " (born ", $owner1Ref-<span class="entity"><span>&amp;</span>gt;</span>{"DOB"}, ")\n";
<span id="line585"></span>print "\t", $owner2Ref-<span class="entity"><span>&amp;</span>gt;</span>{"name"}, " (born ", $owner2Ref-<span class="entity"><span>&amp;</span>gt;</span>{"DOB"}, ")\n";
<span id="line586"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line587"></span>
<span id="line588"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And if we completely skip all the intermediate values:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line589"></span>
<span id="line590"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line591"></span>print "Account #", $account{"number"}, "\n";
<span id="line592"></span>print "Opened on ", $account{"opened"}, "\n";
<span id="line593"></span>print "Joint owners:\n";
<span id="line594"></span>print "\t", $account{"owners"}-<span class="entity"><span>&amp;</span>gt;</span>[0]-<span class="entity"><span>&amp;</span>gt;</span>{"name"}, " (born ", $account{"owners"}-<span class="entity"><span>&amp;</span>gt;</span>[0]-<span class="entity"><span>&amp;</span>gt;</span>{"DOB"}, ")\n";
<span id="line595"></span>print "\t", $account{"owners"}-<span class="entity"><span>&amp;</span>gt;</span>[1]-<span class="entity"><span>&amp;</span>gt;</span>{"name"}, " (born ", $account{"owners"}-<span class="entity"><span>&amp;</span>gt;</span>[1]-<span class="entity"><span>&amp;</span>gt;</span>{"DOB"}, ")\n";
<span id="line596"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line597"></span>
<span id="line598"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>How to shoot yourself in the foot with array references</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line599"></span>
<span id="line600"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This array has five elements:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line601"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line602"></span>my @array1 = (1, 2, 3, 4, 5);
<span id="line603"></span>print @array1; # "12345"
<span id="line604"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line605"></span>
<span id="line606"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This array, however, has ONE element (which happens to be a reference to an anonymous, five-element array):</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line607"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line608"></span>my @array2 = [1, 2, 3, 4, 5];
<span id="line609"></span>print @array2; # e.g. "ARRAY(0x182c180)"
<span id="line610"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line611"></span>
<span id="line612"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>scalar</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> is a reference to an anonymous, five-element array:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line613"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line614"></span>my $array3Ref = [1, 2, 3, 4, 5];
<span id="line615"></span>print $array3Ref;      # e.g. "ARRAY(0x22710c0)"
<span id="line616"></span>print @{ $array3Ref }; # "12345"
<span id="line617"></span>print @$array3Ref;     # "12345"
<span id="line618"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line619"></span>
<span id="line620"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Conditionals</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line621"></span>
<span id="line622"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>if</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> ... </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>elsif</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> ... </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>else</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> ...</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line623"></span>
<span id="line624"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>No surprises here, other than the spelling of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>elsif</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line625"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line626"></span>my $word = "antidisestablishmentarianism";
<span id="line627"></span>my $strlen = </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/length.html">http://perldoc.perl.org/functions/length.html</a>"&gt;</span><span>length</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> $word;
<span id="line628"></span>
<span id="line629"></span>if($strlen <span class="entity"><span>&amp;</span>gt;</span>= 15) {
<span id="line630"></span>	print "'", $word, "' is a very long word";
<span id="line631"></span>} elsif(10 <span class="entity"><span>&amp;</span>lt;</span>= $strlen <span class="entity"><span>&amp;</span>amp;</span><span class="entity"><span>&amp;</span>amp;</span> $strlen <span class="entity"><span>&amp;</span>lt;</span> 15) {
<span id="line632"></span>	print "'", $word, "' is a medium-length word";
<span id="line633"></span>} else {
<span id="line634"></span>	print "'", $word, "' is a short word";
<span id="line635"></span>}
<span id="line636"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line637"></span>
<span id="line638"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl provides a shorter "</span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>statement</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>if</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>condition</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>" syntax which is highly recommended for </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>short</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> statements:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line639"></span>
<span id="line640"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line641"></span>print "'", $word, "' is actually enormous" if $strlen &gt;= 20;
<span id="line642"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line643"></span>
<span id="line644"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>unless</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> ... </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>else</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> ...</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line645"></span>
<span id="line646"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line647"></span>my $temperature = 20;
<span id="line648"></span>
<span id="line649"></span>unless($temperature &gt; 30) {
<span id="line650"></span>	print $temperature, " degrees Celsius is not very hot";
<span id="line651"></span>} else {
<span id="line652"></span>	print $temperature, " degrees Celsius is actually pretty hot";
<span id="line653"></span>}
<span id="line654"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line655"></span>
<span id="line656"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>unless</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> blocks are generally best avoided like the plague because they are very confusing. An "</span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>unless</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> [... </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>else</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>]" block can be trivially refactored into an "</span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>if</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> [... </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>else</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>]" block by negating the condition [or by keeping the condition and swapping the blocks]. Mercifully, there is no </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>elsunless</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> keyword.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line657"></span>
<span id="line658"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This, by comparison, is highly recommended because it is so easy to read:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line659"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line660"></span>print "Oh no it's too cold" unless $temperature &gt; 15;
<span id="line661"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line662"></span>
<span id="line663"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Ternary operator</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line664"></span>
<span id="line665"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The ternary operator </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>?:</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> allows simple </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>if</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statements to be embedded in a statement. The canonical use for this is singular/plural forms:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line666"></span>
<span id="line667"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line668"></span>my $gain = 48;
<span id="line669"></span>print "You gained ", $gain, " ", ($gain == 1 ? "experience point" : "experience points"), "!";
<span id="line670"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line671"></span>
<span id="line672"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Aside: singulars and plurals are best spelled out in full in both cases. Don't do something clever like the following, because anybody searching the codebase to replace the words "tooth" or "teeth" will never find this line:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line673"></span>
<span id="line674"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line675"></span>my $lost = 1;
<span id="line676"></span>print "You lost ", $lost, " t", ($lost == 1 ? "oo" : "ee"), "th!";
<span id="line677"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line678"></span>
<span id="line679"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Ternary operators may be nested:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line680"></span>
<span id="line681"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line682"></span>my $eggs = 5;
<span id="line683"></span>print "You have ", $eggs == 0 ? "no eggs" :
<span id="line684"></span>                   $eggs == 1 ? "an egg"  :
<span id="line685"></span>                   "some eggs";
<span id="line686"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line687"></span>
<span id="line688"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>if</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statements evaluate their conditions in scalar context. For example, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>if(@array)</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> returns true if and only if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@array</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> has 1 or more elements. It doesn't matter what those elements are - they may contain </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>undef</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> or other false values for all we care.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line689"></span>
<span id="line690"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Loops</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line691"></span>
<span id="line692"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>There's More Than One Way To Do It.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line693"></span>
<span id="line694"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl has a conventional </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>while</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> loop:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line695"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line696"></span>my $i = 0;
<span id="line697"></span>while($i <span class="entity"><span>&amp;</span>lt;</span> scalar @array) {
<span id="line698"></span>	print $i, ": ", $array[$i];
<span id="line699"></span>	$i++;
<span id="line700"></span>}
<span id="line701"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line702"></span>
<span id="line703"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl also offers the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>until</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> keyword:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line704"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line705"></span>my $i = 0;
<span id="line706"></span>until($i <span class="entity"><span>&amp;</span>gt;</span>= scalar @array) {
<span id="line707"></span>	print $i, ": ", $array[$i];
<span id="line708"></span>	$i++;
<span id="line709"></span>}
<span id="line710"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line711"></span>
<span id="line712"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>These </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>do</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> loops are </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>almost</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> equivalent to the above (a warning would be raised if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@array</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> were empty):</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line713"></span>
<span id="line714"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line715"></span>my $i = 0;
<span id="line716"></span>do {
<span id="line717"></span>	print $i, ": ", $array[$i];
<span id="line718"></span>	$i++;
<span id="line719"></span>} while ($i <span class="entity"><span>&amp;</span>lt;</span> scalar @array);
<span id="line720"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line721"></span>
<span id="line722"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>and</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line723"></span>
<span id="line724"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line725"></span>my $i = 0;
<span id="line726"></span>do {
<span id="line727"></span>	print $i, ": ", $array[$i];
<span id="line728"></span>	$i++;
<span id="line729"></span>} until ($i <span class="entity"><span>&amp;</span>gt;</span>= scalar @array);
<span id="line730"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line731"></span>
<span id="line732"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Basic C-style </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>for</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> loops are available too. Notice how we put a </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>my</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> inside the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>for</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statement, declaring </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$i</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> only for the scope of the loop:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line733"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line734"></span>for(my $i = 0; $i <span class="entity"><span>&amp;</span>lt;</span> scalar @array; $i++) {
<span id="line735"></span>	print $i, ": ", $array[$i];
<span id="line736"></span>}
<span id="line737"></span># $i has ceased to exist here, which is much tidier.
<span id="line738"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line739"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This kind of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>for</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> loop is considered old-fashioned and should be avoided where possible. Native iteration over a list is much nicer. Note: unlike PHP, the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>for</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>foreach</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> keywords are synonyms. Just use whatever looks most readable:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line740"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line741"></span>foreach my $string ( @array ) {
<span id="line742"></span>	print $string;
<span id="line743"></span>}
<span id="line744"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line745"></span>
<span id="line746"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If you do need the indices, the </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlop.html#Range-Operators">http://perldoc.perl.org/perlop.html#Range-Operators</a>"&gt;</span><span>range operator</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>..</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> creates an anonymous list of integers:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line747"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line748"></span>foreach my $i ( 0 .. $#array ) {
<span id="line749"></span>	print $i, ": ", $array[$i];
<span id="line750"></span>}
<span id="line751"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line752"></span>
<span id="line753"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can't iterate over a hash. However, you can iterate over its keys. Use the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>keys</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> built-in function to retrieve an array containing all the keys of a hash. Then use the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>foreach</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> approach that we used for arrays:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line754"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line755"></span>foreach my $key (keys %scientists) {
<span id="line756"></span>	print $key, ": ", $scientists{$key};
<span id="line757"></span>}
<span id="line758"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line759"></span>
<span id="line760"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Since a hash has no underlying order, the keys may be returned in any order. Use the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>sort</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> built-in function to sort the array of keys alphabetically beforehand:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line761"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line762"></span>foreach my $key (sort keys %scientists) {
<span id="line763"></span>	print $key, ": ", $scientists{$key};
<span id="line764"></span>}
<span id="line765"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line766"></span>
<span id="line767"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If you don't provide an explicit iterator, Perl uses a default iterator, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is the first and friendliest of the </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlvar.html">http://perldoc.perl.org/perlvar.html</a>"&gt;</span><span>built-in variables</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line768"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line769"></span>foreach ( @array ) {
<span id="line770"></span>	print $_;
<span id="line771"></span>}
<span id="line772"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line773"></span>
<span id="line774"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If using the default iterator, and you only wish to put a single statement inside your loop, you can use the super-short loop syntax:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line775"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line776"></span>print $_ foreach @array;
<span id="line777"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line778"></span>
<span id="line779"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Loop control</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line780"></span>
<span id="line781"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>next</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>last</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> can be used to control the progress of a loop. In most programming languages these are known as </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>continue</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>break</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> respectively. We can also optionally provide a label for any loop. By convention, labels are written in </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>ALLCAPITALS</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. Having labelled the loop, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>next</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>last</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> may target that label. This example finds primes below 100:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line782"></span>
<span id="line783"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line784"></span>CANDIDATE: for my $candidate ( 2 .. 100 ) {
<span id="line785"></span>	for my $divisor ( 2 .. </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/sqrt.html">http://perldoc.perl.org/functions/sqrt.html</a>"&gt;</span><span>sqrt</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> $candidate ) {
<span id="line786"></span>		next CANDIDATE if $candidate % $divisor == 0;
<span id="line787"></span>	}
<span id="line788"></span>	print $candidate." is prime\n";
<span id="line789"></span>}
<span id="line790"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line791"></span>
<span id="line792"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Array functions</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line793"></span>
<span id="line794"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>In-place array modification</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line795"></span>
<span id="line796"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>We'll use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@stack</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to demonstrate these:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line797"></span>
<span id="line798"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line799"></span>my @stack = ("Fred", "Eileen", "Denise", "Charlie");
<span id="line800"></span>print @stack; # "FredEileenDeniseCharlie"
<span id="line801"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line802"></span>
<span id="line803"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/pop.html">http://perldoc.perl.org/functions/pop.html</a>"&gt;</span><span>pop</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> extracts and returns the final element of the array. This can be thought of as the top of the stack:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line804"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line805"></span>print pop @stack; # "Charlie"
<span id="line806"></span>print @stack;     # "FredEileenDenise"
<span id="line807"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line808"></span>
<span id="line809"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/push.html">http://perldoc.perl.org/functions/push.html</a>"&gt;</span><span>push</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> appends extra elements to the end of the array:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line810"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line811"></span>push @stack, "Bob", "Alice";
<span id="line812"></span>print @stack; # "FredEileenDeniseBobAlice"
<span id="line813"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line814"></span>
<span id="line815"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/shift.html">http://perldoc.perl.org/functions/shift.html</a>"&gt;</span><span>shift</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> extracts and returns the first element of the array:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line816"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line817"></span>print shift @stack; # "Fred"
<span id="line818"></span>print @stack;       # "EileenDeniseBobAlice"
<span id="line819"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line820"></span>
<span id="line821"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/unshift.html">http://perldoc.perl.org/functions/unshift.html</a>"&gt;</span><span>unshift</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> inserts new elements at the beginning of the array:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line822"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line823"></span>unshift @stack, "Hank", "Grace";
<span id="line824"></span>print @stack; # "HankGraceEileenDeniseBobAlice"
<span id="line825"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line826"></span>
<span id="line827"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>pop</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>push</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>shift</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>unshift</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> are all special cases of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/splice.html">http://perldoc.perl.org/functions/splice.html</a>"&gt;</span><span>splice</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>splice</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> removes and returns an array slice, replacing it with a different array slice:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line828"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line829"></span>print splice(@stack, 1, 4, "<span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>lt;</span>", "<span class="entity"><span>&amp;</span>gt;</span><span class="entity"><span>&amp;</span>gt;</span><span class="entity"><span>&amp;</span>gt;</span>"); # "GraceEileenDeniseBob"
<span id="line830"></span>print @stack;                             # "Hank<span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>gt;</span><span class="entity"><span>&amp;</span>gt;</span><span class="entity"><span>&amp;</span>gt;</span>Alice"
<span id="line831"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line832"></span>
<span id="line833"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Creating new arrays from old</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line834"></span>
<span id="line835"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl provides the following functions which act on arrays to create other arrays.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line836"></span>
<span id="line837"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/join.html">http://perldoc.perl.org/functions/join.html</a>"&gt;</span><span>join</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function concatenates many strings into one:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line838"></span>
<span id="line839"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line840"></span>my @elements = ("Antimony", "Arsenic", "Aluminum", "Selenium");
<span id="line841"></span>print @elements;             # "AntimonyArsenicAluminumSelenium"
<span id="line842"></span>print "@elements";           # "Antimony Arsenic Aluminum Selenium"
<span id="line843"></span>print join(", ", @elements); # "Antimony, Arsenic, Aluminum, Selenium"
<span id="line844"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line845"></span>
<span id="line846"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In list context, the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/reverse.html">http://perldoc.perl.org/functions/reverse.html</a>"&gt;</span><span>reverse</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function returns a list in reverse order. In scalar context, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>reverse</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> concatenates the whole list together and then reverses it as a single word.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line847"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line848"></span>print reverse("Hello", "World");        # "WorldHello"
<span id="line849"></span>print reverse("HelloWorld");            # "HelloWorld"
<span id="line850"></span>print scalar reverse("HelloWorld");     # "dlroWolleH"
<span id="line851"></span>print scalar reverse("Hello", "World"); # "dlroWolleH"
<span id="line852"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line853"></span>
<span id="line854"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/map.html">http://perldoc.perl.org/functions/map.html</a>"&gt;</span><span>map</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function takes an array as input and applies an operation to every scalar </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in this array. It then constructs a new array out of the results. The operation to perform is provided in the form of a single expression inside braces:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line855"></span>
<span id="line856"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line857"></span>my @capitals = ("Baton Rouge", "Indianapolis", "Columbus", "Montgomery", "Helena", "Denver", "Boise");
<span id="line858"></span>
<span id="line859"></span>print join ", ", map { uc $_ } @capitals;
<span id="line860"></span># "BATON ROUGE, INDIANAPOLIS, COLUMBUS, MONTGOMERY, HELENA, DENVER, BOISE"
<span id="line861"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line862"></span>
<span id="line863"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/grep.html">http://perldoc.perl.org/functions/grep.html</a>"&gt;</span><span>grep</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function takes an array as input and returns a filtered array as output. The syntax is similar to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>map</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. This time, the second argument is evaluated for each scalar </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in the input array. If a boolean true value is returned, the scalar is put into the output array, otherwise not.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line864"></span>
<span id="line865"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line866"></span>print join ", ", grep { length $_ == 6 } @capitals;
<span id="line867"></span># "Helena, Denver"
<span id="line868"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line869"></span>
<span id="line870"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Obviously, the length of the resulting array is the </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>number of successful matches</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span>, which means you can use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>grep</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to quickly check whether an array contains an element:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line871"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line872"></span>print scalar grep { $_ eq "Columbus" } @capitals; # "1"
<span id="line873"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line874"></span>
<span id="line875"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>grep</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>map</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> may be combined to form </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:https://en.wikipedia.org/wiki/List_comprehension">https://en.wikipedia.org/wiki/List_comprehension</a>"&gt;</span><span>list comprehensions</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>, an exceptionally powerful feature conspicuously absent from many other programming languages.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line876"></span>
<span id="line877"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>By default, the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/sort.html">http://perldoc.perl.org/functions/sort.html</a>"&gt;</span><span>sort</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function returns the input array, sorted into lexical (alphabetical) order:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line878"></span>
<span id="line879"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line880"></span>my @elevations = (19, 1, 2, 100, 3, 98, 100, 1056);
<span id="line881"></span>
<span id="line882"></span>print join ", ", sort @elevations;
<span id="line883"></span># "1, 100, 100, 1056, 19, 2, 3, 98"
<span id="line884"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line885"></span>
<span id="line886"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>However, similar to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>grep</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>map</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, you may supply some code of your own. Sorting is always performed using a series of comparisons between two elements. Your block receives </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$a</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$b</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> as inputs and should return -1 if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$a</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is "less than" </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$b</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, 0 if they are "equal" or 1 if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$a</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is "greater than" </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$b</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line887"></span>
<span id="line888"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>cmp</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operator does exactly this for strings:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line889"></span>
<span id="line890"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line891"></span>print join ", ", sort { $a cmp $b } @elevations;
<span id="line892"></span># "1, 100, 100, 1056, 19, 2, 3, 98"
<span id="line893"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line894"></span>
<span id="line895"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The "spaceship operator", </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span>=<span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, does the same for numbers:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line896"></span>
<span id="line897"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line898"></span>print join ", ", sort { $a <span class="entity"><span>&amp;</span>lt;</span>=<span class="entity"><span>&amp;</span>gt;</span> $b } @elevations;
<span id="line899"></span># "1, 2, 3, 19, 98, 100, 100, 1056"
<span id="line900"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line901"></span>
<span id="line902"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$a</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$b</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> are always scalars, but they can be references to quite complex objects which are difficult to compare. If you need more space for the comparison, you can create a separate subroutine and provide its name instead:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line903"></span>
<span id="line904"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line905"></span>sub comparator {
<span id="line906"></span>	# lots of code...
<span id="line907"></span>	# return -1, 0 or 1
<span id="line908"></span>}
<span id="line909"></span>
<span id="line910"></span>print join ", ", sort comparator @elevations;
<span id="line911"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line912"></span>
<span id="line913"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can't do this for </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>grep</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>map</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operations.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line914"></span>
<span id="line915"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Notice how the subroutine and block are never explicitly provided with </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$a</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$b</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. Like </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$a</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$b</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> are, in fact, global variables which are </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>populated</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> with a pair of values to be compared each time.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line916"></span>
<span id="line917"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Built-in functions</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line918"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>By now you have seen at least a dozen built-in functions: </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>print</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>sort</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>map</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>grep</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>keys</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>scalar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and so on. Built-in functions are one of Perl's greatest strengths. They</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line919"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line920"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>are numerous</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line921"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>are very useful</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line922"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>are </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlfunc.html">http://perldoc.perl.org/perlfunc.html</a>"&gt;</span><span>extensively documented</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line923"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>vary greatly in syntax, so check the documentation</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line924"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>sometimes accept regular expressions as arguments</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line925"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>sometimes accept entire blocks of code as arguments</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line926"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>sometimes don't require commas between arguments</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line927"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>sometimes will consume an arbitrary number of comma-separated arguments and sometimes will not</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line928"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>sometimes will fill in their own arguments if too few are supplied</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line929"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>generally don't require brackets around their arguments except in ambiguous circumstances</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line930"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line931"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The best advice regarding built-in functions is to </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>know that they exist</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span>. Skim the documentation for future reference. If you are carrying out a task which feels like it's low-level and common enough that it's been done many times before, the chances are that it has.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line932"></span>
<span id="line933"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>User-defined subroutines</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line934"></span>
<span id="line935"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Subroutines are declared using the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/sub.html">http://perldoc.perl.org/functions/sub.html</a>"&gt;</span><span>sub</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> keyword. In contrast with built-in functions, user-defined subroutines always accept the same input: a list of scalars. That list may of course have a single element, or be empty. A single scalar is taken as a list with a single element. A hash with </span><span>&lt;<span class="start-tag">var</span>&gt;</span><span>N</span><span>&lt;/<span class="end-tag">var</span>&gt;</span><span> elements is taken as a list with 2</span><span>&lt;<span class="start-tag">var</span>&gt;</span><span>N</span><span>&lt;/<span class="end-tag">var</span>&gt;</span><span> elements.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line936"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Although the brackets are optional, subroutines should always be invoked using brackets, even when called with no arguments. This makes it clear that a subroutine call is happening.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line937"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Once you're inside a subroutine, the arguments are available using the </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlvar.html">http://perldoc.perl.org/perlvar.html</a>"&gt;</span><span>built-in array variable</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. Example:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line938"></span>
<span id="line939"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line940"></span>sub hyphenate {
<span id="line941"></span>
<span id="line942"></span>  # Extract the first argument from the array, ignore everything else
<span id="line943"></span>  my $word = shift @_;
<span id="line944"></span>
<span id="line945"></span>  # An overly clever list comprehension
<span id="line946"></span>  $word = join "-", map { </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/substr.html">http://perldoc.perl.org/functions/substr.html</a>"&gt;</span><span>substr</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> $word, $_, 1 } (0 .. (</span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/length.html">http://perldoc.perl.org/functions/length.html</a>"&gt;</span><span>length</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> $word) - 1);
<span id="line947"></span>  return $word;
<span id="line948"></span>}
<span id="line949"></span>
<span id="line950"></span>print hyphenate("exterminate"); # "e-x-t-e-r-m-i-n-a-t-e"
<span id="line951"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line952"></span>
<span id="line953"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Perl calls by reference</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line954"></span>
<span id="line955"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Unlike almost every other major programming language, Perl calls by reference. This means that the variables or values available inside the body of a subroutine are not copies of the originals. They </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>are</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> the originals.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line956"></span>
<span id="line957"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line958"></span>my $x = 7;
<span id="line959"></span>
<span id="line960"></span>sub reassign {
<span id="line961"></span>  $_[0] = 42;
<span id="line962"></span>}
<span id="line963"></span>
<span id="line964"></span>reassign($x);
<span id="line965"></span>print $x; # "42"
<span id="line966"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line967"></span>
<span id="line968"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If you try something like</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line969"></span>
<span id="line970"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line971"></span>reassign(8);
<span id="line972"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line973"></span>
<span id="line974"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>then an error occurs and execution halts, because the first line of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>reassign()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is equivalent to</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line975"></span>
<span id="line976"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line977"></span>8 = 42;
<span id="line978"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line979"></span>
<span id="line980"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>which is obviously nonsense.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line981"></span>
<span id="line982"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The lesson to learn is that in the body of a subroutine, you should always unpack your arguments before working with them.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line983"></span>
<span id="line984"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Unpacking arguments</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line985"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>There's More Than One Way To unpack </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, but some are superior to others.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line986"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The example subroutine </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>left_pad</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> below pads a string out to the required length using the supplied pad character. (The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>x</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function concatenates multiple copies of the same string in a row.) (Note: for brevity, these subroutines all lack some elementary error checking, i.e. ensuring the pad character is only 1 character, checking that the width is greater than or equal to the length of existing string, checking that all needed arguments were passed at all.)</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line987"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>left_pad</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is typically invoked as follows:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line988"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line989"></span>print left_pad("hello", 10, "+"); # "+++++hello"
<span id="line990"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line991"></span>
<span id="line992"></span></span><span>&lt;<span class="start-tag">ol</span>&gt;</span><span>
<span id="line993"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line994"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Unpacking </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> entry by entry is effective but not terribly pretty:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line995"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line996"></span>sub left_pad {
<span id="line997"></span>	my $oldString = $_[0];
<span id="line998"></span>	my $width     = $_[1];
<span id="line999"></span>	my $padChar   = $_[2];
<span id="line1000"></span>	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
<span id="line1001"></span>	return $newString;
<span id="line1002"></span>}
<span id="line1003"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1004"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1005"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1006"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Unpacking </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> by removing data from it using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>shift</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is recommended for up to 4 arguments:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1007"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1008"></span>sub left_pad {
<span id="line1009"></span>	my $oldString = shift @_;
<span id="line1010"></span>	my $width     = shift @_;
<span id="line1011"></span>	my $padChar   = shift @_;
<span id="line1012"></span>	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
<span id="line1013"></span>	return $newString;
<span id="line1014"></span>}
<span id="line1015"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1016"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If no array is provided to the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>shift</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function, then it operates on </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> implicitly. This approach is seen very commonly:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1017"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1018"></span>sub left_pad {
<span id="line1019"></span>	my $oldString = shift;
<span id="line1020"></span>	my $width     = shift;
<span id="line1021"></span>	my $padChar   = shift;
<span id="line1022"></span>	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
<span id="line1023"></span>	return $newString;
<span id="line1024"></span>}
<span id="line1025"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1026"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Beyond 4 arguments it becomes hard to keep track of what is being assigned where.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1027"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1028"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1029"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can unpack </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> all in one go using multiple simultaneous scalar assignment. Again, this is okay for up to 4 arguments:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1030"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1031"></span>sub left_pad {
<span id="line1032"></span>	my ($oldString, $width, $padChar) = @_;
<span id="line1033"></span>	my $newString = ($padChar x ($width - length $oldString)) . $oldString;
<span id="line1034"></span>	return $newString;
<span id="line1035"></span>}
<span id="line1036"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1037"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1038"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1039"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>For subroutines with large numbers of arguments or where some arguments are optional or cannot be used in combination with others, best practice is to require the user to provide a hash of arguments when calling the subroutine, and then unpack </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> back into that hash of arguments. For this approach, our subroutine call would look a little different:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1040"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1041"></span>print left_pad("oldString" =<span class="entity"><span>&amp;</span>gt;</span> "pod", "width" =<span class="entity"><span>&amp;</span>gt;</span> 10, "padChar" =<span class="entity"><span>&amp;</span>gt;</span> "+");
<span id="line1042"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1043"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And the subroutine itself looks like this:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1044"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1045"></span>sub left_pad {
<span id="line1046"></span>	my %args = @_;
<span id="line1047"></span>	my $newString = ($args{"padChar"} x ($args{"width"} - length $args{"oldString"})) . $args{"oldString"};
<span id="line1048"></span>	return $newString;
<span id="line1049"></span>}
<span id="line1050"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1051"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1052"></span></span><span>&lt;/<span class="end-tag">ol</span>&gt;</span><span>
<span id="line1053"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Returning values</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line1054"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Like other Perl expressions, subroutine calls may display contextual behaviour. You can use the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/wantarray.html">http://perldoc.perl.org/functions/wantarray.html</a>"&gt;</span><span>wantarray</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function (which should be called </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>wantlist</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> but never mind) to detect what context the subroutine is being evaluated in, and return a result appropriate to that context:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1055"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1056"></span>sub contextualSubroutine {
<span id="line1057"></span>	# Caller wants a list. Return a list
<span id="line1058"></span>	return ("Everest", "K2", "Etna") if wantarray;
<span id="line1059"></span>
<span id="line1060"></span>	# Caller wants a scalar. Return a scalar
<span id="line1061"></span>	return 3;
<span id="line1062"></span>}
<span id="line1063"></span>
<span id="line1064"></span>my @array = contextualSubroutine();
<span id="line1065"></span>print @array; # "EverestK2Etna"
<span id="line1066"></span>
<span id="line1067"></span>my $scalar = contextualSubroutine();
<span id="line1068"></span>print $scalar; # "3"
<span id="line1069"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1070"></span>
<span id="line1071"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>System calls</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1072"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Apologies if you already know the following non-Perl-related facts. Every time a process finishes on a Windows or Linux system (and, I assume, on most other systems), it concludes with a 16-bit </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>status word</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>. The highest 8 bits constitute a </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>return code</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> between 0 and 255 inclusive, with 0 conventionally representing unqualified success, and other values representing various degrees of failure. The other 8 bits are less frequently examined - they "reflect mode of failure, like signal death and core dump information".</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1073"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can exit from a Perl script with the return code of your choice (from 0 to 255) using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/exit.html">http://perldoc.perl.org/functions/exit.html</a>"&gt;</span><span>exit</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1074"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl provides More Than One Way To - in a single call - spawn a child process, pause the current script until the child process has finished, and then resume interpretation of the current script. Whichever method is used, you will find that immediately afterwards, the </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlvar.html">http://perldoc.perl.org/perlvar.html</a>"&gt;</span><span>built-in scalar variable</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$?</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> has been populated with the status word that was returned from that child process's termination. You can get the return code by taking just the highest 8 of those 16 bits: </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$? &gt;&gt; 8</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1075"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/system.html">http://perldoc.perl.org/functions/system.html</a>"&gt;</span><span>system</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function can be used to invoke another program with the arguments listed. The value returned by </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>system</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is the same value with which </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$?</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is populated:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1076"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1077"></span>my $rc = system "perl", "anotherscript.pl", "foo", "bar", "baz";
<span id="line1078"></span>$rc &gt;&gt;= 8;
<span id="line1079"></span>print $rc; # "37"
<span id="line1080"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1081"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Alternatively, you can use backticks </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>``</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to run an actual command at the command line and capture the standard output from that command. In scalar context the entire output is returned as a single string. In list context, the entire output is returned as an array of strings, each one representing a line of output.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1082"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1083"></span>my $text = `perl anotherscript.pl foo bar baz`;
<span id="line1084"></span>print $text; # "foobarbaz"
<span id="line1085"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1086"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This is the behaviour which would be seen if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>anotherscript.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> contained, for example:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1087"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1088"></span>use strict;
<span id="line1089"></span>use warnings;
<span id="line1090"></span>
<span id="line1091"></span>print @ARGV;
<span id="line1092"></span>exit 37;
<span id="line1093"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1094"></span>
<span id="line1095"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Files and file handles</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1096"></span>
<span id="line1097"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A scalar variable may contain a </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>file handle</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> instead of a number/string/reference or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>undef</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. A file handle is essentially a reference to a specific location inside a specific file.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1098"></span>
<span id="line1099"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/open.html">http://perldoc.perl.org/functions/open.html</a>"&gt;</span><span>open</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to turn a scalar variable into a file handle. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>open</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> must be supplied with a </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>mode</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>. The mode </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> indicates that we wish to open the file to read from it:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1100"></span>
<span id="line1101"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1102"></span>my $f = "text.txt";
<span id="line1103"></span>my $result = open my $fh, "<span class="entity"><span>&amp;</span>lt;</span>", $f;
<span id="line1104"></span>
<span id="line1105"></span>if(!$result) {
<span id="line1106"></span>	</span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/die.html">http://perldoc.perl.org/functions/die.html</a>"&gt;</span><span>die</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> "Couldn't open '".$f."' for reading because: ".$!;
<span id="line1107"></span>}
<span id="line1108"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1109"></span>
<span id="line1110"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If successful, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>open</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> returns a true value. Otherwise, it returns false and an error message is stuffed into the built-in variable </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$!</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. As seen above, you should always check that the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>open</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operation completed successfully. This checking being rather tedious, a common idiom is:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1111"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1112"></span>open(my $fh, "<span class="entity"><span>&amp;</span>lt;</span>", $f) || die "Couldn't open '".$f."' for reading because: ".$!;
<span id="line1113"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1114"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Note the need for parentheses around the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>open</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> call's arguments.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1115"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>To read a line of text from a filehandle, use the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/readline.html">http://perldoc.perl.org/functions/readline.html</a>"&gt;</span><span>readline</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> built-in function. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>readline</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> returns a full line of text, with a line break intact at the end of it (except possibly for the final line of the file), or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>undef</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> if you've reached the end of the file.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1116"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1117"></span>while(1) {
<span id="line1118"></span>	my $line = readline $fh;
<span id="line1119"></span>	last unless defined $line;
<span id="line1120"></span>	# process the line...
<span id="line1121"></span>}
<span id="line1122"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1123"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>To truncate that possible trailing line break, use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/chomp.html">http://perldoc.perl.org/functions/chomp.html</a>"&gt;</span><span>chomp</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1124"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1125"></span>chomp $line;
<span id="line1126"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1127"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Note that </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>chomp</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> acts on </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$line</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in place. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$line = chomp $line</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is probably not what you want.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1128"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can also use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/eof.html">http://perldoc.perl.org/functions/eof.html</a>"&gt;</span><span>eof</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to detect that the end of the file has been reached:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1129"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1130"></span>while(!eof $fh) {
<span id="line1131"></span>	my $line = readline $fh;
<span id="line1132"></span>	# process $line...
<span id="line1133"></span>}
<span id="line1134"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1135"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>But beware of just using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>while(my $line = readline $fh)</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, because if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$line</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> turns out to be </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>"0"</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, the loop will terminate early. If you want to write something like that, Perl provides the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operator which wraps up </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>readline</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in a fractionally safer way. This is very commonly-seen and perfectly safe:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1136"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1137"></span>while(my $line = <span class="entity"><span>&amp;</span>lt;</span>$fh<span class="entity"><span>&amp;</span>gt;</span>) {
<span id="line1138"></span>	# process $line...
<span id="line1139"></span>}
<span id="line1140"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1141"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And even:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1142"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1143"></span>while(<span class="entity"><span>&amp;</span>lt;</span>$fh<span class="entity"><span>&amp;</span>gt;</span>) {
<span id="line1144"></span>	# process $_...
<span id="line1145"></span>}
<span id="line1146"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1147"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Writing to a file involves first opening it in a different mode. The mode </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span><span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> indicates that we wish to open the file to write to it. (</span><span>&lt;<span class="start-tag">code</span>&gt;</span><span><span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> will clobber the content of the target file if it already exists and has content. To merely append to an existing file, use mode </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span><span class="entity"><span>&amp;</span>gt;</span><span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.) Then, simply provide the filehandle as a zeroth argument for the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>print</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1148"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1149"></span>open(my $fh2, "<span class="entity"><span>&amp;</span>gt;</span>", $f) || die "Couldn't open '".$f."' for writing because: ".$!;
<span id="line1150"></span>print $fh2 "The eagles have left the nest";
<span id="line1151"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1152"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Notice the absence of a comma between </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$fh2</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and the next argument.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1153"></span>
<span id="line1154"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>File handles are actually closed automatically when they drop out of scope, but otherwise:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1155"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1156"></span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/close.html">http://perldoc.perl.org/functions/close.html</a>"&gt;</span><span>close</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> $fh2;
<span id="line1157"></span>close $fh;
<span id="line1158"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1159"></span>
<span id="line1160"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Three filehandles exist as global constants: </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>STDIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>STDOUT</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>STDERR</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. These are open automatically when the script starts. To read a single line of user input:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1161"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1162"></span>my $line = <span class="entity"><span>&amp;</span>lt;</span>STDIN<span class="entity"><span>&amp;</span>gt;</span>;
<span id="line1163"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1164"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>To just wait for the user to hit Enter:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1165"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1166"></span><span class="entity"><span>&amp;</span>lt;</span>STDIN<span class="entity"><span>&amp;</span>gt;</span>;
<span id="line1167"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1168"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Calling </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> with no filehandle reads data from </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>STDIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, or from any files named in arguments when the Perl script was called.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1169"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>As you may have gathered, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>print</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> prints to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>STDOUT</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> by default if no filehandle is named.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1170"></span>
<span id="line1171"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>File tests</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line1172"></span>
<span id="line1173"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The function </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>-e</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is a built-in function which tests whether the named file exists.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1174"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1175"></span>print "what" unless -e "/usr/bin/perl";
<span id="line1176"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1177"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The function </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>-d</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is a built-in function which tests whether the named file is a directory.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1178"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The function </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>-f</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is a built-in function which tests whether the named file is a plain file.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1179"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>These are just three of </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/-X.html">http://perldoc.perl.org/functions/-X.html</a>"&gt;</span><span>a large class of functions</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> of the form </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>-X</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> where </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>X</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is some lower- or upper-case letter. These functions are called </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>file tests</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span>. Note the leading minus sign. In a Google query, the minus sign indicates to exclude results containing this search term. This makes file tests hard to Google for! Just search for "perl file test" instead.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1180"></span>
<span id="line1181"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Regular expressions</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1182"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Regular expressions appear in many languages and tools other than Perl. Perl's core regular expression syntax is basically the same as everywhere else, but Perl's </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>full</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> regular expression capabilities are terrifyingly complex and difficult to understand. The best advice I can give you is to avoid this complexity wherever possible.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1183"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Match operations are performed using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ m//</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. In scalar context, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ m//</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> returns true on success, false on failure.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1184"></span>
<span id="line1185"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1186"></span>my $string = "Hello world";
<span id="line1187"></span>if($string =~ m/(\w+)\s+(\w+)/) {
<span id="line1188"></span>	print "success";
<span id="line1189"></span>}
<span id="line1190"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1191"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Parentheses perform sub-matches. After a successful match operation is performed, the sub-matches get stuffed into the built-in variables </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$1</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$2</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$3</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, ...:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1192"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1193"></span>print $1; # "Hello"
<span id="line1194"></span>print $2; # "world"
<span id="line1195"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1196"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In list context, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ m//</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> returns </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$1</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$2</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, ... as a list.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1197"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1198"></span>my $string = "colourless green ideas sleep furiously";
<span id="line1199"></span>my @matches = $string =~ m/(\w+)\s+((\w+)\s+(\w+))\s+(\w+)\s+(\w+)/;
<span id="line1200"></span>
<span id="line1201"></span>print join ", ", map { "'".$_."'" } @matches;
<span id="line1202"></span># prints "'colourless', 'green ideas', 'green', 'ideas', 'sleep', 'furiously'"
<span id="line1203"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1204"></span>
<span id="line1205"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Substitution operations are performed using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ s///</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1206"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1207"></span>my $string = "Good morning world";
<span id="line1208"></span>$string =~ s/world/Vietnam/;
<span id="line1209"></span>print $string; # "Good morning Vietnam"
<span id="line1210"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1211"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Notice how the contents of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$string</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> have changed. You have to pass a scalar variable on the left-hand side of an </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ s///</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operation. If you pass a literal string, you'll get an error.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1212"></span>
<span id="line1213"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>/g</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> flag indicates "group match".</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1214"></span>
<span id="line1215"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In scalar context, each </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ m//g</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> call finds another match after the previous one, returning true on success, false on failure. You can access </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$1</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and so on afterwards in the usual way. For example:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1216"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1217"></span>my $string = "a tonne of feathers or a tonne of bricks";
<span id="line1218"></span>while($string =~ m/(\w+)/g) {
<span id="line1219"></span>  print "'".$1."'\n";
<span id="line1220"></span>}
<span id="line1221"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1222"></span>
<span id="line1223"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In list context, an </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ m//g</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> call returns all of the matches at once.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1224"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1225"></span>my @matches = $string =~ m/(\w+)/g;
<span id="line1226"></span>print join ", ", map { "'".$_."'" } @matches;
<span id="line1227"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1228"></span>
<span id="line1229"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>An </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ s///g</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> call performs a global search/replace and returns the number of matches. Here, we replace all vowels with the letter "r".</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1230"></span>
<span id="line1231"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1232"></span># Try once without /g.
<span id="line1233"></span>$string =~ s/[aeiou]/r/;
<span id="line1234"></span>print $string; # "r tonne of feathers or a tonne of bricks"
<span id="line1235"></span>
<span id="line1236"></span># Once more.
<span id="line1237"></span>$string =~ s/[aeiou]/r/;
<span id="line1238"></span>print $string; # "r trnne of feathers or a tonne of bricks"
<span id="line1239"></span>
<span id="line1240"></span># And do all the rest using /g
<span id="line1241"></span>$string =~ s/[aeiou]/r/g;
<span id="line1242"></span>print $string, "\n"; # "r trnnr rf frrthrrs rr r trnnr rf brrcks"
<span id="line1243"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1244"></span>
<span id="line1245"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>/i</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> flag makes matches and substitutions case-insensitive.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1246"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>/x</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> flag allows your regular expression to contain whitespace (e.g., line breaks) and comments.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1247"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1248"></span>"Hello world" =~ m/
<span id="line1249"></span>  (\w+) # one or more word characters
<span id="line1250"></span>  [ ]   # single literal space, stored inside a character class
<span id="line1251"></span>  world # literal "world"
<span id="line1252"></span>/x;
<span id="line1253"></span>
<span id="line1254"></span># returns true
<span id="line1255"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1256"></span>
<span id="line1257"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Modules and packages</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1258"></span>
<span id="line1259"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In Perl, modules and packages are different things.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1260"></span>
<span id="line1261"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Modules</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line1262"></span>
<span id="line1263"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>module</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> is a </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> file that you can </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>include</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> in another Perl file (script or module). A module is a text file with exactly the same syntax as a </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> Perl script. An example module might be located at </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>C:\foo\bar\baz\Demo\StringUtils.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>/foo/bar/baz/Demo/StringUtils.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, and read as follows:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1264"></span>
<span id="line1265"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1266"></span>use strict;
<span id="line1267"></span>use warnings;
<span id="line1268"></span>
<span id="line1269"></span>sub zombify {
<span id="line1270"></span>	my $word = shift @_;
<span id="line1271"></span>	$word =~ s/[aeiou]/r/g;
<span id="line1272"></span>	return $word;
<span id="line1273"></span>}
<span id="line1274"></span>
<span id="line1275"></span>return 1;
<span id="line1276"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1277"></span>
<span id="line1278"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Because a module is executed from top to bottom when it is loaded, you need to return a true value at the end to show that it was loaded successfully.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1279"></span>
<span id="line1280"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>So that the Perl interpreter can find them, directories containing Perl modules should be listed in your environment variable </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>PERL5LIB</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> before calling </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>perl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. List the root directory containing the modules, don't list the module directories or the modules themselves:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1281"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">bash</a>"&gt;</span><span>
<span id="line1282"></span>set PERL5LIB="C:\foo\bar\baz;%PERL5LIB%"
<span id="line1283"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1284"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>or</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1285"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">bash</a>"&gt;</span><span>
<span id="line1286"></span>export PERL5LIB="/foo/bar/baz:$PERL5LIB"
<span id="line1287"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1288"></span>
<span id="line1289"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Once the Perl module is created and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>perl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> knows where to look for it, you can use the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/require.html">http://perldoc.perl.org/functions/require.html</a>"&gt;</span><span>require</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> built-in function to search for and execute it during a Perl script. For example, calling </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>require Demo::StringUtils</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> causes the Perl interpreter to search each directory listed in </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>PERL5LIB</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> in turn, looking for a file called </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Demo/StringUtils.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. After the module has been executed, the subroutines that were defined there suddenly become available to the main script. Our example script might be called </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>main.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and read as follows:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1290"></span>
<span id="line1291"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1292"></span>use strict;
<span id="line1293"></span>use warnings;
<span id="line1294"></span>
<span id="line1295"></span>require Demo::StringUtils;
<span id="line1296"></span>
<span id="line1297"></span>print zombify("i want brains"); # "r wrnt brrrns"
<span id="line1298"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1299"></span>
<span id="line1300"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>Note the use of the double colon </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>::</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> as a directory separator.</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1301"></span>
<span id="line1302"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Now a problem surfaces: if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>main.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> contains many </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>require</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> calls, and each of the modules so loaded contains more </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>require</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> calls, then it can become difficult to track down the original declaration of the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>zombify()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> subroutine. The solution to this problem is to use packages.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1303"></span>
<span id="line1304"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Packages</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line1305"></span>
<span id="line1306"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>package</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> is a namespace in which subroutines can be declared. Any subroutine you declare is implicitly declared within the current package. At the beginning of execution, you are in the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>main</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> package, but you can switch package using the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/package.html">http://perldoc.perl.org/functions/package.html</a>"&gt;</span><span>package</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> built-in function:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1307"></span>
<span id="line1308"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1309"></span>use strict;
<span id="line1310"></span>use warnings;
<span id="line1311"></span>
<span id="line1312"></span>sub subroutine {
<span id="line1313"></span>	print "universe";
<span id="line1314"></span>}
<span id="line1315"></span>
<span id="line1316"></span>package Food::Potatoes;
<span id="line1317"></span>
<span id="line1318"></span># no collision:
<span id="line1319"></span>sub subroutine {
<span id="line1320"></span>	print "kingedward";
<span id="line1321"></span>}
<span id="line1322"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1323"></span>
<span id="line1324"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span></span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>Note the use of the double colon </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>::</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> as a namespace separator.</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1325"></span>
<span id="line1326"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Any time you call a subroutine, you implicitly call a subroutine which is inside the current package. Alternatively, you can explicitly provide a package. See what happens if we continue the above script:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1327"></span>
<span id="line1328"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1329"></span>subroutine();                 # "kingedward"
<span id="line1330"></span>main::subroutine();           # "universe"
<span id="line1331"></span>Food::Potatoes::subroutine(); # "kingedward"
<span id="line1332"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1333"></span>
<span id="line1334"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>So the logical solution to the problem described above is to modify </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>C:\foo\bar\baz\Demo\StringUtils.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>/foo/bar/baz/Demo/StringUtils.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to read:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1335"></span>
<span id="line1336"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1337"></span>use strict;
<span id="line1338"></span>use warnings;
<span id="line1339"></span>
<span id="line1340"></span></span><span>&lt;<span class="start-tag">ins</span>&gt;</span><span>package Demo::StringUtils;</span><span>&lt;/<span class="end-tag">ins</span>&gt;</span><span>
<span id="line1341"></span>
<span id="line1342"></span>sub zombify {
<span id="line1343"></span>	my $word = shift @_;
<span id="line1344"></span>	$word =~ s/[aeiou]/r/g;
<span id="line1345"></span>	return $word;
<span id="line1346"></span>}
<span id="line1347"></span>
<span id="line1348"></span>return 1;
<span id="line1349"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1350"></span>
<span id="line1351"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And modify </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>main.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to read:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1352"></span>
<span id="line1353"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1354"></span>use strict;
<span id="line1355"></span>use warnings;
<span id="line1356"></span>
<span id="line1357"></span>require Demo::StringUtils;
<span id="line1358"></span>
<span id="line1359"></span>print </span><span>&lt;<span class="start-tag">ins</span>&gt;</span><span>Demo::StringUtils::</span><span>&lt;/<span class="end-tag">ins</span>&gt;</span><span>zombify("i want brains"); # "r wrnt brrrns"
<span id="line1360"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1361"></span>
<span id="line1362"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Now read this next bit carefully.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1363"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Packages and modules are two completely separate and distinct features of the Perl programming language. The fact that they both use the same double colon delimiter is a huge red herring. It is possible to switch packages multiple times over the course of a script or module, and it is possible to use the same package declaration in multiple locations in multiple files. Calling </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>require Foo::Bar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>does not</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> look for and load a file with a </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>package Foo::Bar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> declaration somewhere inside it, nor does it necessarily load subroutines in the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Foo::Bar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> namespace. Calling </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>require Foo::Bar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> merely loads a file called </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Foo/Bar.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, which need not have </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>any</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> kind of package declaration inside it at all, and in fact might declare </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>package Baz::Qux</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and other nonsense inside it for all you know.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1364"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Likewise, a subroutine call </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Baz::Qux::processThis()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> need not necessarily have been declared inside a file named </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Baz/Qux.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. It could have been declared </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>literally anywhere</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1365"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Separating these two concepts is one of the stupidest features of Perl, and treating them as separate concepts invariably results in chaotic, maddening code. Fortunately for us, the majority of Perl programmers obey the following two laws:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1366"></span></span><span>&lt;<span class="start-tag">ol</span>&gt;</span><span>
<span id="line1367"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>A Perl script (</span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>.pl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> file) must always contain exactly zero </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>package</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> declarations.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1368"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>A Perl module (</span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> file) must always contain exactly one </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>package</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> declaration, corresponding exactly to its name and location.</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> E.g. module </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Demo/StringUtils.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> must begin with </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>package Demo::StringUtils</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1369"></span></span><span>&lt;/<span class="end-tag">ol</span>&gt;</span><span>
<span id="line1370"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Because of this, in practice you will find that most "packages" and "modules" produced by reliable third parties </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>can</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> be regarded and referred to interchangeably. However, it is important that you do not take this for granted, because one day you </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>will</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> meet code produced by a madman.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1371"></span>
<span id="line1372"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Object-oriented Perl</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1373"></span>
<span id="line1374"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl is not a great language for OO programming. Perl's OO capabilities were grafted on after the fact, and this shows.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1375"></span>
<span id="line1376"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line1377"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>An </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>object</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> is simply a reference (i.e. a scalar variable) which happens to know which class its referent belongs to. To tell a reference that its referent belongs to a class, use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/bless.html">http://perldoc.perl.org/functions/bless.html</a>"&gt;</span><span>bless</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. To find out what class a reference's referent belongs to (if any), use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/ref.html">http://perldoc.perl.org/functions/ref.html</a>"&gt;</span><span>ref</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1378"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>method</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> is simply a subroutine that expects an object (or, in the case of class methods, a package name) as its first argument. Object methods are invoked using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$obj-<span class="entity"><span>&amp;</span>gt;</span>method()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>; class methods are invoked using </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Package::Name-<span class="entity"><span>&amp;</span>gt;</span>method()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1379"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>class</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> is simply a package that happens to contain methods.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1380"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line1381"></span>
<span id="line1382"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A quick example makes this clearer. An example module </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Animal.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> containing a class </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Animal</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> reads like this:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1383"></span>
<span id="line1384"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1385"></span>use strict;
<span id="line1386"></span>use warnings;
<span id="line1387"></span>
<span id="line1388"></span>package Animal;
<span id="line1389"></span>
<span id="line1390"></span>sub eat {
<span id="line1391"></span>	# First argument is always the object to act upon.
<span id="line1392"></span>	my $self = shift @_;
<span id="line1393"></span>
<span id="line1394"></span>	foreach my $food ( @_ ) {
<span id="line1395"></span>		if($self-<span class="entity"><span>&amp;</span>gt;</span>can_eat($food)) {
<span id="line1396"></span>			print "Eating ", $food;
<span id="line1397"></span>		} else {
<span id="line1398"></span>			print "Can't eat ", $food;
<span id="line1399"></span>		}
<span id="line1400"></span>	}
<span id="line1401"></span>}
<span id="line1402"></span>
<span id="line1403"></span># For the sake of argument, assume an Animal can eat anything.
<span id="line1404"></span>sub can_eat {
<span id="line1405"></span>	return 1;
<span id="line1406"></span>}
<span id="line1407"></span>
<span id="line1408"></span>return 1;
<span id="line1409"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1410"></span>
<span id="line1411"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And we might make use of this class like so:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1412"></span>
<span id="line1413"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1414"></span>require Animal;
<span id="line1415"></span>
<span id="line1416"></span>my $animal = {
<span id="line1417"></span>	"legs"   =<span class="entity"><span>&amp;</span>gt;</span> 4,
<span id="line1418"></span>	"colour" =<span class="entity"><span>&amp;</span>gt;</span> "brown",
<span id="line1419"></span>};                       # $animal is an ordinary hash reference
<span id="line1420"></span>print ref $animal;       # "HASH"
<span id="line1421"></span>bless $animal, "Animal"; # now it is an object of class "Animal"
<span id="line1422"></span>print ref $animal;       # "Animal"
<span id="line1423"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1424"></span>
<span id="line1425"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Note: literally any reference can be blessed into any class. It's up to you to ensure that (1) the referent can actually be used as an instance of this class and (2) that the class in question exists and has been loaded.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1426"></span>
<span id="line1427"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>You can still work with the original hash in the usual way:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1428"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1429"></span>print "Animal has ", $animal-&gt;{"legs"}, " leg(s)";
<span id="line1430"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1431"></span>
<span id="line1432"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>But you can now also call methods on the object using the same </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>-<span class="entity"><span>&amp;</span>gt;</span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operator, like so:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1433"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1434"></span>$animal-<span class="entity"><span>&amp;</span>gt;</span>eat("insects", "curry", "eucalyptus");
<span id="line1435"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1436"></span>
<span id="line1437"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This final call is equivalent to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Animal::eat($animal, "insects", "curry", "eucalyptus")</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1438"></span>
<span id="line1439"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Constructors</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line1440"></span>
<span id="line1441"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A constructor is a class method which returns a new object. If you want one, just declare one. You can use any name you like. For class methods, the first argument passed is not an object but a class name. In this case, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>"Animal"</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1442"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1443"></span>use strict;
<span id="line1444"></span>use warnings;
<span id="line1445"></span>
<span id="line1446"></span>package Animal;
<span id="line1447"></span>
<span id="line1448"></span>sub new {
<span id="line1449"></span>	my $class = shift @_;
<span id="line1450"></span>	return bless { "legs" =<span class="entity"><span>&amp;</span>gt;</span> 4, "colour" =<span class="entity"><span>&amp;</span>gt;</span> "brown" }, $class;
<span id="line1451"></span>}
<span id="line1452"></span>
<span id="line1453"></span># ...etc.
<span id="line1454"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1455"></span>
<span id="line1456"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And then use it like so:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1457"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1458"></span>my $animal = Animal-<span class="entity"><span>&amp;</span>gt;</span>new();
<span id="line1459"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1460"></span>
<span id="line1461"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span>Inheritance</span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line1462"></span>
<span id="line1463"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>To create a class inheriting from a parent class, use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use parent</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. Let's suppose we subclassed </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Animal</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> with </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Koala</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, located at </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Koala.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1464"></span>
<span id="line1465"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1466"></span>use strict;
<span id="line1467"></span>use warnings;
<span id="line1468"></span>
<span id="line1469"></span>package Koala;
<span id="line1470"></span>
<span id="line1471"></span># Inherit from Animal
<span id="line1472"></span>use parent ("Animal");
<span id="line1473"></span>
<span id="line1474"></span># Override one method
<span id="line1475"></span>sub can_eat {
<span id="line1476"></span>	my $self = shift @_; # Not used. You could just put "shift @_;" here
<span id="line1477"></span>	my $food = shift @_;
<span id="line1478"></span>	return $food eq "eucalyptus";
<span id="line1479"></span>}
<span id="line1480"></span>
<span id="line1481"></span>return 1;
<span id="line1482"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1483"></span>
<span id="line1484"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And some sample code:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1485"></span>
<span id="line1486"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1487"></span>use strict;
<span id="line1488"></span>use warnings;
<span id="line1489"></span>
<span id="line1490"></span>require Koala;
<span id="line1491"></span>
<span id="line1492"></span>my $koala = Koala-<span class="entity"><span>&amp;</span>gt;</span>new();
<span id="line1493"></span>
<span id="line1494"></span>$koala-<span class="entity"><span>&amp;</span>gt;</span>eat("insects", "curry", "eucalyptus"); # eat only the eucalyptus
<span id="line1495"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1496"></span>
<span id="line1497"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This final method call tries to invoke </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Koala::eat($koala, "insects", "curry", "eucalyptus")</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, but a subroutine </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>eat()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> isn't defined in the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Koala</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> package. However, because </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Koala</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> has a parent class </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Animal</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, the Perl interpreter tries calling </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Animal::eat($koala, "insects", "curry", "eucalyptus")</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> instead, which works. Note how the class </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Animal</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> was loaded automatically by </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Koala.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1498"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Since </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use parent</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> accepts a list of parent class names, Perl supports multiple inheritance, with all the benefits and horrors this entails.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1499"></span>
<span id="line1500"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> blocks</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1501"></span>
<span id="line1502"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/BEGIN.html">http://perldoc.perl.org/functions/BEGIN.html</a>"&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block is executed as soon as </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>perl</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> has finished parsing that block, even before it parses the rest of the file. It is ignored at execution time:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1503"></span>
<span id="line1504"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1505"></span>use strict;
<span id="line1506"></span>use warnings;
<span id="line1507"></span>
<span id="line1508"></span>print "This gets printed second";
<span id="line1509"></span>
<span id="line1510"></span>BEGIN {
<span id="line1511"></span>	print "This gets printed first";
<span id="line1512"></span>}
<span id="line1513"></span>
<span id="line1514"></span>print "This gets printed third";
<span id="line1515"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1516"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block is always executed first. If you create multiple </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> blocks (don't), they are executed in order from top to bottom as the compiler encounters them. A </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block always executes first even if it is placed halfway through a script (don't do this) or at the end (or this). </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>Do not mess with the natural order of code. Put </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> blocks at the beginning!</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1517"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block is executed as soon as the block has been parsed. Once this is done, </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>parsing</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> resumes at the end of the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block. Only once the whole script or module has been parsed is any of the code outside of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> blocks executed.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1518"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1519"></span>use strict;
<span id="line1520"></span>use warnings;
<span id="line1521"></span>
<span id="line1522"></span>print "This 'print' statement gets parsed successfully but never executed";
<span id="line1523"></span>
<span id="line1524"></span>BEGIN {
<span id="line1525"></span>	print "This gets printed first";
<span id="line1526"></span>}
<span id="line1527"></span>
<span id="line1528"></span>print "This, also, is parsed successfully but never executed";
<span id="line1529"></span>
<span id="line1530"></span>...because e4h8v3oitv8h4o8gch3o84c3 there is a huge parsing error down here.
<span id="line1531"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1532"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Because they are executed at compilation time, a </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block placed inside a conditional block will </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>still</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> be executed first, even if the conditional evaluates to false and despite the fact that the conditional </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>has not been evaluated at all yet</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> and in fact </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>may never be evaluated</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1533"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1534"></span>if(0) {
<span id="line1535"></span>	BEGIN {
<span id="line1536"></span>		print "This will definitely get printed";
<span id="line1537"></span>	}
<span id="line1538"></span>	print "Even though this won't";
<span id="line1539"></span>}
<span id="line1540"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1541"></span></span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>Do not put </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> blocks in conditionals!</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> If you want to do something conditionally at compile time, you need to put the conditional </span><span>&lt;<span class="start-tag">em</span>&gt;</span><span>inside</span><span>&lt;/<span class="end-tag">em</span>&gt;</span><span> the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block:</span><span class="error" title="No p element in scope but a p end tag seen.">&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1542"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1543"></span>BEGIN {
<span id="line1544"></span>	if($condition) {
<span id="line1545"></span>		# etc.
<span id="line1546"></span>	}
<span id="line1547"></span>}
<span id="line1548"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1549"></span>
<span id="line1550"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1551"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Okay. Now that you understand the obtuse behaviour and semantics of packages, modules, class methods and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> blocks, I can explain the exceedingly commonly-seen </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/functions/use.html">http://perldoc.perl.org/functions/use.html</a>"&gt;</span><span>use</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> function.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1552"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The following three statements:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1553"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1554"></span>use Caterpillar ("crawl", "pupate");
<span id="line1555"></span>use Caterpillar ();
<span id="line1556"></span>use Caterpillar;
<span id="line1557"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1558"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>are respectively equivalent to:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1559"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1560"></span>BEGIN {
<span id="line1561"></span>	require Caterpillar;
<span id="line1562"></span>	Caterpillar-<span class="entity"><span>&amp;</span>gt;</span>import("crawl", "pupate");
<span id="line1563"></span>}
<span id="line1564"></span>BEGIN {
<span id="line1565"></span>	require Caterpillar;
<span id="line1566"></span>}
<span id="line1567"></span>BEGIN {
<span id="line1568"></span>	require Caterpillar;
<span id="line1569"></span>	Caterpillar-<span class="entity"><span>&amp;</span>gt;</span>import();
<span id="line1570"></span>}
<span id="line1571"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1572"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line1573"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>No, the three examples are not in the wrong order. It is just that Perl is dumb.</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1574"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>A </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> call is a disguised </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>BEGIN</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> block. The same warnings apply. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statements must always be placed at the top of the file, and </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>never inside conditionals</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1575"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is not a built-in Perl function. It is a </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>user-defined class method</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span>. The burden is on the programmer of the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> package to define or inherit </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, and the method could theoretically accept anything as arguments and do anything with those arguments. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use Caterpillar;</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> could do anything. Consult the documentation of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to find out exactly what will happen.</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1576"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>Notice how </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>require Caterpillar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> loads a </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>module</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span> named </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, whereas </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar-<span class="entity"><span>&amp;</span>gt;</span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> calls the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> subroutine that was defined inside the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>package</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span>. Let's hope the module and the package coincide!</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1577"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line1578"></span>
<span id="line1579"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Exporter</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1580"></span>
<span id="line1581"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The most common way to define an </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> method is to inherit it from the </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/Exporter.html">http://perldoc.perl.org/Exporter.html</a>"&gt;</span><span>Exporter</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> module. Exporter is a core module, and a </span><span>&lt;<span class="start-tag">i</span>&gt;</span><span>de facto</span><span>&lt;/<span class="end-tag">i</span>&gt;</span><span> core feature of the Perl programming language. In Exporter's implementation of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, the list of arguments that you pass in is interpreted as a list of subroutine names. When a subroutine is </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>ed, it becomes available in the current package as well as in its own original package.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1582"></span>
<span id="line1583"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>This concept is easiest to grasp using an example. Here's what </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> looks like:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1584"></span>
<span id="line1585"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1586"></span>use strict;
<span id="line1587"></span>use warnings;
<span id="line1588"></span>
<span id="line1589"></span>package Caterpillar;
<span id="line1590"></span>
<span id="line1591"></span># Inherit from Exporter
<span id="line1592"></span>use parent ("Exporter");
<span id="line1593"></span>
<span id="line1594"></span>sub crawl  { print "inch inch";   }
<span id="line1595"></span>sub eat    { print "chomp chomp"; }
<span id="line1596"></span>sub pupate { print "bloop bloop"; }
<span id="line1597"></span>
<span id="line1598"></span>our @EXPORT_OK = ("crawl", "eat");
<span id="line1599"></span>
<span id="line1600"></span>return 1;
<span id="line1601"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1602"></span>
<span id="line1603"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The package variable </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@EXPORT_OK</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> should contain a list of subroutine names.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1604"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Another piece of code may then </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> these subroutines by name, typically using a </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statement:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1605"></span>
<span id="line1606"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1607"></span>use strict;
<span id="line1608"></span>use warnings;
<span id="line1609"></span>use Caterpillar ("crawl");
<span id="line1610"></span>
<span id="line1611"></span>crawl(); # "inch inch"
<span id="line1612"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1613"></span>
<span id="line1614"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In this case, the current package is </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>main</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, so the </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>crawl()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> call is actually a call to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>main::crawl()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, which (because it was imported) maps to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar::crawl()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1615"></span>
<span id="line1616"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Note: regardless of the content of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@EXPORT_OK</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, every method can always be called "longhand":</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1617"></span>
<span id="line1618"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1619"></span>use strict;
<span id="line1620"></span>use warnings;
<span id="line1621"></span>use Caterpillar (); # no subroutines named, no import() call made
<span id="line1622"></span>
<span id="line1623"></span># and yet...
<span id="line1624"></span>Caterpillar::crawl();  # "inch inch"
<span id="line1625"></span>Caterpillar::eat();    # "chomp chomp"
<span id="line1626"></span>Caterpillar::pupate(); # "bloop bloop"
<span id="line1627"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1628"></span>
<span id="line1629"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl has no private methods. Customarily, a method intended for private use is named with a leading underscore or two.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1630"></span>
<span id="line1631"></span></span><span>&lt;<span class="start-tag">h3</span>&gt;</span><span></span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@EXPORT</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">h3</span>&gt;</span><span>
<span id="line1632"></span>
<span id="line1633"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The Exporter module also defines a package variable called </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@EXPORT</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, which can also be populated with a list of subroutine names.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1634"></span>
<span id="line1635"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1636"></span>use strict;
<span id="line1637"></span>use warnings;
<span id="line1638"></span>
<span id="line1639"></span>package Caterpillar;
<span id="line1640"></span>
<span id="line1641"></span># Inherit from Exporter
<span id="line1642"></span>use parent ("Exporter");
<span id="line1643"></span>
<span id="line1644"></span>sub crawl  { print "inch inch";   }
<span id="line1645"></span>sub eat    { print "chomp chomp"; }
<span id="line1646"></span>sub pupate { print "bloop bloop"; }
<span id="line1647"></span>
<span id="line1648"></span>our @EXPORT = ("crawl", "eat", "pupate");
<span id="line1649"></span>
<span id="line1650"></span>return 1;
<span id="line1651"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1652"></span>
<span id="line1653"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The subroutines named in </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@EXPORT</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> are exported if </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> is called with no arguments at all, which is what happens here:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1654"></span>
<span id="line1655"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1656"></span>use strict;
<span id="line1657"></span>use warnings;
<span id="line1658"></span>use Caterpillar; # calls import() with no arguments
<span id="line1659"></span>
<span id="line1660"></span>crawl();  # "inch inch"
<span id="line1661"></span>eat();    # "chomp chomp"
<span id="line1662"></span>pupate(); # "bloop bloop"
<span id="line1663"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1664"></span>
<span id="line1665"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>But notice how we are back in a situation where, without other clues, it might not be easy to tell where </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>crawl()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> was originally defined. The moral of this story is twofold:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1666"></span></span><span>&lt;<span class="start-tag">ol</span>&gt;</span><span>
<span id="line1667"></span></span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>When creating a module which makes use of Exporter, never use </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>@EXPORT</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> to export subroutines by default. Always make the user call subroutines "longhand" or </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> them explicitly (using e.g. </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use Caterpillar ("crawl")</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, which is a strong clue to look in </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>Caterpillar.pm</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> for the definition of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>crawl()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>).</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1668"></span></span><span>&lt;<span class="start-tag">li</span>&gt;</span><span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>When </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>ing a module which makes use of Exporter, always explicitly name the subroutines you want to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. If you don't want to </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>import()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> any subroutines and wish to refer to them longhand, you must supply an explicit empty list: </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use Caterpillar ()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1669"></span></span><span>&lt;/<span class="end-tag">ol</span>&gt;</span><span>
<span id="line1670"></span>
<span id="line1671"></span></span><span>&lt;<span class="start-tag">h2</span>&gt;</span><span>Miscellaneous notes</span><span>&lt;/<span class="end-tag">h2</span>&gt;</span><span>
<span id="line1672"></span></span><span>&lt;<span class="start-tag">ul</span>&gt;</span><span>
<span id="line1673"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1674"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>The core module </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/Data/Dumper.html">http://perldoc.perl.org/Data/Dumper.html</a>"&gt;</span><span>Data::Dumper</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span> can be used to output an arbitrary scalar to the screen. This is an essential debug tool.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1675"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1676"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1677"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>There's an alternate syntax, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>qw{ }</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, for declaring arrays. This is often seen in </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>use</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> statements:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1678"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1679"></span>use Account qw{create open close suspend delete};
<span id="line1680"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1681"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>There are </span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators">http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators</a>"&gt;</span><span>many other quote-like operators</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1682"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1683"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1684"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>In </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ m//</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ s///</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> operations, you can use braces instead of slashes as the regex delimiters. This is quite useful if your regex contains a lot of slashes, which would otherwise need escaping with backslashes. For example, </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ m{///}</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> matches three literal forward slashes, and </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>=~ s{^https?://}{}</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> removes the protocol part of a URL.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1685"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1686"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1687"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Perl does have </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>CONSTANTS</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. These are discouraged now, but weren't always. Constants are actually just subroutine calls with omitted brackets.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1688"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1689"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1690"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Sometimes people omit quotes around hash keys, writing </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$hash{key}</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> instead of </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$hash{"key"}</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>. They can get away with it because in this situation the bareword </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>key</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> occurs as the string </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>"key"</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, as opposed to a subroutine call </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>key()</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1691"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1692"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1693"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>If you see a block of unformatted code wrapped in a delimiter with double chevrons, like </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators">http://perldoc.perl.org/perlop.html#Quote-and-Quote-like-Operators</a>"&gt;</span><span><span class="entity"><span>&amp;</span>lt;</span><span class="entity"><span>&amp;</span>lt;</span>EOF</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span>, the magic word to Google for is "here-doc".</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1694"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1695"></span>	</span><span>&lt;<span class="start-tag">li</span>&gt;</span><span>
<span id="line1696"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>Warning! Many built-in functions can be called with no arguments, </span><span>&lt;<span class="start-tag">strong</span>&gt;</span><span>causing them to operate on </span><span>&lt;<span class="start-tag">code</span>&gt;</span><span>$_</span><span>&lt;/<span class="end-tag">code</span>&gt;</span><span> instead</span><span>&lt;/<span class="end-tag">strong</span>&gt;</span><span>. Hopefully this will help you understand formations like:</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1697"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1698"></span>print foreach @array;
<span id="line1699"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1700"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>and</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1701"></span></span><span>&lt;<span class="start-tag">pre</span> <span class="attribute-name">class</span>="<a class="attribute-value">perl</a>"&gt;</span><span>
<span id="line1702"></span>foreach ( @array ) {
<span id="line1703"></span>	next unless defined;
<span id="line1704"></span>}
<span id="line1705"></span></span><span>&lt;/<span class="end-tag">pre</span>&gt;</span><span>
<span id="line1706"></span>		</span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>I dislike this formation because it can lead to problems when refactoring.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1707"></span>	</span><span>&lt;/<span class="end-tag">li</span>&gt;</span><span>
<span id="line1708"></span></span><span>&lt;/<span class="end-tag">ul</span>&gt;</span><span>
<span id="line1709"></span>
<span id="line1710"></span></span><span>&lt;<span class="start-tag">p</span>&gt;</span><span>And that's two and a half hours.</span><span>&lt;/<span class="end-tag">p</span>&gt;</span><span>
<span id="line1711"></span></span><span>&lt;<span class="start-tag">h4</span>&gt;</span><span></span><span>&lt;<span class="start-tag">a</span> <span class="attribute-name">href</span>="<a class="attribute-value" href="view-source:https://qntm.org/perl">https://qntm.org/perl</a>"&gt;</span><span>Back to Things Of Interest</span><span>&lt;/<span class="end-tag">a</span>&gt;</span><span></span><span>&lt;/<span class="end-tag">h4</span>&gt;</span><span>
<span id="line1712"></span>
<span id="line1713"></span></span><span>&lt;<span class="start-tag">script</span> <span class="attribute-name">type</span>="<a class="attribute-value">text/javascript</a>"&gt;</span><span></span><span>&lt;!</span><span>--
<span id="line1714"></span>	var sc_project=667681; 
<span id="line1715"></span>	var sc_invisible=1; 
<span id="line1716"></span>	var sc_partition=5; 
<span id="line1717"></span>	var sc_security="f56850e2"; 
<span id="line1718"></span>	var sc_remove_link=1; 
<span id="line1719"></span>// --&gt;</span><span>&lt;/<span class="end-tag">script</span>&gt;</span><span>
<span id="line1720"></span></span><span>&lt;<span class="start-tag">script</span> <span class="attribute-name">type</span>="<a class="attribute-value">text/javascript</a>" <span class="attribute-name">src</span>="<a class="attribute-value" href="view-source:https://statcounter.com/counter/counter_xhtml.js">https://statcounter.com/counter/counter_xhtml.js</a>"&gt;</span><span></span><span>&lt;/<span class="end-tag">script</span>&gt;</span><span>
<span id="line1721"></span>
<span id="line1722"></span></span><span>&lt;<span class="start-tag">noscript</span>&gt;</span><span>
<span id="line1723"></span>	</span><span>&lt;</span><span>p&gt;</span><span>&lt;</span><span>img
<span id="line1724"></span>		class="statcounter"
<span id="line1725"></span>		src="https://c6.statcounter.com/counter.php?sc_project=667681&amp;amp;java=0&amp;amp;security=f56850e2&amp;amp;invisible=1"
<span id="line1726"></span>		alt="website statistics"
<span id="line1727"></span>	/&gt;</span><span>&lt;/<span></span>p</span><span>&gt;
<span id="line1728"></span></span><span>&lt;/<span class="end-tag">noscript</span>&gt;</span><span>
<span id="line1729"></span></span><span>&lt;/<span class="end-tag">body</span>&gt;</span><span>
<span id="line1730"></span></span><span>&lt;/<span class="end-tag">html</span>&gt;</span><span></span></pre><menu type="context" id="actions"><menuitem id="goToLine" label="Go to Line" accesskey="L"></menuitem><menuitem id="wrapLongLines" label="Wrap Long Lines" type="checkbox"></menuitem><menuitem id="highlightSyntax" label="Syntax Highlighting" type="checkbox" checked="true"></menuitem></menu></body></html>